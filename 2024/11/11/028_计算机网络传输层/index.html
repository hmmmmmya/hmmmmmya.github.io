<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>028_计算机网络传输层 | Hymns</title><meta name="author" content="Hymns"><meta name="copyright" content="Hymns"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="在计算机网络中，传输层（Transport Layer）负责在网络端点之间传输数据。它是 OSI 模型中的第四层，提供了关键的功能，以确保数据在网络中能够有效、可靠地传输。以下是传输层的一些主要功能和作用：">
<meta property="og:type" content="article">
<meta property="og:title" content="028_计算机网络传输层">
<meta property="og:url" content="https://hmmmmmya.github.io/2024/11/11/028_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%B1%82/index.html">
<meta property="og:site_name" content="Hymns">
<meta property="og:description" content="在计算机网络中，传输层（Transport Layer）负责在网络端点之间传输数据。它是 OSI 模型中的第四层，提供了关键的功能，以确保数据在网络中能够有效、可靠地传输。以下是传输层的一些主要功能和作用：">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hmmmmmya.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2024-11-11T03:30:45.000Z">
<meta property="article:modified_time" content="2024-11-11T03:55:28.394Z">
<meta property="article:author" content="Hymns">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hmmmmmya.github.io/img/butterfly-icon.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://hmmmmmya.github.io/2024/11/11/028_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%B1%82/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '028_计算机网络传输层',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/atom.xml" title="Hymns" type="application/atom+xml">
</head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/cover1.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hymns</span></a><a class="nav-page-title" href="/"><span class="site-name">028_计算机网络传输层</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">028_计算机网络传输层</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-11T03:30:45.000Z" title="发表于 2024-11-11 11:30:45">2024-11-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-11T03:55:28.394Z" title="更新于 2024-11-11 11:55:28">2024-11-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>在计算机网络中，传输层（Transport Layer）负责在网络端点之间传输数据。它是 OSI 模型中的第四层，提供了关键的功能，以确保数据在网络中能够有效、可靠地传输。以下是传输层的一些主要功能和作用：</p>
<span id="more"></span>

<h2 id="传输层的主要功能"><a href="#传输层的主要功能" class="headerlink" title="传输层的主要功能"></a>传输层的主要功能</h2><h3 id="1-数据分段和重组"><a href="#1-数据分段和重组" class="headerlink" title="1. 数据分段和重组"></a>1. <strong>数据分段和重组</strong></h3><p>传输层将应用层传递下来的数据分割成更小的段（segments），每个段包含必要的控制信息。接收方传输层会将这些段重组成原始的数据流。</p>
<h3 id="2-传输控制"><a href="#2-传输控制" class="headerlink" title="2. 传输控制"></a>2. <strong>传输控制</strong></h3><p>传输层确保数据可靠传输。常见协议如 TCP（传输控制协议）提供了数据包的确认（acknowledgment）、序号（sequence numbering）、超时重传（retransmission）、流控制（flow control）和拥塞控制（congestion control）等机制。</p>
<h3 id="3-端到端通信"><a href="#3-端到端通信" class="headerlink" title="3. 端到端通信"></a>3. <strong>端到端通信</strong></h3><p>传输层建立并管理端到端的通信连接。TCP 协议通过三次握手（three-way handshake）建立连接，确保通信双方准备就绪，而 UDP（用户数据报协议）则是不可靠的连接，通常用于实时应用如视频流和在线游戏。</p>
<h3 id="4-数据完整性"><a href="#4-数据完整性" class="headerlink" title="4. 数据完整性"></a>4. <strong>数据完整性</strong></h3><p>传输层通过校验和（checksum）等技术，确保数据在传输过程中没有被篡改或损坏。TCP 协议在接收数据时会计算并验证校验和，以检测传输中的错误。</p>
<h3 id="5-多路复用和解复用"><a href="#5-多路复用和解复用" class="headerlink" title="5. 多路复用和解复用"></a>5. <strong>多路复用和解复用</strong></h3><p>传输层允许多个应用程序同时使用网络连接，通过使用端口号（port numbers）来区分不同的应用流。多路复用（multiplexing）指的是将多个应用数据流合并到一个物理网络连接上，而解复用（demultiplexing）则是将收到的数据分配给正确的应用程序。</p>
<h3 id="6-流控制"><a href="#6-流控制" class="headerlink" title="6. 流控制"></a>6. <strong>流控制</strong></h3><p>传输层可以管理发送方和接收方的速率，避免网络拥塞和数据丢失。流控制机制确保发送方不会过快地发送数据，以至于接收方来不及处理。</p>
<h3 id="7-拥塞控制"><a href="#7-拥塞控制" class="headerlink" title="7. 拥塞控制"></a>7. <strong>拥塞控制</strong></h3><p>在 TCP 协议中，传输层负责监控网络的拥塞状态，并动态调整数据发送速率，以避免网络过载。常见的拥塞控制算法包括慢启动（slow start）、拥塞避免（congestion avoidance）等。</p>
<p>通过提供上述功能，传输层在确保数据可靠、有效传输方面发挥了关键作用。</p>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><p>Socket 通信主要涉及传输层和应用层。具体来说：</p>
<ol>
<li><p><strong>传输层</strong>：在传输层，Socket 与 TCP（传输控制协议）和 UDP（用户数据报协议）一起工作。TCP 提供可靠的、面向连接的通信，而 UDP 提供无连接的、不可靠的通信。Socket 用于建立和管理这些传输层连接。</p>
</li>
<li><p><strong>应用层</strong>：应用层通过 Socket 接口与传输层进行交互，发送和接收数据。例如，HTTP、FTP、SMTP 等应用层协议都是通过 Socket 来进行数据传输的。</p>
</li>
</ol>
<p>Socket 可以看作是传输层与应用层之间的桥梁，使得应用程序能够方便地使用网络传输功能。</p>
<p>socket 是传输层提供给应用层的编程接口。</p>
<p>socket 是应用层与传输层之间的抽象，socket 不止是 TCP 才有，UDP 也有 socket。</p>
<p>socket 是基于文件描述符的，socket 是文件描述符的一种。</p>
<h3 id="传输层的信息要发送到哪里"><a href="#传输层的信息要发送到哪里" class="headerlink" title="传输层的信息要发送到哪里"></a>传输层的信息要发送到哪里</h3><p>传输层的信息会发送到传输层协议所指定的端口，这些端口是与应用层的特定服务或应用程序关联的。例如，当你在浏览器中访问一个网站时，HTTP 协议会在传输层使用 TCP 端口 80 或者 HTTPS 的 443 端口来发送和接收数据。</p>
<p>具体过程如下：</p>
<ol>
<li><p><strong>发送端</strong>：传输层将应用层的数据封装成数据段，并添加头部信息（例如源端口号和目标端口号）。然后，它将这些数据段传递给网络层。</p>
</li>
<li><p><strong>网络层</strong>：网络层会根据 IP 地址将数据包路由到目标计算机。</p>
</li>
<li><p><strong>接收端</strong>：在目标计算机上，网络层接收到数据包后，会将其传递给传输层。传输层根据数据包中的端口号，将数据转发给对应的应用程序。</p>
</li>
</ol>
<p>因此，传输层的信息最终会交给运行在指定端口上的应用程序或服务。</p>
<h3 id="使用传输层所需的信息"><a href="#使用传输层所需的信息" class="headerlink" title="使用传输层所需的信息"></a>使用传输层所需的信息</h3><p>要使用传输层进行通信，通常需要以下信息：</p>
<ol>
<li><strong>源端口号</strong>：发送方传输层使用的端口号，用于标识发送方的应用程序或服务。</li>
<li><strong>目标端口号</strong>：接收方传输层使用的端口号，用于标识接收方的应用程序或服务。例如，HTTP 使用端口 80，HTTPS 使用端口 443。</li>
<li><strong>源 IP 地址</strong>：发送方设备的 IP 地址，用于标识发送数据包的设备。</li>
<li><strong>目标 IP 地址</strong>：接收方设备的 IP 地址，用于标识接收数据包的设备。</li>
<li><strong>传输协议</strong>：例如 TCP 或 UDP，用于定义数据传输的方式。TCP 提供可靠的传输，而 UDP 则是无连接的、不保证可靠性的传输方式。</li>
<li><strong>序号和确认号</strong>（对于 TCP）：用于确保数据包按顺序到达并确认接收，防止数据丢失或重复。每个数据段都有一个序号，接收方确认收到的数据段时会返回一个确认号。</li>
<li><strong>控制信息</strong>：包括各种标志位（如 SYN、ACK、FIN 等），用于控制数据传输的状态和流程。例如，SYN 和 ACK 用于 TCP 连接的建立和确认。</li>
<li><strong>校验和</strong>：用于数据完整性校验，确保传输过程中数据未被篡改或损坏。</li>
<li><strong>窗口大小</strong>：流控制信息，指示接收方可接受的最大数据量，用于控制发送方的发送速率，防止网络拥塞。</li>
</ol>
<p>通过提供这些信息，传输层能够在发送方和接收方之间建立可靠的数据传输通道，确保数据能够正确、有效地到达目标。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://hmmmmmya.github.io">Hymns</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://hmmmmmya.github.io/2024/11/11/028_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%B1%82/">https://hmmmmmya.github.io/2024/11/11/028_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%B1%82/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://hmmmmmya.github.io" target="_blank">Hymns</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/11/11/029_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BD%91%E7%BB%9C%E5%B1%82/" title="029_计算机网络网络层"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">029_计算机网络网络层</div></div><div class="info-2"><div class="info-item-1">网络层（Network Layer）在计算机网络中扮演着关键的角色，负责数据在网络中的传输路径选择和数据包的路由。以下是网络层的主要功能：   网络层的主要功能1. 路由选择网络层负责确定数据包从源地址到目标地址的最佳路径。路由器（Routers）使用路由协议（如 OSPF、BGP）来动态更新和维护路由表，并根据网络拓扑的变化调整路径。 2. 数据包转发网络层将数据包从一个网络节点转发到下一个节点，直到数据包到达目标地址。这个过程涉及查找路由表，并根据表中的信息确定数据包的下一跳地址。 3. IP 地址编址网络层使用 IP 地址来唯一标识网络中的每个设备。IP 地址分为 IPv4 和 IPv6 两种格式，网络层通过 IP 地址来确定数据包的源和目的地。 4. 分段与重组网络层将较大的数据包分割成适合传输的较小片段（分段），并在到达目标后重新组装（重组）这些片段。这对于跨越不同网络的传输尤为重要，因为不同网络可能对数据包大小有不同的限制。 5. 差错处理与流量控制虽然主要的差错检测和流量控制功能在传输层，但网络层也具备一定的错误检测机制。例如，IPv4...</div></div></div></a><a class="pagination-related" href="/2024/11/07/027_GOF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB/" title="027_GOF设计模式分类"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">027_GOF设计模式分类</div></div><div class="info-2"><div class="info-item-1">GOF 设计模式是经过总结、优化的代码设计经验，用于解决软件设计中的特定问题。设计模式通常分为三大类：创建型模式、结构型模式和行为型模式。以下是每个分类中的常见设计模式：   创建型模式这些模式处理对象的创建问题，并提供更灵活、可复用的创建机制。  单例模式（Singleton Pattern）: 确保一个类只有一个实例，并提供全局访问点。 工厂方法模式（Factory Method Pattern）: 定义一个创建对象的接口，但由子类决定要实例化的类。 抽象工厂模式（Abstract Factory Pattern）: 提供一个创建一系列相关或依赖对象的接口，而无需指定具体类。 生成器模式（Builder Pattern）: 将对象的构建过程与表示分离，使得同样的构建过程可以创建不同的表示。 原型模式（Prototype Pattern）: 通过复制现有对象来创建新对象，避免了对象的重复初始化。  结构型模式这些模式关注类和对象的组合关系，解决系统的结构问题。  适配器模式（Adapter Pattern）:...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/09/21/013_%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7/" title="013_内网穿透工具"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-21</div><div class="info-item-2">013_内网穿透工具</div></div><div class="info-2"><div class="info-item-1">localtunnel 和 Cloudflare Tunnels 都是内网穿透工具，可以方便快捷的将本地 Localhost 暴露给全世界，无需修改 DNS 和防火墙设置   localtunnellocaltunnel 是一款基于 node.js 的内网穿透工具，非常流行，可以方便快捷的将本地 Localhost 暴露给全世界，无需修改 DNS 和防火墙设置 github 地址: https://github.com/localtunnel/localtunnel 使用方式 安装: npm install -g localtunnel  绑定端口: lt --port 8000, 绑定要访问内网服务的端口, 即本地访问该服务的端口  公网 ip:之后会生成一个 https 的公网 ip 地址, 通过该地址可以访问内网  访问密码: 本地访问该 ip, 点击查看密码, 即可看到。从外网访问 ip，并输出密码即可    注意 服务关闭后, 外网不可访问, 再次开启后会分配新的 ip  Cloudflare...</div></div></div></a><a class="pagination-related" href="/2024/10/29/018_%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E5%B8%B8%E8%A7%81%E7%9A%84%20IP%20%E9%83%BD%E6%98%AF%20192.168%20%E5%BC%80%E5%A4%B4%E7%9A%84/" title="018_为什么我们常见的 IP 都是 192.168 开头的"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-29</div><div class="info-item-2">018_为什么我们常见的 IP 都是 192.168 开头的</div></div><div class="info-2"><div class="info-item-1">为什么我们常见的 IP 都是 192.168 开头的   ip 地址划分参考：IP 地址的分类 互联网诞生之初，IP 地址显得很充裕，于是计算机科学家们设计了分类地址。 IP 地址分类成了 5 种类型，分别是 A 类、B 类、C 类、D 类、E 类。  上图中黄色部分为分类号，用以区分 IP 地址类别。 私网地址划分 10.0.0.0–10.255.255.255 172.16.0.0–172.31.255.255 192.168.0.0–192.168.255.255   除了这三个 ip 地址段为私有 ip 地址外，其它的都为公网 ip。 这些地址已被声明私有化，任何内网中的设备可以任意使用这些地址，但是在这三个范围内的 IP 地址不允许出现在 Internet（外网）上。所以我们平台在内部组网时用的比较多，比如监控项目与公司内部电脑 ip 设置，用的多的就是 192.168.xx。 通常情况下，按照需要容纳的主机数选择私有地址段。家庭网络规模比较小，一个 C 类地址，192.168.1.x 可以容纳 254 个终端，足够使用。 学校或者大型企业可能使用 B 类甚至 A...</div></div></div></a><a class="pagination-related" href="/2024/11/11/029_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BD%91%E7%BB%9C%E5%B1%82/" title="029_计算机网络网络层"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-11</div><div class="info-item-2">029_计算机网络网络层</div></div><div class="info-2"><div class="info-item-1">网络层（Network Layer）在计算机网络中扮演着关键的角色，负责数据在网络中的传输路径选择和数据包的路由。以下是网络层的主要功能：   网络层的主要功能1. 路由选择网络层负责确定数据包从源地址到目标地址的最佳路径。路由器（Routers）使用路由协议（如 OSPF、BGP）来动态更新和维护路由表，并根据网络拓扑的变化调整路径。 2. 数据包转发网络层将数据包从一个网络节点转发到下一个节点，直到数据包到达目标地址。这个过程涉及查找路由表，并根据表中的信息确定数据包的下一跳地址。 3. IP 地址编址网络层使用 IP 地址来唯一标识网络中的每个设备。IP 地址分为 IPv4 和 IPv6 两种格式，网络层通过 IP 地址来确定数据包的源和目的地。 4. 分段与重组网络层将较大的数据包分割成适合传输的较小片段（分段），并在到达目标后重新组装（重组）这些片段。这对于跨越不同网络的传输尤为重要，因为不同网络可能对数据包大小有不同的限制。 5. 差错处理与流量控制虽然主要的差错检测和流量控制功能在传输层，但网络层也具备一定的错误检测机制。例如，IPv4...</div></div></div></a><a class="pagination-related" href="/2024/11/11/030_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%B1%82/" title="030_计算机网络应用层"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-11</div><div class="info-item-2">030_计算机网络应用层</div></div><div class="info-2"><div class="info-item-1">应用层是 OSI 模型中的第七层，直接面向用户和应用程序。它主要负责提供网络服务的接口和实现数据交换。以下是应用层的主要功能：   应用层的主要功能1. 提供网络服务接口应用层为各种应用程序提供网络服务接口，使得用户可以通过这些应用程序进行通信和数据交换。例如，Web 浏览器、电子邮件客户端和文件传输应用都通过应用层协议与网络进行交互。 2. 数据表示和转换应用层负责数据的表示和转换，确保不同系统之间的数据可以正确理解和处理。这包括字符编码、数据格式转换和数据压缩等功能。例如，HTTP 协议在传输 HTML 文件时，需要将字符数据编码为网络传输格式。 3. 数据加密和安全性应用层提供数据加密和解密功能，确保数据在传输过程中的机密性和完整性。例如，HTTPS 协议通过 SSL&#x2F;TLS 加密数据，保护用户的敏感信息。 4. 资源共享和远程访问应用层支持资源共享和远程访问功能，使得用户可以访问远程服务器的资源。例如，FTP 协议允许用户上传和下载远程服务器上的文件，Telnet 协议允许用户远程登录到另一台计算机。 5....</div></div></div></a><a class="pagination-related" href="/2024/11/11/031_DHCP%E7%9A%84%E4%BD%9C%E7%94%A8/" title="031_DHCP的作用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-11</div><div class="info-item-2">031_DHCP的作用</div></div><div class="info-2"><div class="info-item-1">DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）的主要作用是自动为网络上的设备分配 IP 地址和其他网络配置参数，如子网掩码、默认网关和 DNS 服务器。这样做的目的是简化网络管理，避免手动配置每个设备的网络设置。以下是 DHCP 的具体功能：   1. 自动 IP 地址分配DHCP 服务器可以自动分配 IP 地址给网络中的设备，确保每个设备都有一个唯一的 IP 地址，避免地址冲突。 2. 分配网络配置参数除了 IP 地址，DHCP 还可以分配其他重要的网络配置参数，如：  子网掩码：用于确定 IP 地址的网络部分和主机部分。 默认网关：用于设备访问外部网络。 DNS 服务器：用于将域名解析为 IP 地址。  3. IP 地址租赁DHCP 使用租赁机制，IP 地址的分配是有时间限制的。设备在租期到期之前，可以向 DHCP 服务器请求续租以继续使用当前的 IP 地址。 4. 网络管理简化通过 DHCP，网络管理员不需要手动为每个设备配置网络设置，简化了网络管理工作，尤其是在有大量设备的网络环境中。 5....</div></div></div></a><a class="pagination-related" href="/2024/11/11/032_%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84/" title="032_报文结构"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-11</div><div class="info-item-2">032_报文结构</div></div><div class="info-2"><div class="info-item-1">报文结构是指在网络通信中，各种协议规定的数据报文格式。不同的协议会有不同的报文结构，以下是一些常见协议的报文结构示例。   TCP 报文结构TCP（传输控制协议）的报文结构如下： 12345678910111213141516171819+-------------------------+|       源端口号 (16位)      |+-------------------------+|       目的端口号 (16位)     |+-------------------------+|       序列号 (32位)       |+-------------------------+|      确认号 (32位)       |+-------------------------+| 数据偏移 (4位) | 保留 (6位) | 标志位 (6位) | 窗口大小 (16位) |+-------------------------+|     校验和 (16位)        |+-------------------------+|     紧急指针 (16位)  ...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Hymns</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">50</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD"><span class="toc-number">1.</span> <span class="toc-text">传输层的主要功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E5%88%86%E6%AE%B5%E5%92%8C%E9%87%8D%E7%BB%84"><span class="toc-number">1.1.</span> <span class="toc-text">1. 数据分段和重组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6"><span class="toc-number">1.2.</span> <span class="toc-text">2. 传输控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%AB%AF%E5%88%B0%E7%AB%AF%E9%80%9A%E4%BF%A1"><span class="toc-number">1.3.</span> <span class="toc-text">3. 端到端通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="toc-number">1.4.</span> <span class="toc-text">4. 数据完整性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%92%8C%E8%A7%A3%E5%A4%8D%E7%94%A8"><span class="toc-number">1.5.</span> <span class="toc-text">5. 多路复用和解复用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%B5%81%E6%8E%A7%E5%88%B6"><span class="toc-number">1.6.</span> <span class="toc-text">6. 流控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">1.7.</span> <span class="toc-text">7. 拥塞控制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">2.</span> <span class="toc-text">相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#socket"><span class="toc-number">2.1.</span> <span class="toc-text">socket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82%E7%9A%84%E4%BF%A1%E6%81%AF%E8%A6%81%E5%8F%91%E9%80%81%E5%88%B0%E5%93%AA%E9%87%8C"><span class="toc-number">2.2.</span> <span class="toc-text">传输层的信息要发送到哪里</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BC%A0%E8%BE%93%E5%B1%82%E6%89%80%E9%9C%80%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="toc-number">2.3.</span> <span class="toc-text">使用传输层所需的信息</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/19/049-data-structure-and-algorithm-learning/" title="049-data-structure-and-algorithm-learning">049-data-structure-and-algorithm-learning</a><time datetime="2024-11-19T06:32:23.000Z" title="发表于 2024-11-19 14:32:23">2024-11-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/18/048-%E4%BB%8A%E5%A4%A9%E6%8D%A2%E9%A1%B5%E6%9C%BA%E5%88%B6%E6%98%AF%E5%90%A6%E4%BB%8D%E7%84%B6%E6%9C%89%E5%BF%85%E8%A6%81/" title="048-今天换页机制是否仍然有必要">048-今天换页机制是否仍然有必要</a><time datetime="2024-11-18T07:33:27.000Z" title="发表于 2024-11-18 15:33:27">2024-11-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/15/047-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/" title="047-操作系统上下文切换">047-操作系统上下文切换</a><time datetime="2024-11-15T07:10:16.000Z" title="发表于 2024-11-15 15:10:16">2024-11-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/15/046-%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%AD%E6%96%AD%E7%9A%84%E5%8C%BA%E5%88%AB/" title="046-异常和中断的区别">046-异常和中断的区别</a><time datetime="2024-11-15T06:58:43.000Z" title="发表于 2024-11-15 14:58:43">2024-11-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/15/045-operate-system-learning/" title="045-operate-system-learning">045-operate-system-learning</a><time datetime="2024-11-15T06:36:59.000Z" title="发表于 2024-11-15 14:36:59">2024-11-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2024 By Hymns</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>