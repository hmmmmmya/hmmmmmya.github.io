<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>033_集线器_交换机_路由器_光猫的区别 | Hymns</title><meta name="author" content="Hymns"><meta name="copyright" content="Hymns"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="路由器和交换机的主要区别路由器和交换机不同点在于，它的每个网口下，都有一个 MAC 地址和 IP 地址前面提到交换机，是不具备 MAC 地址的，而 MAC 报头是需要填上目的 MAC 地址的。因此交换机从来都不是数据的目的地，它只简单转发数据帧到目的地。 但路由器，是有 MAC 地址的，因此 MAC 报头就可以写上，下一站目的地就是 xx 路由。 到了路由器后，路由器可以再次组装下一站的目的 MA">
<meta property="og:type" content="article">
<meta property="og:title" content="033_集线器_交换机_路由器_光猫的区别">
<meta property="og:url" content="https://hmmmmmya.github.io/2024/11/12/033-%E9%9B%86%E7%BA%BF%E5%99%A8-%E4%BA%A4%E6%8D%A2%E6%9C%BA-%E8%B7%AF%E7%94%B1%E5%99%A8-%E5%85%89%E7%8C%AB%E7%9A%84%E5%8C%BA%E5%88%AB/index.html">
<meta property="og:site_name" content="Hymns">
<meta property="og:description" content="路由器和交换机的主要区别路由器和交换机不同点在于，它的每个网口下，都有一个 MAC 地址和 IP 地址前面提到交换机，是不具备 MAC 地址的，而 MAC 报头是需要填上目的 MAC 地址的。因此交换机从来都不是数据的目的地，它只简单转发数据帧到目的地。 但路由器，是有 MAC 地址的，因此 MAC 报头就可以写上，下一站目的地就是 xx 路由。 到了路由器后，路由器可以再次组装下一站的目的 MA">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hmmmmmya.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2024-11-12T08:50:14.000Z">
<meta property="article:modified_time" content="2024-11-12T08:55:36.447Z">
<meta property="article:author" content="Hymns">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hmmmmmya.github.io/img/butterfly-icon.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://hmmmmmya.github.io/2024/11/12/033-%E9%9B%86%E7%BA%BF%E5%99%A8-%E4%BA%A4%E6%8D%A2%E6%9C%BA-%E8%B7%AF%E7%94%B1%E5%99%A8-%E5%85%89%E7%8C%AB%E7%9A%84%E5%8C%BA%E5%88%AB/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '033_集线器_交换机_路由器_光猫的区别',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/atom.xml" title="Hymns" type="application/atom+xml">
</head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/cover1.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hymns</span></a><a class="nav-page-title" href="/"><span class="site-name">033_集线器_交换机_路由器_光猫的区别</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">033_集线器_交换机_路由器_光猫的区别</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-12T08:50:14.000Z" title="发表于 2024-11-12 16:50:14">2024-11-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-12T08:55:36.447Z" title="更新于 2024-11-12 16:55:36">2024-11-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h3 id="路由器和交换机的主要区别"><a href="#路由器和交换机的主要区别" class="headerlink" title="路由器和交换机的主要区别"></a>路由器和交换机的主要区别</h3><h4 id="路由器和交换机不同点在于，它的每个网口下，都有一个-MAC-地址和-IP-地址"><a href="#路由器和交换机不同点在于，它的每个网口下，都有一个-MAC-地址和-IP-地址" class="headerlink" title="路由器和交换机不同点在于，它的每个网口下，都有一个 MAC 地址和 IP 地址"></a>路由器和交换机不同点在于，它的每个网口下，都有一个 MAC 地址和 IP 地址</h4><p>前面提到交换机，是不具备 MAC 地址的，而 MAC 报头是需要填上目的 MAC 地址的。因此交换机从来都不是数据的目的地，它只简单转发数据帧到目的地。</p>
<p>但路由器，是有 MAC 地址的，因此 MAC 报头就可以写上，下一站目的地就是 xx 路由。</p>
<p>到了路由器后，路由器可以再次组装下一站的目的 MAC 地址是再下一个路由，通过这一点，让数据在路由和路由之间传输。</p>
<p>而同时因为交换机不具有 MAC 地址，因此也不会校验收到的数据帧的 MAC 地址是不是自己的，全部收下做转发。而路由器则会校验数据帧的 MAC 报头里的目的 MAC 地址是不是自己，是的话才会收入内存缓冲区，否则丢弃。</p>
<h4 id="找不到转发目的地时的处理方式有区别"><a href="#找不到转发目的地时的处理方式有区别" class="headerlink" title="找不到转发目的地时的处理方式有区别"></a>找不到转发目的地时的处理方式有区别</h4><p>如果在路由表中无法找到匹配的记录，路由器会丢弃这个包，并通过 ICMP 消息告知发送方。</p>
<p>而交换机在 MAC 地址表里找不到转发端口时会选择广播。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>两台电脑可以通过一根网线直接连接，进行通信。</li>
<li>机器一多，可以把网线都接到集线器（物理层）上，但是集线器会不管三七二十一进行广播。</li>
<li>不想广播，可以用（二层）交换机（数据链路层），又叫多端口网桥，它比较聪明，会自我学习生产 MAC 地址表，知道消息发到哪，那就不需要广播啦</li>
<li>互联网电脑这么多，交换机 MAC 地址表总不能全放下吧。改用路由器（网络层），也叫三层交换机，通过网段的方式定位要把消息转发到哪，就不需要像交换机那样苦哈哈一条一条记录 MAC 地址啦。</li>
<li>路由器和光猫之间是好搭档，光猫负责把光纤里的光信号转换成电信号给路由器。</li>
<li>现在一般情况下，家里已经不用集线器和交换机了，大部分路由器也支持交换机的功能。所以可以看到，家里的台式机电脑一般就连到一个路由器，再连个光猫就够能快乐上网了。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20241112165453.png" alt="网络连接模型"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://hmmmmmya.github.io">Hymns</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://hmmmmmya.github.io/2024/11/12/033-%E9%9B%86%E7%BA%BF%E5%99%A8-%E4%BA%A4%E6%8D%A2%E6%9C%BA-%E8%B7%AF%E7%94%B1%E5%99%A8-%E5%85%89%E7%8C%AB%E7%9A%84%E5%8C%BA%E5%88%AB/">https://hmmmmmya.github.io/2024/11/12/033-%E9%9B%86%E7%BA%BF%E5%99%A8-%E4%BA%A4%E6%8D%A2%E6%9C%BA-%E8%B7%AF%E7%94%B1%E5%99%A8-%E5%85%89%E7%8C%AB%E7%9A%84%E5%8C%BA%E5%88%AB/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://hmmmmmya.github.io" target="_blank">Hymns</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/11/12/034-%E7%AB%AF%E5%8F%A3%E5%8F%B7%E7%9A%84%E5%88%92%E5%88%86/" title="034_端口号的划分"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">034_端口号的划分</div></div><div class="info-2"><div class="info-item-1">端口号用于标识网络通信中的特定进程或服务，它们在 TCP&#x2F;IP 协议中有特定的划分方式。以下是端口号的分类：   端口号的划分1. 系统端口 (0-1023)这些端口号是为系统进程或特权服务预留的，只有超级用户或具有特定权限的用户才能使用。例如：  80: HTTP 443: HTTPS 21: FTP 22: SSH  2. 用户端口 (1024-49151)这些端口号通常用于用户进程或应用程序，普通用户可以使用。例如：  3306: MySQL 数据库 8080: 通常用于 HTTP 备用端口或 Web 服务器端口  3. 动态&#x2F;私有端口 (49152-65535)这些端口号通常用于临时或短期的通信，客户端在连接到服务器时常用这些端口。例如，临时打开的 Web 浏览器与服务器进行通信时使用的端口。 详细示例假设你在浏览器中访问一个网站，过程可能涉及多个端口号：  浏览器（客户端）使用一个动态端口（如 49152）发送请求。 服务器接收到请求，监听端口 80（HTTP）或...</div></div></div></a><a class="pagination-related" href="/2024/11/11/032_%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84/" title="032_报文结构"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">032_报文结构</div></div><div class="info-2"><div class="info-item-1">报文结构是指在网络通信中，各种协议规定的数据报文格式。不同的协议会有不同的报文结构，以下是一些常见协议的报文结构示例。   TCP 报文结构TCP（传输控制协议）的报文结构如下： 12345678910111213141516171819+-------------------------+|       源端口号 (16位)      |+-------------------------+|       目的端口号 (16位)     |+-------------------------+|       序列号 (32位)       |+-------------------------+|      确认号 (32位)       |+-------------------------+| 数据偏移 (4位) | 保留 (6位) | 标志位 (6位) | 窗口大小 (16位) |+-------------------------+|     校验和 (16位)        |+-------------------------+|     紧急指针 (16位)  ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/09/21/013_%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7/" title="013_内网穿透工具"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-21</div><div class="info-item-2">013_内网穿透工具</div></div><div class="info-2"><div class="info-item-1">localtunnel 和 Cloudflare Tunnels 都是内网穿透工具，可以方便快捷的将本地 Localhost 暴露给全世界，无需修改 DNS 和防火墙设置   localtunnellocaltunnel 是一款基于 node.js 的内网穿透工具，非常流行，可以方便快捷的将本地 Localhost 暴露给全世界，无需修改 DNS 和防火墙设置 github 地址: https://github.com/localtunnel/localtunnel 使用方式 安装: npm install -g localtunnel  绑定端口: lt --port 8000, 绑定要访问内网服务的端口, 即本地访问该服务的端口  公网 ip:之后会生成一个 https 的公网 ip 地址, 通过该地址可以访问内网  访问密码: 本地访问该 ip, 点击查看密码, 即可看到。从外网访问 ip，并输出密码即可    注意 服务关闭后, 外网不可访问, 再次开启后会分配新的 ip  Cloudflare...</div></div></div></a><a class="pagination-related" href="/2024/10/29/018_%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E5%B8%B8%E8%A7%81%E7%9A%84%20IP%20%E9%83%BD%E6%98%AF%20192.168%20%E5%BC%80%E5%A4%B4%E7%9A%84/" title="018_为什么我们常见的 IP 都是 192.168 开头的"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-29</div><div class="info-item-2">018_为什么我们常见的 IP 都是 192.168 开头的</div></div><div class="info-2"><div class="info-item-1">为什么我们常见的 IP 都是 192.168 开头的   ip 地址划分参考：IP 地址的分类 互联网诞生之初，IP 地址显得很充裕，于是计算机科学家们设计了分类地址。 IP 地址分类成了 5 种类型，分别是 A 类、B 类、C 类、D 类、E 类。  上图中黄色部分为分类号，用以区分 IP 地址类别。 私网地址划分 10.0.0.0–10.255.255.255 172.16.0.0–172.31.255.255 192.168.0.0–192.168.255.255   除了这三个 ip 地址段为私有 ip 地址外，其它的都为公网 ip。 这些地址已被声明私有化，任何内网中的设备可以任意使用这些地址，但是在这三个范围内的 IP 地址不允许出现在 Internet（外网）上。所以我们平台在内部组网时用的比较多，比如监控项目与公司内部电脑 ip 设置，用的多的就是 192.168.xx。 通常情况下，按照需要容纳的主机数选择私有地址段。家庭网络规模比较小，一个 C 类地址，192.168.1.x 可以容纳 254 个终端，足够使用。 学校或者大型企业可能使用 B 类甚至 A...</div></div></div></a><a class="pagination-related" href="/2024/11/11/028_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%B1%82/" title="028_计算机网络传输层"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-11</div><div class="info-item-2">028_计算机网络传输层</div></div><div class="info-2"><div class="info-item-1">在计算机网络中，传输层（Transport Layer）负责在网络端点之间传输数据。它是 OSI 模型中的第四层，提供了关键的功能，以确保数据在网络中能够有效、可靠地传输。以下是传输层的一些主要功能和作用：   传输层的主要功能1. 数据分段和重组传输层将应用层传递下来的数据分割成更小的段（segments），每个段包含必要的控制信息。接收方传输层会将这些段重组成原始的数据流。 2. 传输控制传输层确保数据可靠传输。常见协议如 TCP（传输控制协议）提供了数据包的确认（acknowledgment）、序号（sequence numbering）、超时重传（retransmission）、流控制（flow control）和拥塞控制（congestion control）等机制。 3. 端到端通信传输层建立并管理端到端的通信连接。TCP 协议通过三次握手（three-way handshake）建立连接，确保通信双方准备就绪，而 UDP（用户数据报协议）则是不可靠的连接，通常用于实时应用如视频流和在线游戏。 4....</div></div></div></a><a class="pagination-related" href="/2024/11/11/029_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BD%91%E7%BB%9C%E5%B1%82/" title="029_计算机网络网络层"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-11</div><div class="info-item-2">029_计算机网络网络层</div></div><div class="info-2"><div class="info-item-1">网络层（Network Layer）在计算机网络中扮演着关键的角色，负责数据在网络中的传输路径选择和数据包的路由。以下是网络层的主要功能：   网络层的主要功能1. 路由选择网络层负责确定数据包从源地址到目标地址的最佳路径。路由器（Routers）使用路由协议（如 OSPF、BGP）来动态更新和维护路由表，并根据网络拓扑的变化调整路径。 2. 数据包转发网络层将数据包从一个网络节点转发到下一个节点，直到数据包到达目标地址。这个过程涉及查找路由表，并根据表中的信息确定数据包的下一跳地址。 3. IP 地址编址网络层使用 IP 地址来唯一标识网络中的每个设备。IP 地址分为 IPv4 和 IPv6 两种格式，网络层通过 IP 地址来确定数据包的源和目的地。 4. 分段与重组网络层将较大的数据包分割成适合传输的较小片段（分段），并在到达目标后重新组装（重组）这些片段。这对于跨越不同网络的传输尤为重要，因为不同网络可能对数据包大小有不同的限制。 5. 差错处理与流量控制虽然主要的差错检测和流量控制功能在传输层，但网络层也具备一定的错误检测机制。例如，IPv4...</div></div></div></a><a class="pagination-related" href="/2024/11/11/030_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%B1%82/" title="030_计算机网络应用层"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-11</div><div class="info-item-2">030_计算机网络应用层</div></div><div class="info-2"><div class="info-item-1">应用层是 OSI 模型中的第七层，直接面向用户和应用程序。它主要负责提供网络服务的接口和实现数据交换。以下是应用层的主要功能：   应用层的主要功能1. 提供网络服务接口应用层为各种应用程序提供网络服务接口，使得用户可以通过这些应用程序进行通信和数据交换。例如，Web 浏览器、电子邮件客户端和文件传输应用都通过应用层协议与网络进行交互。 2. 数据表示和转换应用层负责数据的表示和转换，确保不同系统之间的数据可以正确理解和处理。这包括字符编码、数据格式转换和数据压缩等功能。例如，HTTP 协议在传输 HTML 文件时，需要将字符数据编码为网络传输格式。 3. 数据加密和安全性应用层提供数据加密和解密功能，确保数据在传输过程中的机密性和完整性。例如，HTTPS 协议通过 SSL&#x2F;TLS 加密数据，保护用户的敏感信息。 4. 资源共享和远程访问应用层支持资源共享和远程访问功能，使得用户可以访问远程服务器的资源。例如，FTP 协议允许用户上传和下载远程服务器上的文件，Telnet 协议允许用户远程登录到另一台计算机。 5....</div></div></div></a><a class="pagination-related" href="/2024/11/11/031_DHCP%E7%9A%84%E4%BD%9C%E7%94%A8/" title="031_DHCP的作用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-11</div><div class="info-item-2">031_DHCP的作用</div></div><div class="info-2"><div class="info-item-1">DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）的主要作用是自动为网络上的设备分配 IP 地址和其他网络配置参数，如子网掩码、默认网关和 DNS 服务器。这样做的目的是简化网络管理，避免手动配置每个设备的网络设置。以下是 DHCP 的具体功能：   1. 自动 IP 地址分配DHCP 服务器可以自动分配 IP 地址给网络中的设备，确保每个设备都有一个唯一的 IP 地址，避免地址冲突。 2. 分配网络配置参数除了 IP 地址，DHCP 还可以分配其他重要的网络配置参数，如：  子网掩码：用于确定 IP 地址的网络部分和主机部分。 默认网关：用于设备访问外部网络。 DNS 服务器：用于将域名解析为 IP 地址。  3. IP 地址租赁DHCP 使用租赁机制，IP 地址的分配是有时间限制的。设备在租期到期之前，可以向 DHCP 服务器请求续租以继续使用当前的 IP 地址。 4. 网络管理简化通过 DHCP，网络管理员不需要手动为每个设备配置网络设置，简化了网络管理工作，尤其是在有大量设备的网络环境中。 5....</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Hymns</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">58</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E5%92%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB"><span class="toc-number">1.</span> <span class="toc-text">路由器和交换机的主要区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E5%92%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA%E4%B8%8D%E5%90%8C%E7%82%B9%E5%9C%A8%E4%BA%8E%EF%BC%8C%E5%AE%83%E7%9A%84%E6%AF%8F%E4%B8%AA%E7%BD%91%E5%8F%A3%E4%B8%8B%EF%BC%8C%E9%83%BD%E6%9C%89%E4%B8%80%E4%B8%AA-MAC-%E5%9C%B0%E5%9D%80%E5%92%8C-IP-%E5%9C%B0%E5%9D%80"><span class="toc-number">1.1.</span> <span class="toc-text">路由器和交换机不同点在于，它的每个网口下，都有一个 MAC 地址和 IP 地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%BE%E4%B8%8D%E5%88%B0%E8%BD%AC%E5%8F%91%E7%9B%AE%E7%9A%84%E5%9C%B0%E6%97%B6%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E6%9C%89%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.</span> <span class="toc-text">找不到转发目的地时的处理方式有区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/058-design-patterns-learning/" title="058-design-patterns-learning">058-design-patterns-learning</a><time datetime="2024-11-28T09:04:03.000Z" title="发表于 2024-11-28 17:04:03">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/22/057-nlohmann-json%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/" title="057-nlohmann_json库的使用">057-nlohmann_json库的使用</a><time datetime="2024-11-22T07:54:26.000Z" title="发表于 2024-11-22 15:54:26">2024-11-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/21/056-ifndef-LINUX/" title="056-ifndef LINUX">056-ifndef LINUX</a><time datetime="2024-11-21T09:53:59.000Z" title="发表于 2024-11-21 17:53:59">2024-11-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/21/055-windwos%E4%B8%8B%E7%94%A8Studio%E7%BC%96%E8%AF%91%E7%BC%BA%E5%B0%91jsoncpp%E5%BA%93%E6%80%8E%E4%B9%88%E5%8A%9E/" title="055-windwos下用Studio编译缺少jsoncpp库怎么办">055-windwos下用Studio编译缺少jsoncpp库怎么办</a><time datetime="2024-11-21T09:49:54.000Z" title="发表于 2024-11-21 17:49:54">2024-11-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/21/054-Microsoft-Visual-Studio-%E6%80%8E%E4%B9%88%E7%BC%96%E8%AF%91cpp-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%8C%85%E5%90%AB%E4%BA%86-sln%E6%96%87%E4%BB%B6/" title="054-Microsoft Visual Studio 怎么编译c++项目, 项目中包含了.sln文件">054-Microsoft Visual Studio 怎么编译c++项目, 项目中包含了.sln文件</a><time datetime="2024-11-21T08:46:34.000Z" title="发表于 2024-11-21 16:46:34">2024-11-21</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2024 By Hymns</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>