<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>040-c++递归互斥锁、lock_guard和unique_lock | Hymns</title><meta name="author" content="Hymns"><meta name="copyright" content="Hymns"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="std::recursive_mutex可以在同一个线程中嵌套使用。介绍了 lock_guard 和 mutex 是什么关系, lock_guard 和 unique_lock 的区别">
<meta property="og:type" content="article">
<meta property="og:title" content="040-c++递归互斥锁、lock_guard和unique_lock">
<meta property="og:url" content="https://hmmmmmya.github.io/2024/11/14/040-cpp%E9%80%92%E5%BD%92%E4%BA%92%E6%96%A5%E9%94%81%E3%80%81lock_guard%E5%92%8Cunique_lock/index.html">
<meta property="og:site_name" content="Hymns">
<meta property="og:description" content="std::recursive_mutex可以在同一个线程中嵌套使用。介绍了 lock_guard 和 mutex 是什么关系, lock_guard 和 unique_lock 的区别">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hmmmmmya.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2024-11-14T01:54:49.000Z">
<meta property="article:modified_time" content="2024-11-14T02:58:24.126Z">
<meta property="article:author" content="Hymns">
<meta property="article:tag" content="c++">
<meta property="article:tag" content="c++11">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hmmmmmya.github.io/img/butterfly-icon.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://hmmmmmya.github.io/2024/11/14/040-cpp%E9%80%92%E5%BD%92%E4%BA%92%E6%96%A5%E9%94%81%E3%80%81lock_guard%E5%92%8Cunique_lock/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '040-c++递归互斥锁、lock_guard和unique_lock',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/atom.xml" title="Hymns" type="application/atom+xml">
</head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/cover1.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hymns</span></a><a class="nav-page-title" href="/"><span class="site-name">040-c++递归互斥锁、lock_guard和unique_lock</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">040-c++递归互斥锁、lock_guard和unique_lock</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-14T01:54:49.000Z" title="发表于 2024-11-14 09:54:49">2024-11-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-14T02:58:24.126Z" title="更新于 2024-11-14 10:58:24">2024-11-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/c/">c++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p><code>std::recursive_mutex</code>可以在同一个线程中嵌套使用。介绍了 lock_guard 和 mutex 是什么关系, lock_guard 和 unique_lock 的区别</p>
<span id="more"></span>

<p><code>std::recursive_mutex</code>是一种递归锁，它允许同一线程多次加锁而不会导致死锁。在使用普通的<code>std::mutex</code>时，同一线程如果多次尝试加锁会造成死锁；而<code>std::recursive_mutex</code>则不会。它会跟踪当前线程的加锁次数，并在解锁时，只有当解锁次数与加锁次数相同时，锁才会真正释放。</p>
<p>以下是一个简单的示例，展示了如何在同一线程中嵌套使用<code>std::recursive_mutex</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::recursive_mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recursiveFunction</span><span class="params">(<span class="type">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    mtx.<span class="built_in">lock</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Lock acquired, count = &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归调用</span></span><br><span class="line">    <span class="built_in">recursiveFunction</span>(count - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Releasing lock, count = &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">    mtx.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(recursiveFunction, <span class="number">3</span>)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>recursiveFunction</code>函数递归调用自己，每次调用时都会加锁，直到<code>count</code>为零时停止递归。由于使用了<code>std::recursive_mutex</code>，即使在同一线程中多次加锁，也不会发生死锁。</p>
<h2 id="lock-guard-和-mutex-是什么关系"><a href="#lock-guard-和-mutex-是什么关系" class="headerlink" title="lock_guard 和 mutex 是什么关系"></a>lock_guard 和 mutex 是什么关系</h2><p><code>std::lock_guard</code>和<code>std::mutex</code>在 C++中是协同使用的关系。<code>std::lock_guard</code>是一个用于管理<code>std::mutex</code>（或其他锁类型）的 RAII（资源获取即初始化）机制，旨在更安全和便捷地管理互斥锁的加锁和解锁过程。</p>
<h3 id="它们的关系"><a href="#它们的关系" class="headerlink" title="它们的关系"></a>它们的关系</h3><ul>
<li>**<code>std::mutex</code>**：是 C++标准库中提供的基础互斥锁类，用于在线程间保护共享资源，避免数据竞争。通过显式调用<code>lock()</code>和<code>unlock()</code>函数加锁和解锁来控制对共享资源的访问。</li>
<li>**<code>std::lock_guard</code>**：是一个模板类，用于自动管理<code>std::mutex</code>的加锁和解锁操作。它在构造时自动对传入的<code>std::mutex</code>对象加锁，在销毁时（通常是作用域结束时）自动解锁。因此，使用<code>std::lock_guard</code>可以确保即使在异常或函数提前返回时，锁也会被正确释放。</li>
</ul>
<h3 id="为什么要使用std-lock-guard"><a href="#为什么要使用std-lock-guard" class="headerlink" title="为什么要使用std::lock_guard"></a>为什么要使用<code>std::lock_guard</code></h3><p>如果手动控制<code>std::mutex</code>的加锁和解锁，很容易因漏掉解锁操作或在出现异常时未释放锁而导致死锁。<code>std::lock_guard</code>简化了这一过程，通过在其生命周期内自动加锁和解锁，确保了代码的安全性和可读性。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safeFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 lock_guard 管理 mtx 的加锁和解锁</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 临界区，安全访问共享资源</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; is in critical section.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock 离开作用域后会自动解锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(safeFunction)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(safeFunction)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>std::lock_guard</code>构造时会锁住<code>mtx</code>，在<code>safeFunction</code>结束时，<code>std::lock_guard</code>自动析构并解锁，从而避免了手动解锁可能带来的问题。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>std::lock_guard</code>和<code>std::mutex</code>是合作关系：<code>std::mutex</code>是互斥锁的实现，而<code>std::lock_guard</code>是用于自动管理<code>std::mutex</code>加锁和解锁的工具。</p>
<h2 id="lock-guard-和-unique-lock-的区别"><a href="#lock-guard-和-unique-lock-的区别" class="headerlink" title="lock_guard 和 unique_lock 的区别"></a>lock_guard 和 unique_lock 的区别</h2><p><code>std::lock_guard</code>和<code>std::unique_lock</code>都是用于管理<code>std::mutex</code>的 RAII 类型锁，但它们在功能和灵活性上有一些区别。下面详细解释它们的差异。</p>
<h3 id="1-锁的灵活性"><a href="#1-锁的灵活性" class="headerlink" title="1. 锁的灵活性"></a>1. 锁的灵活性</h3><ul>
<li>**<code>std::lock_guard</code>**：<code>std::lock_guard</code>非常简单，在构造时自动加锁，并且在析构时自动解锁。它没有提供其他任何锁管理的接口，因此无法手动解锁后再重新加锁。</li>
<li>**<code>std::unique_lock</code>**：<code>std::unique_lock</code>更灵活，它提供了加锁、解锁和重锁的功能。你可以在代码中选择性地调用<code>lock()</code>和<code>unlock()</code>来手动控制锁的状态。</li>
</ul>
<h3 id="2-延迟加锁和解锁"><a href="#2-延迟加锁和解锁" class="headerlink" title="2. 延迟加锁和解锁"></a>2. 延迟加锁和解锁</h3><ul>
<li>**<code>std::lock_guard</code>**：在创建<code>std::lock_guard</code>对象时必须立即加锁，没有延迟加锁的选项。</li>
<li>**<code>std::unique_lock</code>**：支持延迟加锁，即可以在构造时不加锁，稍后在需要的时候调用<code>lock()</code>来加锁。可以使用<code>std::defer_lock</code>标志来延迟加锁。</li>
</ul>
<h3 id="3-条件变量的支持"><a href="#3-条件变量的支持" class="headerlink" title="3. 条件变量的支持"></a>3. 条件变量的支持</h3><ul>
<li>**<code>std::lock_guard</code>**：无法与<code>std::condition_variable</code>配合使用，因为条件变量要求能够临时解锁和重新加锁，这需要更灵活的锁管理。</li>
<li>**<code>std::unique_lock</code>**：可以与<code>std::condition_variable</code>配合使用。在等待条件变量时，<code>std::unique_lock</code>可以暂时解锁互斥锁，以便其他线程获得锁，并在条件满足后重新加锁。</li>
</ul>
<h3 id="4-开销"><a href="#4-开销" class="headerlink" title="4. 开销"></a>4. 开销</h3><ul>
<li>**<code>std::lock_guard</code>**：轻量级，没有额外的状态信息，因为它一旦加锁，就保持锁定状态直到销毁。适用于简单的场景。</li>
<li>**<code>std::unique_lock</code>**：稍微重一些，因为它维护了更多的状态信息（比如是否锁定、是否延迟等），以便支持更多功能。适用于需要灵活控制锁的场景。</li>
</ul>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><h4 id="std-lock-guard"><a href="#std-lock-guard" class="headerlink" title="std::lock_guard"></a><code>std::lock_guard</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safeFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;  <span class="comment">// 构造时自动加锁</span></span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; is in critical section.\n&quot;</span>;</span><br><span class="line">&#125;  <span class="comment">// 作用域结束，自动解锁</span></span><br></pre></td></tr></table></figure>

<h4 id="std-unique-lock"><a href="#std-unique-lock" class="headerlink" title="std::unique_lock"></a><code>std::unique_lock</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">waitingThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;  <span class="comment">// 构造时加锁</span></span><br><span class="line">    cv.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> ready; &#125;);     <span class="comment">// 等待条件变量，期间自动解锁并在条件满足后重新加锁</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; finished waiting.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setReady</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    ready = <span class="literal">true</span>;</span><br><span class="line">    cv.<span class="built_in">notify_all</span>();  <span class="comment">// 唤醒所有等待的线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(waitingThread)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(setReady)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th>特性</th>
<th><code>std::lock_guard</code></th>
<th><code>std::unique_lock</code></th>
</tr>
</thead>
<tbody><tr>
<td>加锁和解锁灵活性</td>
<td>固定，只能自动加锁和解锁</td>
<td>灵活，支持手动加锁、解锁、重新加锁</td>
</tr>
<tr>
<td>延迟加锁</td>
<td>不支持</td>
<td>支持，通过<code>std::defer_lock</code>指定</td>
</tr>
<tr>
<td>条件变量支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>适用场景</td>
<td>简单加锁、解锁</td>
<td>需要更多锁管理控制的复杂场景</td>
</tr>
<tr>
<td>性能</td>
<td>更轻量级</td>
<td>较重，带有额外状态信息</td>
</tr>
</tbody></table>
<p>总体而言，如果只需要简单的加锁解锁，<code>std::lock_guard</code>更合适；如果需要更灵活的锁控制（如条件变量、延迟加锁等），则<code>std::unique_lock</code>是更好的选择。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://hmmmmmya.github.io">Hymns</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://hmmmmmya.github.io/2024/11/14/040-cpp%E9%80%92%E5%BD%92%E4%BA%92%E6%96%A5%E9%94%81%E3%80%81lock_guard%E5%92%8Cunique_lock/">https://hmmmmmya.github.io/2024/11/14/040-cpp%E9%80%92%E5%BD%92%E4%BA%92%E6%96%A5%E9%94%81%E3%80%81lock_guard%E5%92%8Cunique_lock/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://hmmmmmya.github.io" target="_blank">Hymns</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/c/">c++</a><a class="post-meta__tags" href="/tags/c-11/">c++11</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/11/14/041-cpp-learning/" title="041-c++ learning"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">041-c++ learning</div></div><div class="info-2"><div class="info-item-1">自用 c++ 学习资料   c++书籍 《c++ primer 5th》 《Effective c++》 《Effective modern c++》中文 《Google c++ style guide》中文, 英文 《C++ Concurrency in Action》  网站 cppreference 中文, 英文  c++库 boost awesome-cpp 开源 C++ 库- cppreference  工具 c++在线编译 c++数据类型 c++数据类型转换  博客 c++学习路线 c++那些事-光城 现代 c++教程-changkun 博客园-c++  常用...</div></div></div></a><a class="pagination-related" href="/2024/11/13/039-linux-mv/" title="039-linux-mv"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">039-linux-mv</div></div><div class="info-2"><div class="info-item-1">以下是关于 mv 命令在不同情况下的用法：   将文件夹移动到另一个文件夹内1. 将文件夹移动到另一个文件夹内假设要将文件夹 source_folder 移动到 destination_folder 内： 1mv source_folder destination_folder/  这样会将 source_folder 以及其中的所有内容移动到 destination_folder 中。 2. 将文件夹内的文件移动到另一个文件夹假设要将 source_folder 中的所有文件移动到 destination_folder 中： 1mv source_folder/* destination_folder/  这会将 source_folder 中的所有文件（不包含子文件夹）移动到 destination_folder。 如果希望同时移动子文件夹，可以使用 -r 选项： 1mv source_folder/* destination_folder/ -r  3. 将文件夹覆盖为另一个文件夹如果 destination_folder 已经存在，并希望用 source_folder...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/06/17/007_windows%E4%B8%8B%E6%90%AD%E5%BB%BACpp%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/" title="007_windows下搭建C++编译环境"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-17</div><div class="info-item-2">007_windows下搭建C++编译环境</div></div><div class="info-2"><div class="info-item-1">using CMake + MinGW + VSCode CMake is an open-source, cross-platform tool that uses compiler and platform independent configuration files to generate native build tool files specific to your compiler and platform. The CMake Tools extension integrates Visual Studio Code and CMake to make it easy to configure, build, and debug your C++ project.   环境配置 安装 VSCode 配置 VSCode 终端  安装 VSCode 插件 C&#x2F;C++  安装 VSCode 插件 CMake 和 CMake Tools  CMake 插件主要功能是 CMake 语法高亮、自动补全  CMake Tools 的功能主要是结合 VSCode...</div></div></div></a><a class="pagination-related" href="/2024/10/31/022_cpp%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A/" title="022_c++结构化绑定"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-31</div><div class="info-item-2">022_c++结构化绑定</div></div><div class="info-2"><div class="info-item-1">介绍下 c++ 的结构化绑定   结构化绑定(Structured Binding)是 C++17 引入的新特性,允许我们将结构体、数组或元组中的多个元素同时绑定到多个变量上。 以下是几个常见的使用场景:  绑定 tuple:  12std::tuple&lt;int, std::string, double&gt; tuple&#123;1, &quot;hello&quot;, 3.14&#125;;auto [id, name, value] = tuple;  // 自动解包到三个变量   绑定 pair:  1234std::map&lt;std::string, int&gt; map&#123;&#123;&quot;one&quot;, 1&#125;&#125;;for (const auto&amp; [key, value] : map) &#123;  // 遍历map时直接获取键值    std::cout &lt;&lt; key &lt;&lt; &quot;: &quot; &lt;&lt; value &lt;&lt;...</div></div></div></a><a class="pagination-related" href="/2024/10/31/023_cpp%E6%8A%98%E5%8F%A0%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="023_c++折叠表达式"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-31</div><div class="info-item-2">023_c++折叠表达式</div></div><div class="info-2"><div class="info-item-1">C++中的折叠表达式（Fold Expressions）是一种简化变参模板函数编写的语法，从 C++17 开始引入。折叠表达式可以对可变参数模板进行自动折叠，从而简化代码。   基本概念折叠表达式可以将可变参数模板中的所有参数，通过特定的运算符折叠为一个结果。常见的运算符包括加法+、乘法*、逻辑与&amp;&amp;、逻辑或||等。折叠表达式主要有四种形式：  一元左折叠：从左到右依次折叠，例如：(args + ...) 一元右折叠：从右到左依次折叠，例如：(... + args) 二元左折叠：用于指定初始值，从左到右依次折叠，例如：(init + ... + args) 二元右折叠：用于指定初始值，从右到左依次折叠，例如：(args + ... + init)  示例以下是每种折叠表达式的代码示例： 1. 一元左折叠123456789template&lt;typename... Args&gt;auto sum(Args... args) &#123;    return (args + ...);  // 将参数依次相加&#125;int main() &#123;   ...</div></div></div></a><a class="pagination-related" href="/2024/10/31/024_cpp%E5%88%9D%E5%A7%8B%E5%8C%96/" title="024_cpp初始化"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-31</div><div class="info-item-2">024_cpp初始化</div></div><div class="info-2"><div class="info-item-1">介绍下 c++ 的初始化   一. 自动初始化为 0 的情况在 C++中，初始化为 0 的情况取决于变量的类型、存储位置和初始化方式。以下是 C++中会自动初始化为 0 的几种情况： 1. 全局变量和静态变量 全局变量（包括命名空间作用域的变量）和静态变量（static）在定义时会被自动初始化为 0。  这种自动初始化包括整型初始化为 0，浮点型初始化为 0.0，指针初始化为nullptr，类对象会调用默认构造函数。 示例： 1234567int globalVar;          // 自动初始化为0static int staticVar;    // 静态变量自动初始化为0int main() &#123;    static int funcStaticVar;  // 函数内部的静态变量自动初始化为0    return 0;&#125;  2. 类中的非静态成员变量（使用值初始化） 如果对象的非静态成员变量没有显式初始化，在值初始化时这些成员变量会被自动初始化为...</div></div></div></a><a class="pagination-related" href="/2024/11/13/035-lamda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/" title="035-lamda表达式的应用场景"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-13</div><div class="info-item-2">035-lamda表达式的应用场景</div></div><div class="info-2"><div class="info-item-1">Lambda 表达式在 C++中是一个非常强大且灵活的特性，它在以下场景中会特别有用：   1. 简化代码Lambda 表达式可以用来简化代码，特别是在需要定义短小的匿名函数时。例如，在 STL 算法（如std::sort）中传递自定义比较函数时： 1234567891011121314#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iostream&gt;int main() &#123;    std::vector&lt;int&gt; vec = &#123;1, 5, 3, 4, 2&#125;;    std::sort(vec.begin(), vec.end(), [](int a, int b) &#123;        return a &lt; b;    &#125;);    for (int n : vec) &#123;        std::cout &lt;&lt; n &lt;&lt; &quot; &quot;;    &#125;    return...</div></div></div></a><a class="pagination-related" href="/2024/11/13/036-std-funtion/" title="036-std::funtion"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-13</div><div class="info-item-2">036-std::funtion</div></div><div class="info-2"><div class="info-item-1">std::function 是 C++11 引入的标准库组件，用于包装任意可调用的目标。它可以用来存储、传递和调用各种类型的可调用对象，如普通函数、Lambda 表达式、函数对象和成员函数等。下面是 std::function 的一些关键特点和用法：   1. 定义和用法std::function 模板类定义如下： 123#include &lt;functional&gt;std::function&lt;返回类型(参数类型...)&gt; 函数对象;  例如，定义一个接收两个 int 参数并返回 int 的函数对象： 1std::function&lt;int(int, int)&gt; func;  2. 存储和调用不同类型的可调用对象存储普通函数123456int add(int a, int b) &#123;    return a + b;&#125;std::function&lt;int(int, int)&gt; func = add;std::cout &lt;&lt; func(1, 2) &lt;&lt; std::endl; // 输出 3  存储...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Hymns</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">59</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#lock-guard-%E5%92%8C-mutex-%E6%98%AF%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB"><span class="toc-number">1.</span> <span class="toc-text">lock_guard 和 mutex 是什么关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%83%E4%BB%AC%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.1.</span> <span class="toc-text">它们的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8std-lock-guard"><span class="toc-number">1.2.</span> <span class="toc-text">为什么要使用std::lock_guard</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-number">1.3.</span> <span class="toc-text">示例代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lock-guard-%E5%92%8C-unique-lock-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.</span> <span class="toc-text">lock_guard 和 unique_lock 的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%94%81%E7%9A%84%E7%81%B5%E6%B4%BB%E6%80%A7"><span class="toc-number">2.1.</span> <span class="toc-text">1. 锁的灵活性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BB%B6%E8%BF%9F%E5%8A%A0%E9%94%81%E5%92%8C%E8%A7%A3%E9%94%81"><span class="toc-number">2.2.</span> <span class="toc-text">2. 延迟加锁和解锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E7%9A%84%E6%94%AF%E6%8C%81"><span class="toc-number">2.3.</span> <span class="toc-text">3. 条件变量的支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%BC%80%E9%94%80"><span class="toc-number">2.4.</span> <span class="toc-text">4. 开销</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.5.</span> <span class="toc-text">使用示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#std-lock-guard"><span class="toc-number">2.5.1.</span> <span class="toc-text">std::lock_guard</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#std-unique-lock"><span class="toc-number">2.5.2.</span> <span class="toc-text">std::unique_lock</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">2.6.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/30/059-int%E8%B5%8B%E5%80%BC%E7%BB%99char/" title="059-int赋值给char">059-int赋值给char</a><time datetime="2024-11-30T08:28:46.000Z" title="发表于 2024-11-30 16:28:46">2024-11-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/28/058-design-patterns-learning/" title="058-design-patterns-learning">058-design-patterns-learning</a><time datetime="2024-11-28T09:04:03.000Z" title="发表于 2024-11-28 17:04:03">2024-11-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/22/057-nlohmann-json%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/" title="057-nlohmann_json库的使用">057-nlohmann_json库的使用</a><time datetime="2024-11-22T07:54:26.000Z" title="发表于 2024-11-22 15:54:26">2024-11-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/21/056-ifndef-LINUX/" title="056-ifndef LINUX">056-ifndef LINUX</a><time datetime="2024-11-21T09:53:59.000Z" title="发表于 2024-11-21 17:53:59">2024-11-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/21/055-windwos%E4%B8%8B%E7%94%A8Studio%E7%BC%96%E8%AF%91%E7%BC%BA%E5%B0%91jsoncpp%E5%BA%93%E6%80%8E%E4%B9%88%E5%8A%9E/" title="055-windwos下用Studio编译缺少jsoncpp库怎么办">055-windwos下用Studio编译缺少jsoncpp库怎么办</a><time datetime="2024-11-21T09:49:54.000Z" title="发表于 2024-11-21 17:49:54">2024-11-21</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2024 By Hymns</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>