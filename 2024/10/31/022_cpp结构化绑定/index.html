<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>022_c++结构化绑定 | Hymns</title><meta name="author" content="Hymns"><meta name="copyright" content="Hymns"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="介绍下 c++ 的结构化绑定">
<meta property="og:type" content="article">
<meta property="og:title" content="022_c++结构化绑定">
<meta property="og:url" content="https://hmmmmmya.github.io/2024/10/31/022_cpp%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A/index.html">
<meta property="og:site_name" content="Hymns">
<meta property="og:description" content="介绍下 c++ 的结构化绑定">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hmmmmmya.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2024-10-31T06:58:46.000Z">
<meta property="article:modified_time" content="2024-10-31T07:10:11.427Z">
<meta property="article:author" content="Hymns">
<meta property="article:tag" content="c++">
<meta property="article:tag" content="c++17">
<meta property="article:tag" content="现代c++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hmmmmmya.github.io/img/butterfly-icon.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://hmmmmmya.github.io/2024/10/31/022_cpp%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '022_c++结构化绑定',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: false,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/atom.xml" title="Hymns" type="application/atom+xml">
</head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/cover1.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hymns</span></a><a class="nav-page-title" href="/"><span class="site-name">022_c++结构化绑定</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">022_c++结构化绑定</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-31T06:58:46.000Z" title="发表于 2024-10-31 14:58:46">2024-10-31</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-31T07:10:11.427Z" title="更新于 2024-10-31 15:10:11">2024-10-31</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/c/">c++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>介绍下 c++ 的结构化绑定</p>
<span id="more"></span>

<p>结构化绑定(Structured Binding)是 C++17 引入的新特性,允许我们将结构体、数组或元组中的多个元素同时绑定到多个变量上。</p>
<p>以下是几个常见的使用场景:</p>
<ol>
<li>绑定 tuple:</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::tuple&lt;<span class="type">int</span>, std::string, <span class="type">double</span>&gt; tuple&#123;<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>, <span class="number">3.14</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> [id, name, value] = tuple;  <span class="comment">// 自动解包到三个变量</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>绑定 pair:</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt; map&#123;&#123;<span class="string">&quot;one&quot;</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [key, value] : map) &#123;  <span class="comment">// 遍历map时直接获取键值</span></span><br><span class="line">    std::cout &lt;&lt; key &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>绑定结构体:</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line">Point p&#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> [x, y] = p;  <span class="comment">// 直接获取结构体的成员</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>绑定数组:</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> array[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> [a, b, c] = array;  <span class="comment">// 解包固定大小的数组</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在函数返回多个值时使用:</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::tuple&lt;<span class="type">bool</span>, std::string&gt; <span class="title">ValidateUser</span><span class="params">(<span class="type">const</span> std::string&amp; user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="literal">true</span>, <span class="string">&quot;验证成功&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用时</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> [success, message] = <span class="built_in">ValidateUser</span>(<span class="string">&quot;admin&quot;</span>); success) &#123;</span><br><span class="line">    std::cout &lt;&lt; message &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在之前的代码中的应用:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原来的写法</span></span><br><span class="line">std::vector&lt;std::tuple&lt;T, T, T&gt;&gt; &amp;params;</span><br><span class="line">T min = std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(params.<span class="built_in">at</span>(i));</span><br><span class="line">T max = std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(params.<span class="built_in">at</span>(i));</span><br><span class="line">std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(params.<span class="built_in">at</span>(i)) = value;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用结构化绑定的写法</span></span><br><span class="line"><span class="keyword">auto</span>&amp; [value, min, max] = params[i];  <span class="comment">// 一次性获取所有值</span></span><br></pre></td></tr></table></figure>

<p>优点:</p>
<ol>
<li>代码更简洁易读</li>
<li>避免重复访问容器元素</li>
<li>减少了使用 std::get 的繁琐语法</li>
<li>变量名更有意义,提高代码可维护性</li>
</ol>
<p>注意事项:</p>
<ol>
<li>需要 C++17 或更高版本</li>
<li>绑定的变量数量必须与结构中的元素数量完全匹配</li>
<li>使用 auto 关键字声明</li>
<li>可以使用引用(&amp;)来避免拷贝</li>
</ol>
<p>结构化绑定是现代 C++中非常实用的特性,能让代码更加简洁优雅。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://hmmmmmya.github.io">Hymns</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://hmmmmmya.github.io/2024/10/31/022_cpp%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A/">https://hmmmmmya.github.io/2024/10/31/022_cpp%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://hmmmmmya.github.io" target="_blank">Hymns</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/c/">c++</a><a class="post-meta__tags" href="/tags/c-17/">c++17</a><a class="post-meta__tags" href="/tags/%E7%8E%B0%E4%BB%A3c/">现代c++</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/10/31/023_cpp%E6%8A%98%E5%8F%A0%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="023_c++折叠表达式"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">023_c++折叠表达式</div></div><div class="info-2"><div class="info-item-1">C++中的折叠表达式（Fold Expressions）是一种简化变参模板函数编写的语法，从 C++17 开始引入。折叠表达式可以对可变参数模板进行自动折叠，从而简化代码。   基本概念折叠表达式可以将可变参数模板中的所有参数，通过特定的运算符折叠为一个结果。常见的运算符包括加法+、乘法*、逻辑与&amp;&amp;、逻辑或||等。折叠表达式主要有四种形式：  一元左折叠：从左到右依次折叠，例如：(args + ...) 一元右折叠：从右到左依次折叠，例如：(... + args) 二元左折叠：用于指定初始值，从左到右依次折叠，例如：(init + ... + args) 二元右折叠：用于指定初始值，从右到左依次折叠，例如：(args + ... + init)  示例以下是每种折叠表达式的代码示例： 1. 一元左折叠123456789template&lt;typename... Args&gt;auto sum(Args... args) &#123;    return (args + ...);  // 将参数依次相加&#125;int main() &#123;   ...</div></div></div></a><a class="pagination-related" href="/2024/10/30/021_%E4%B8%BB%E9%A2%98%E7%9A%AE%E8%82%A4%E6%8E%A8%E8%8D%90/" title="021_主题皮肤推荐"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">021_主题皮肤推荐</div></div><div class="info-2"><div class="info-item-1">好用的主题皮肤推荐      工具 主题皮肤 备注    vscode Night Owl fav    One Dark Pro foggy   typora Vue fav    Github     Juejin    </div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/10/31/023_cpp%E6%8A%98%E5%8F%A0%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="023_c++折叠表达式"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-31</div><div class="info-item-2">023_c++折叠表达式</div></div><div class="info-2"><div class="info-item-1">C++中的折叠表达式（Fold Expressions）是一种简化变参模板函数编写的语法，从 C++17 开始引入。折叠表达式可以对可变参数模板进行自动折叠，从而简化代码。   基本概念折叠表达式可以将可变参数模板中的所有参数，通过特定的运算符折叠为一个结果。常见的运算符包括加法+、乘法*、逻辑与&amp;&amp;、逻辑或||等。折叠表达式主要有四种形式：  一元左折叠：从左到右依次折叠，例如：(args + ...) 一元右折叠：从右到左依次折叠，例如：(... + args) 二元左折叠：用于指定初始值，从左到右依次折叠，例如：(init + ... + args) 二元右折叠：用于指定初始值，从右到左依次折叠，例如：(args + ... + init)  示例以下是每种折叠表达式的代码示例： 1. 一元左折叠123456789template&lt;typename... Args&gt;auto sum(Args... args) &#123;    return (args + ...);  // 将参数依次相加&#125;int main() &#123;   ...</div></div></div></a><a class="pagination-related" href="/2024/06/17/007_windows%E4%B8%8B%E6%90%AD%E5%BB%BACpp%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/" title="007_windows下搭建C++编译环境"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-17</div><div class="info-item-2">007_windows下搭建C++编译环境</div></div><div class="info-2"><div class="info-item-1">using CMake + MinGW + VSCode CMake is an open-source, cross-platform tool that uses compiler and platform independent configuration files to generate native build tool files specific to your compiler and platform. The CMake Tools extension integrates Visual Studio Code and CMake to make it easy to configure, build, and debug your C++ project.   环境配置 安装 VSCode 配置 VSCode 终端  安装 VSCode 插件 C&#x2F;C++  安装 VSCode 插件 CMake 和 CMake Tools  CMake 插件主要功能是 CMake 语法高亮、自动补全  CMake Tools 的功能主要是结合 VSCode...</div></div></div></a><a class="pagination-related" href="/2024/10/31/024_cpp%E5%88%9D%E5%A7%8B%E5%8C%96/" title="024_cpp初始化"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-31</div><div class="info-item-2">024_cpp初始化</div></div><div class="info-2"><div class="info-item-1">介绍下 c++ 的初始化   一. 自动初始化为 0 的情况在 C++中，初始化为 0 的情况取决于变量的类型、存储位置和初始化方式。以下是 C++中会自动初始化为 0 的几种情况： 1. 全局变量和静态变量 全局变量（包括命名空间作用域的变量）和静态变量（static）在定义时会被自动初始化为 0。  这种自动初始化包括整型初始化为 0，浮点型初始化为 0.0，指针初始化为nullptr，类对象会调用默认构造函数。 示例： 1234567int globalVar;          // 自动初始化为0static int staticVar;    // 静态变量自动初始化为0int main() &#123;    static int funcStaticVar;  // 函数内部的静态变量自动初始化为0    return 0;&#125;  2. 类中的非静态成员变量（使用值初始化） 如果对象的非静态成员变量没有显式初始化，在值初始化时这些成员变量会被自动初始化为...</div></div></div></a><a class="pagination-related" href="/2024/11/13/035-lamda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/" title="035-lamda表达式的应用场景"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-13</div><div class="info-item-2">035-lamda表达式的应用场景</div></div><div class="info-2"><div class="info-item-1">Lambda 表达式在 C++中是一个非常强大且灵活的特性，它在以下场景中会特别有用：   1. 简化代码Lambda 表达式可以用来简化代码，特别是在需要定义短小的匿名函数时。例如，在 STL 算法（如std::sort）中传递自定义比较函数时： 1234567891011121314#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iostream&gt;int main() &#123;    std::vector&lt;int&gt; vec = &#123;1, 5, 3, 4, 2&#125;;    std::sort(vec.begin(), vec.end(), [](int a, int b) &#123;        return a &lt; b;    &#125;);    for (int n : vec) &#123;        std::cout &lt;&lt; n &lt;&lt; &quot; &quot;;    &#125;    return...</div></div></div></a><a class="pagination-related" href="/2024/11/13/036-std-funtion/" title="036-std::funtion"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-13</div><div class="info-item-2">036-std::funtion</div></div><div class="info-2"><div class="info-item-1">std::function 是 C++11 引入的标准库组件，用于包装任意可调用的目标。它可以用来存储、传递和调用各种类型的可调用对象，如普通函数、Lambda 表达式、函数对象和成员函数等。下面是 std::function 的一些关键特点和用法：   1. 定义和用法std::function 模板类定义如下： 123#include &lt;functional&gt;std::function&lt;返回类型(参数类型...)&gt; 函数对象;  例如，定义一个接收两个 int 参数并返回 int 的函数对象： 1std::function&lt;int(int, int)&gt; func;  2. 存储和调用不同类型的可调用对象存储普通函数123456int add(int a, int b) &#123;    return a + b;&#125;std::function&lt;int(int, int)&gt; func = add;std::cout &lt;&lt; func(1, 2) &lt;&lt; std::endl; // 输出 3  存储...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Hymns</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/13/039-linux-mv/" title="039-linux-mv">039-linux-mv</a><time datetime="2024-11-13T09:14:08.000Z" title="发表于 2024-11-13 17:14:08">2024-11-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/13/038-%E7%BD%91%E5%85%B3/" title="038-网关">038-网关</a><time datetime="2024-11-13T06:20:46.000Z" title="发表于 2024-11-13 14:20:46">2024-11-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/13/037-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB/" title="037-服务器的分类">037-服务器的分类</a><time datetime="2024-11-13T03:56:05.000Z" title="发表于 2024-11-13 11:56:05">2024-11-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/13/036-std-funtion/" title="036-std::funtion">036-std::funtion</a><time datetime="2024-11-13T02:18:39.000Z" title="发表于 2024-11-13 10:18:39">2024-11-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/13/035-lamda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/" title="035-lamda表达式的应用场景">035-lamda表达式的应用场景</a><time datetime="2024-11-13T01:32:51.000Z" title="发表于 2024-11-13 09:32:51">2024-11-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2024 By Hymns</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>