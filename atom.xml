<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hymns</title>
  
  
  <link href="https://hmmmmmya.github.io/atom.xml" rel="self"/>
  
  <link href="https://hmmmmmya.github.io/"/>
  <updated>2024-11-07T04:23:15.514Z</updated>
  <id>https://hmmmmmya.github.io/</id>
  
  <author>
    <name>Hymns</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>027_GOF设计模式分类</title>
    <link href="https://hmmmmmya.github.io/2024/11/07/027_GOF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB/"/>
    <id>https://hmmmmmya.github.io/2024/11/07/027_GOF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB/</id>
    <published>2024-11-07T04:15:10.000Z</published>
    <updated>2024-11-07T04:23:15.514Z</updated>
    
    <content type="html"><![CDATA[<p>GOF 设计模式是经过总结、优化的代码设计经验，用于解决软件设计中的特定问题。设计模式通常分为三大类：<strong>创建型模式</strong>、<strong>结构型模式</strong>和<strong>行为型模式</strong>。以下是每个分类中的常见设计模式：</p><span id="more"></span><h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h3><p>这些模式处理对象的创建问题，并提供更灵活、可复用的创建机制。</p><ol><li><strong>单例模式（Singleton Pattern）</strong>: 确保一个类只有一个实例，并提供全局访问点。</li><li><strong>工厂方法模式（Factory Method Pattern）</strong>: 定义一个创建对象的接口，但由子类决定要实例化的类。</li><li><strong>抽象工厂模式（Abstract Factory Pattern）</strong>: 提供一个创建一系列相关或依赖对象的接口，而无需指定具体类。</li><li><strong>生成器模式（Builder Pattern）</strong>: 将对象的构建过程与表示分离，使得同样的构建过程可以创建不同的表示。</li><li><strong>原型模式（Prototype Pattern）</strong>: 通过复制现有对象来创建新对象，避免了对象的重复初始化。</li></ol><h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><p>这些模式关注类和对象的组合关系，解决系统的结构问题。</p><ol><li><strong>适配器模式（Adapter Pattern）</strong>: 使得原本由于接口不兼容而不能一起工作的类可以一起工作。</li><li><strong>桥接模式（Bridge Pattern）</strong>: 将抽象部分与它的实现部分分离，使它们都可以独立地变化。</li><li><strong>组合模式（Composite Pattern）</strong>: 将对象组合成树形结构以表示”部分-整体”的层次结构，使得客户端可以统一地处理单个对象和组合对象。</li><li><strong>装饰者模式（Decorator Pattern）</strong>: 动态地给对象增加额外的职责。</li><li><strong>外观模式（Facade Pattern）</strong>: 提供一个统一的接口，用来访问子系统中的一群接口。</li><li><strong>享元模式（Flyweight Pattern）</strong>: 运用共享技术来支持大量细粒度的对象。</li><li><strong>代理模式（Proxy Pattern）</strong>: 为其他对象提供一种代理，以控制对这个对象的访问。</li></ol><h3 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h3><p>这些模式关注对象之间的职责划分和相互协作。</p><ol><li><strong>策略模式（Strategy Pattern）</strong>: 定义一系列算法，将每一个算法封装起来，并且使它们可以互换。</li><li><strong>模板方法模式（Template Method Pattern）</strong>: 在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。</li><li><strong>观察者模式（Observer Pattern）</strong>: 定义对象之间的一种一对多的依赖关系。</li><li><strong>迭代器模式（Iterator Pattern）</strong>: 提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。</li><li><strong>职责链模式（Chain of Responsibility Pattern）</strong>: 为请求创建一个接收者对象的链。</li><li><strong>命令模式（Command Pattern）</strong>: 将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。</li><li><strong>备忘录模式（Memento Pattern）</strong>: 在不破坏封装性的前提下，捕获并外部化一个对象的内部状态。</li><li><strong>状态模式（State Pattern）</strong>: 允许对象在内部状态改变时改变它的行为。</li><li><strong>中介者模式（Mediator Pattern）</strong>: 用一个中介对象来封装一系列对象的交互。</li><li><strong>解释器模式（Interpreter Pattern）</strong>: 给定一种语言，定义它的文法表示，并定义一个解释器来处理这个文法。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;GOF 设计模式是经过总结、优化的代码设计经验，用于解决软件设计中的特定问题。设计模式通常分为三大类：&lt;strong&gt;创建型模式&lt;/strong&gt;、&lt;strong&gt;结构型模式&lt;/strong&gt;和&lt;strong&gt;行为型模式&lt;/strong&gt;。以下是每个分类中的常见设计模式：&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://hmmmmmya.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://hmmmmmya.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>026_gitignore</title>
    <link href="https://hmmmmmya.github.io/2024/11/04/026_gitignore/"/>
    <id>https://hmmmmmya.github.io/2024/11/04/026_gitignore/</id>
    <published>2024-11-04T10:05:52.000Z</published>
    <updated>2024-11-04T10:06:53.478Z</updated>
    
    <content type="html"><![CDATA[<p>Git 忽略文件的规则</p><span id="more"></span><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><code>.gitignore</code> 文件是用来告诉 Git 哪些文件或目录在版本控制中应该被忽略的。这对于排除编译生成的文件、临时文件、日志文件以及敏感数据等非常有用。下面是一些编写 <code>.gitignore</code> 文件的基本规则和示例：</p><ol><li><p><strong>文件名匹配规则</strong>：</p><ul><li><code>*</code>：匹配零个或多个字符。</li><li><code>?</code>：匹配任意一个字符。</li><li><code>[]</code>：匹配方括号内的任意一个字符。</li><li><code>!</code>：在模式前加上感叹号表示取反，即排除匹配的文件或目录。</li></ul></li><li><p><strong>注释</strong>：以 <code>#</code> 开头的行表示注释，Git 会忽略这些行。</p></li><li><p><strong>示例</strong>：</p><ul><li><p>忽略所有 <code>.a</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*.a</span><br></pre></td></tr></table></figure></li><li><p>但是跟踪 <code>lib.a</code>，即使在忽略 <code>.a</code> 文件的规则下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!lib.a</span><br></pre></td></tr></table></figure></li><li><p>忽略所有以 <code>.o</code> 结尾的文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*.o</span><br></pre></td></tr></table></figure></li><li><p>忽略所有以 <code>~</code> 结尾的临时文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*~</span><br></pre></td></tr></table></figure></li><li><p>忽略 <code>TODO</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TODO</span><br></pre></td></tr></table></figure></li><li><p>忽略 <code>build/</code> 目录下的所有文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build/</span><br></pre></td></tr></table></figure></li><li><p>忽略 <code>doc/notes.txt</code> 文件，但不包括 <code>doc/server/arch.txt</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doc/notes.txt</span><br></pre></td></tr></table></figure></li><li><p>忽略 <code>doc/</code> 目录下的 <code>.pdf</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doc/*.pdf</span><br></pre></td></tr></table></figure></li><li><p>忽略 <code>doc/</code> 目录下的所有 <code>.pdf</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="取消忽略后无效果"><a href="#取消忽略后无效果" class="headerlink" title="取消忽略后无效果"></a>取消忽略后无效果</h3><p>如果上述 <code>.gitignore</code> 规则没有达到预期效果，可以尝试更具体的忽略和取消忽略规则。在 <code>.gitignore</code> 文件中，顺序和具体路径可能会影响规则的应用。以下是调整后的版本，确保首先取消忽略特定的文件夹，然后忽略一般的文件夹：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 取消忽略以 hexo-theme- 开头的文件夹</span><br><span class="line">!node_modules/hexo-theme-*/</span><br><span class="line"></span><br><span class="line"># 忽略 node_modules 文件夹及其所有内容</span><br><span class="line">node_modules/</span><br><span class="line"></span><br><span class="line"># 忽略 node_modules 文件夹下的 hexo-theme-landscape 文件夹</span><br><span class="line">node_modules/hexo-theme-landscape/</span><br></pre></td></tr></table></figure><p>另外，请确保这些文件夹已经被 Git 跟踪（即它们之前没有被忽略）。如果这些文件夹之前已经被忽略，需要先将它们从缓存中移除，然后重新添加它们。可以按照以下步骤操作：</p><ol><li><p>从 Git 缓存中移除 <code>node_modules</code> 文件夹（但保留本地文件）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> -r --cached node_modules</span><br></pre></td></tr></table></figure></li><li><p>确认 <code>.gitignore</code> 文件中的规则。</p></li><li><p>重新添加 <code>node_modules</code> 文件夹：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add node_modules</span><br></pre></td></tr></table></figure></li><li><p>提交更改：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;Update .gitignore rules&quot;</span></span><br></pre></td></tr></table></figure></li></ol><p>通过这些步骤，Git 将正确应用 <code>.gitignore</code> 文件中的规则。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Git 忽略文件的规则&lt;/p&gt;</summary>
    
    
    
    <category term="git" scheme="https://hmmmmmya.github.io/categories/git/"/>
    
    
    <category term="git" scheme="https://hmmmmmya.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>025_PR和MR的区别</title>
    <link href="https://hmmmmmya.github.io/2024/11/04/025_PR%E5%92%8CMR%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://hmmmmmya.github.io/2024/11/04/025_PR%E5%92%8CMR%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2024-11-04T09:59:06.000Z</published>
    <updated>2024-11-04T10:00:45.416Z</updated>
    
    <content type="html"><![CDATA[<p>PR（Pull Request）和 MR（Merge Request）是代码版本控制系统中的两个概念，它们主要用于在多人协作开发项目时合并代码变更。这两个术语在功能上非常相似，但在不同的代码托管平台上有不同的称呼。</p><span id="more"></span><h2 id="PR（Pull-Request）"><a href="#PR（Pull-Request）" class="headerlink" title="PR（Pull Request）"></a>PR（Pull Request）</h2><ul><li><strong>定义</strong>: Pull Request 是 GitHub、Bitbucket、GitLab 等平台上用于代码合并的一种请求机制。当开发者在自己的分支上完成了一组代码更改后，他们可以创建一个 Pull Request 请求，将这些更改合并到主分支（例如 <code>main</code> 或 <code>master</code>）或者其他目标分支。</li><li><strong>使用场景</strong>:<ul><li>开发者完成功能或修复后，创建 PR 并向代码库的维护者或团队成员发出请求，要求对这些更改进行审查。</li><li>审查通过后，维护者可以批准并合并 PR，将这些更改合并到目标分支中。</li></ul></li><li><strong>平台</strong>: PR 这个术语主要用于 GitHub 和 Bitbucket 等平台。</li></ul><h2 id="MR（Merge-Request）"><a href="#MR（Merge-Request）" class="headerlink" title="MR（Merge Request）"></a>MR（Merge Request）</h2><ul><li><p><strong>定义</strong>: Merge Request 是 GitLab 上使用的术语，功能上与 Pull Request 类似。MR 用于向项目中的其他开发者或团队发出合并代码更改的请求。</p></li><li><p><strong>使用场景</strong>:</p><ul><li>在开发者完成某个功能或修复后，他们提交 MR 请求，将代码合并到主分支或其他目标分支。</li><li>代码库的维护者或团队成员审查 MR，并决定是否合并这些更改。</li></ul></li><li><p><strong>平台</strong>: MR 主要在 GitLab 上使用。</p></li></ul><h2 id="PR-和-MR-的区别"><a href="#PR-和-MR-的区别" class="headerlink" title="PR 和 MR 的区别"></a>PR 和 MR 的区别</h2><ul><li><strong>平台不同</strong>: PR 主要用于 GitHub 和 Bitbucket，MR 主要用于 GitLab。</li><li><strong>功能相同</strong>: 尽管名称不同，PR 和 MR 的核心功能都是相同的，即允许开发者在合并代码之前发起请求进行代码审查。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>无论是 PR 还是 MR，它们的主要目的是通过让代码库的维护者或团队成员审查代码，确保在代码合并到主分支之前能够发现并解决潜在的问题。这种机制有助于提高代码质量，减少引入的错误，同时也便于多人协作开发。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;PR（Pull Request）和 MR（Merge Request）是代码版本控制系统中的两个概念，它们主要用于在多人协作开发项目时合并代码变更。这两个术语在功能上非常相似，但在不同的代码托管平台上有不同的称呼。&lt;/p&gt;</summary>
    
    
    
    <category term="git" scheme="https://hmmmmmya.github.io/categories/git/"/>
    
    
    <category term="git" scheme="https://hmmmmmya.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>024_cpp初始化</title>
    <link href="https://hmmmmmya.github.io/2024/10/31/024_cpp%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>https://hmmmmmya.github.io/2024/10/31/024_cpp%E5%88%9D%E5%A7%8B%E5%8C%96/</id>
    <published>2024-10-31T09:43:25.000Z</published>
    <updated>2024-10-31T09:59:00.923Z</updated>
    
    <content type="html"><![CDATA[<p>介绍下 c++ 的初始化</p><span id="more"></span><h2 id="一-自动初始化为-0-的情况"><a href="#一-自动初始化为-0-的情况" class="headerlink" title="一. 自动初始化为 0 的情况"></a>一. 自动初始化为 0 的情况</h2><p>在 C++中，初始化为 0 的情况取决于变量的类型、存储位置和初始化方式。以下是 C++中会自动初始化为 0 的几种情况：</p><h3 id="1-全局变量和静态变量"><a href="#1-全局变量和静态变量" class="headerlink" title="1. 全局变量和静态变量"></a>1. <strong>全局变量和静态变量</strong></h3><ul><li><p><strong>全局变量</strong>（包括命名空间作用域的变量）和<strong>静态变量</strong>（<code>static</code>）在定义时会被自动初始化为 0。</p></li><li><p>这种自动初始化包括整型初始化为 0，浮点型初始化为 0.0，指针初始化为<code>nullptr</code>，类对象会调用默认构造函数。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> globalVar;          <span class="comment">// 自动初始化为0</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> staticVar;    <span class="comment">// 静态变量自动初始化为0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> funcStaticVar;  <span class="comment">// 函数内部的静态变量自动初始化为0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-类中的非静态成员变量（使用值初始化）"><a href="#2-类中的非静态成员变量（使用值初始化）" class="headerlink" title="2. 类中的非静态成员变量（使用值初始化）"></a>2. <strong>类中的非静态成员变量（使用值初始化）</strong></h3><ul><li><p>如果对象的非静态成员变量没有显式初始化，在值初始化时这些成员变量会被自动初始化为 0。</p></li><li><p>值初始化通常发生在使用花括号初始化或默认初始化的情况下。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">double</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj&#123;&#125;;  <span class="comment">// obj.a 和 obj.b 都会被初始化为0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-数组的值初始化"><a href="#3-数组的值初始化" class="headerlink" title="3. 数组的值初始化"></a>3. <strong>数组的值初始化</strong></h3><ul><li><p>如果数组通过值初始化进行初始化，数组中的元素会被初始化为 0。</p></li><li><p>通常使用花括号初始化或空花括号初始化的方式触发此行为。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr1[<span class="number">5</span>] = &#123;&#125;;   <span class="comment">// 所有元素初始化为0</span></span><br><span class="line"><span class="type">int</span> arr2[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">// 所有元素初始化为0</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="4-动态分配的内存初始化"><a href="#4-动态分配的内存初始化" class="headerlink" title="4. 动态分配的内存初始化"></a>4. <strong>动态分配的内存初始化</strong></h3><ul><li><p>使用<code>new</code>时，如果使用了带括号的方式，会将分配的内存初始化为 0。</p></li><li><p>不加括号的<code>new</code>不会自动初始化（需要手动赋值）。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p1 = <span class="keyword">new</span> <span class="built_in">int</span>();       <span class="comment">// *p1 被初始化为0</span></span><br><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>]();   <span class="comment">// arr数组的每个元素都初始化为0</span></span><br><span class="line"><span class="keyword">delete</span> p1;</span><br><span class="line"><span class="keyword">delete</span>[] arr;</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-内置类型的局部变量不会自动初始化"><a href="#5-内置类型的局部变量不会自动初始化" class="headerlink" title="5. 内置类型的局部变量不会自动初始化"></a>5. <strong>内置类型的局部变量不会自动初始化</strong></h3><ul><li><p>如果是局部变量且不属于静态存储期的内置类型变量（如局部整型、浮点型或指针），则它们不会自动初始化为 0，值是未定义的，需手动初始化。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> localVar;    <span class="comment">// 未初始化，值未定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>C++中会自动初始化为 0 的主要情形包括全局&#x2F;静态变量、类中的非静态成员变量（在值初始化时）、使用值初始化的数组和使用括号初始化的动态内存。</p><h3 id="1-vector-初始化"><a href="#1-vector-初始化" class="headerlink" title="1. vector 初始化"></a>1. vector 初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>是的,使用这种方式定义 vector 时,编译器会自动将所有元素初始化为 0。</p><p>具体来说:</p><ol><li>对于内置类型(如 int, double 等),会被初始化为 0</li><li>对于类类型,会调用默认构造函数</li></ol><p>举例说明:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下定义方式都会将元素初始化为0</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">5</span>)</span></span>;           <span class="comment">// &#123;0,0,0,0,0&#125;</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">double</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">3</span>)</span></span>;        <span class="comment">// &#123;0.0,0.0,0.0&#125;</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">2</span>)</span></span>;          <span class="comment">// &#123;false,false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类类型会调用默认构造函数</span></span><br><span class="line"><span class="function">std::vector&lt;std::string&gt; <span class="title">v4</span><span class="params">(<span class="number">2</span>)</span></span>;   <span class="comment">// &#123;&quot;&quot;,&quot;&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>所以 vector 中的所有 int 元素已经被初始化为 0 了。</p><h2 id="二-存放内置类型的容器初始化"><a href="#二-存放内置类型的容器初始化" class="headerlink" title="二. 存放内置类型的容器初始化"></a>二. 存放内置类型的容器初始化</h2><p>在 C++中，存放内置类型的容器（如<code>std::vector&lt;int&gt;</code>）中的值是否会被初始化，取决于容器的构造和初始化方式。默认情况下，内置类型的元素不会自动初始化为 0，需要显式设置或采用某些特定的构造方式。以下是不同情况下的初始化行为：</p><h3 id="1-默认构造的容器"><a href="#1-默认构造的容器" class="headerlink" title="1. 默认构造的容器"></a>1. <strong>默认构造的容器</strong></h3><ul><li><p>如果使用默认构造的容器（即没有指定大小或初始值），则容器的内容为空。</p></li><li><p>例如，<code>std::vector&lt;int&gt; v;</code>会创建一个空的<code>vector</code>，没有任何元素，因此不存在初始化的问题。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;  <span class="comment">// 空容器，没有元素，因此没有初始化</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-指定大小的构造方式"><a href="#2-指定大小的构造方式" class="headerlink" title="2. 指定大小的构造方式"></a>2. <strong>指定大小的构造方式</strong></h3><ul><li><p>如果通过指定大小来构造容器，例如<code>std::vector&lt;int&gt; v(5);</code>，容器会分配出对应数量的元素。</p></li><li><p>对于内置类型的元素，使用此方式初始化时，值是未定义的，不会自动初始化为 0。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">5</span>)</span></span>;  <span class="comment">// 分配5个int元素，值未定义</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-指定大小和初始值的构造方式"><a href="#3-指定大小和初始值的构造方式" class="headerlink" title="3. 指定大小和初始值的构造方式"></a>3. <strong>指定大小和初始值的构造方式</strong></h3><ul><li><p>使用<code>std::vector&lt;int&gt; v(5, 0);</code>指定大小并提供初始值时，所有元素都会被初始化为指定的值（此处为 0）。</p></li><li><p>这种方式适用于确保容器中所有元素的初始值。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">5</span>, <span class="number">0</span>)</span></span>;  <span class="comment">// 分配5个元素，全部初始化为0</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="4-使用std-array"><a href="#4-使用std-array" class="headerlink" title="4. 使用std::array"></a>4. <strong>使用<code>std::array</code></strong></h3><ul><li><p><code>std::array</code>的大小是固定的，初始化时如果没有提供所有元素的初始值，未指定的元素会被自动初始化为 0。</p></li><li><p>例如，<code>std::array&lt;int, 5&gt; arr = &#123;1&#125;;</code>会将第一个元素初始化为 1，其他元素初始化为 0。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::array&lt;<span class="type">int</span>, 5&gt; arr = &#123;<span class="number">1</span>&#125;;  <span class="comment">// arr = &#123;1, 0, 0, 0, 0&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="5-使用std-vector的resize方法"><a href="#5-使用std-vector的resize方法" class="headerlink" title="5. 使用std::vector的resize方法"></a>5. <strong>使用<code>std::vector</code>的<code>resize</code>方法</strong></h3><ul><li><p>使用<code>resize</code>调整大小时，如果提供初始值参数（如<code>v.resize(5, 0);</code>），所有新元素会被初始化为指定值（这里是 0）。</p></li><li><p>如果不提供初始值，则新元素的值未定义。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">resize</span>(<span class="number">5</span>, <span class="number">0</span>);  <span class="comment">// 将容器扩展为5个元素，全部初始化为0</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li>**默认构造或仅指定大小的<code>vector</code>**：元素不会被初始化，值未定义。</li><li>**指定大小和初始值的<code>vector</code>**：元素会被初始化为指定值。</li><li><strong><code>std::array</code>初始化不完全填充</strong>：剩余元素会被初始化为 0。</li><li><strong><code>resize</code>时提供初始值</strong>：新元素会被初始化为该值。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍下 c++ 的初始化&lt;/p&gt;</summary>
    
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/categories/c/"/>
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>023_c++折叠表达式</title>
    <link href="https://hmmmmmya.github.io/2024/10/31/023_cpp%E6%8A%98%E5%8F%A0%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://hmmmmmya.github.io/2024/10/31/023_cpp%E6%8A%98%E5%8F%A0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2024-10-31T08:50:14.000Z</published>
    <updated>2024-10-31T08:52:50.425Z</updated>
    
    <content type="html"><![CDATA[<p>C++中的折叠表达式（Fold Expressions）是一种简化变参模板函数编写的语法，从 C++17 开始引入。折叠表达式可以对可变参数模板进行自动折叠，从而简化代码。</p><span id="more"></span><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>折叠表达式可以将可变参数模板中的所有参数，通过特定的运算符折叠为一个结果。常见的运算符包括加法<code>+</code>、乘法<code>*</code>、逻辑与<code>&amp;&amp;</code>、逻辑或<code>||</code>等。折叠表达式主要有四种形式：</p><ol><li><strong>一元左折叠</strong>：从左到右依次折叠，例如：<code>(args + ...)</code></li><li><strong>一元右折叠</strong>：从右到左依次折叠，例如：<code>(... + args)</code></li><li><strong>二元左折叠</strong>：用于指定初始值，从左到右依次折叠，例如：<code>(init + ... + args)</code></li><li><strong>二元右折叠</strong>：用于指定初始值，从右到左依次折叠，例如：<code>(args + ... + init)</code></li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>以下是每种折叠表达式的代码示例：</p><h4 id="1-一元左折叠"><a href="#1-一元左折叠" class="headerlink" title="1. 一元左折叠"></a>1. 一元左折叠</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args + ...);  <span class="comment">// 将参数依次相加</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);  <span class="comment">// 返回 1 + 2 + 3 + 4 = 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-一元右折叠"><a href="#2-一元右折叠" class="headerlink" title="2. 一元右折叠"></a>2. 一元右折叠</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (... + args);  <span class="comment">// 从右到左依次相加</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-二元左折叠"><a href="#3-二元左折叠" class="headerlink" title="3. 二元左折叠"></a>3. 二元左折叠</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span> + ... + args);  <span class="comment">// 从0开始，依次相加</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);  <span class="comment">// 返回 0 + 1 + 2 + 3 + 4 = 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-二元右折叠"><a href="#4-二元右折叠" class="headerlink" title="4. 二元右折叠"></a>4. 二元右折叠</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args + ... + <span class="number">0</span>);  <span class="comment">// 从右到左依次相加，最终加0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常见应用场景"><a href="#常见应用场景" class="headerlink" title="常见应用场景"></a>常见应用场景</h3><p>折叠表达式在编写模板时非常有用，常见的应用场景包括：</p><ol><li><strong>累加求和</strong>：将参数列表中的所有值求和。</li><li><strong>逻辑判断</strong>：可以通过折叠表达式实现<code>&amp;&amp;</code>和<code>||</code>运算来检查所有参数是否满足某个条件。</li><li><strong>打印参数</strong>：配合<code>std::cout</code>可以实现简单的参数打印。</li></ol><h4 id="逻辑判断的示例"><a href="#逻辑判断的示例" class="headerlink" title="逻辑判断的示例"></a>逻辑判断的示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">allTrue</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args &amp;&amp; ...);  <span class="comment">// 如果所有参数都为true，则返回true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">anyTrue</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args || ...);  <span class="comment">// 如果任意一个参数为true，则返回true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>折叠表达式大大减少了变参模板代码的复杂性，是编写简洁、高效代码的重要工具。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++中的折叠表达式（Fold Expressions）是一种简化变参模板函数编写的语法，从 C++17 开始引入。折叠表达式可以对可变参数模板进行自动折叠，从而简化代码。&lt;/p&gt;</summary>
    
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/categories/c/"/>
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/tags/c/"/>
    
    <category term="c++17" scheme="https://hmmmmmya.github.io/tags/c-17/"/>
    
    <category term="现代c++" scheme="https://hmmmmmya.github.io/tags/%E7%8E%B0%E4%BB%A3c/"/>
    
  </entry>
  
  <entry>
    <title>022_c++结构化绑定</title>
    <link href="https://hmmmmmya.github.io/2024/10/31/022_cpp%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A/"/>
    <id>https://hmmmmmya.github.io/2024/10/31/022_cpp%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A/</id>
    <published>2024-10-31T06:58:46.000Z</published>
    <updated>2024-10-31T07:10:11.427Z</updated>
    
    <content type="html"><![CDATA[<p>介绍下 c++ 的结构化绑定</p><span id="more"></span><p>结构化绑定(Structured Binding)是 C++17 引入的新特性,允许我们将结构体、数组或元组中的多个元素同时绑定到多个变量上。</p><p>以下是几个常见的使用场景:</p><ol><li>绑定 tuple:</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::tuple&lt;<span class="type">int</span>, std::string, <span class="type">double</span>&gt; tuple&#123;<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>, <span class="number">3.14</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> [id, name, value] = tuple;  <span class="comment">// 自动解包到三个变量</span></span><br></pre></td></tr></table></figure><ol start="2"><li>绑定 pair:</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt; map&#123;&#123;<span class="string">&quot;one&quot;</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [key, value] : map) &#123;  <span class="comment">// 遍历map时直接获取键值</span></span><br><span class="line">    std::cout &lt;&lt; key &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>绑定结构体:</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line">Point p&#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> [x, y] = p;  <span class="comment">// 直接获取结构体的成员</span></span><br></pre></td></tr></table></figure><ol start="4"><li>绑定数组:</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> array[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> [a, b, c] = array;  <span class="comment">// 解包固定大小的数组</span></span><br></pre></td></tr></table></figure><ol start="5"><li>在函数返回多个值时使用:</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::tuple&lt;<span class="type">bool</span>, std::string&gt; <span class="title">ValidateUser</span><span class="params">(<span class="type">const</span> std::string&amp; user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="literal">true</span>, <span class="string">&quot;验证成功&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用时</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> [success, message] = <span class="built_in">ValidateUser</span>(<span class="string">&quot;admin&quot;</span>); success) &#123;</span><br><span class="line">    std::cout &lt;&lt; message &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在之前的代码中的应用:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原来的写法</span></span><br><span class="line">std::vector&lt;std::tuple&lt;T, T, T&gt;&gt; &amp;params;</span><br><span class="line">T min = std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(params.<span class="built_in">at</span>(i));</span><br><span class="line">T max = std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(params.<span class="built_in">at</span>(i));</span><br><span class="line">std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(params.<span class="built_in">at</span>(i)) = value;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用结构化绑定的写法</span></span><br><span class="line"><span class="keyword">auto</span>&amp; [value, min, max] = params[i];  <span class="comment">// 一次性获取所有值</span></span><br></pre></td></tr></table></figure><p>优点:</p><ol><li>代码更简洁易读</li><li>避免重复访问容器元素</li><li>减少了使用 std::get 的繁琐语法</li><li>变量名更有意义,提高代码可维护性</li></ol><p>注意事项:</p><ol><li>需要 C++17 或更高版本</li><li>绑定的变量数量必须与结构中的元素数量完全匹配</li><li>使用 auto 关键字声明</li><li>可以使用引用(&amp;)来避免拷贝</li></ol><p>结构化绑定是现代 C++中非常实用的特性,能让代码更加简洁优雅。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍下 c++ 的结构化绑定&lt;/p&gt;</summary>
    
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/categories/c/"/>
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/tags/c/"/>
    
    <category term="c++17" scheme="https://hmmmmmya.github.io/tags/c-17/"/>
    
    <category term="现代c++" scheme="https://hmmmmmya.github.io/tags/%E7%8E%B0%E4%BB%A3c/"/>
    
  </entry>
  
  <entry>
    <title>021_主题皮肤推荐</title>
    <link href="https://hmmmmmya.github.io/2024/10/30/021_%E4%B8%BB%E9%A2%98%E7%9A%AE%E8%82%A4%E6%8E%A8%E8%8D%90/"/>
    <id>https://hmmmmmya.github.io/2024/10/30/021_%E4%B8%BB%E9%A2%98%E7%9A%AE%E8%82%A4%E6%8E%A8%E8%8D%90/</id>
    <published>2024-10-30T03:44:23.000Z</published>
    <updated>2024-11-01T04:19:15.386Z</updated>
    
    <content type="html"><![CDATA[<p>好用的主题皮肤推荐</p><span id="more"></span><table><thead><tr><th>工具</th><th>主题皮肤</th><th>备注</th></tr></thead><tbody><tr><td><strong>vscode</strong></td><td><em>Night Owl</em></td><td>fav</td></tr><tr><td></td><td>One Dark Pro</td><td>foggy</td></tr><tr><td><strong>typora</strong></td><td><em>Vue</em></td><td>fav</td></tr><tr><td></td><td>Github</td><td></td></tr><tr><td></td><td>Juejin</td><td></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;好用的主题皮肤推荐&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>020_如何修改 Linux 栈区大小</title>
    <link href="https://hmmmmmya.github.io/2024/10/29/020_%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%20Linux%20%E6%A0%88%E5%8C%BA%E5%A4%A7%E5%B0%8F/"/>
    <id>https://hmmmmmya.github.io/2024/10/29/020_%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%20Linux%20%E6%A0%88%E5%8C%BA%E5%A4%A7%E5%B0%8F/</id>
    <published>2024-10-29T08:42:00.000Z</published>
    <updated>2024-10-29T08:42:33.731Z</updated>
    
    <content type="html"><![CDATA[<p>栈，就是那些由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区。里面的变量通常是局部变量、函数参数等。和堆相比，栈通常很小。<br>在 Linux 系统中，栈区的大小是固定的，通常为 8 MB。然而，在某些情况下，我们可能需要修改栈区的大小。本文将介绍如何修改 Linux 栈区大小。</p><span id="more"></span><h2 id="1-查看当前栈区大小"><a href="#1-查看当前栈区大小" class="headerlink" title="1. 查看当前栈区大小"></a>1. 查看当前栈区大小</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -s // 一般为8192KB, 即8MB</span><br></pre></td></tr></table></figure><p>注：线程栈大小默认为 8M，8192 KB。</p><h2 id="2-修改栈区大小"><a href="#2-修改栈区大小" class="headerlink" title="2. 修改栈区大小"></a>2. 修改栈区大小</h2><h3 id="临时修改"><a href="#临时修改" class="headerlink" title="临时修改"></a>临时修改</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -s 102400 // 改为100MB</span><br></pre></td></tr></table></figure><p>注：ulimit -s ulimited 不限制。</p><h3 id="永久修改"><a href="#永久修改" class="headerlink" title="永久修改"></a>永久修改</h3><p>有两种方法：</p><ul><li><p>方法一：可以在&#x2F;etc&#x2F;rc.local 内加入 ulimit -s 102400 则可以开机就设置栈空间大小，任何用户启动的时候都会调用</p></li><li><p>方法二：修改配置文件&#x2F;etc&#x2F;security&#x2F;limits.conf</p></li></ul><p>手动添加：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* soft stack 102400</span><br></pre></td></tr></table></figure><p>自动添加：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -ne <span class="string">&quot;* soft stack 102400\n&quot;</span> &gt;&gt; /etc/security/limits.conf</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;栈，就是那些由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区。里面的变量通常是局部变量、函数参数等。和堆相比，栈通常很小。&lt;br&gt;在 Linux 系统中，栈区的大小是固定的，通常为 8 MB。然而，在某些情况下，我们可能需要修改栈区的大小。本文将介绍如何修改 Linux 栈区大小。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://hmmmmmya.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://hmmmmmya.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>019_Linux 查看库中是否包含指定函数</title>
    <link href="https://hmmmmmya.github.io/2024/10/29/019_Linux%20%E6%9F%A5%E7%9C%8B%E5%BA%93%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E6%8C%87%E5%AE%9A%E5%87%BD%E6%95%B0/"/>
    <id>https://hmmmmmya.github.io/2024/10/29/019_Linux%20%E6%9F%A5%E7%9C%8B%E5%BA%93%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E6%8C%87%E5%AE%9A%E5%87%BD%E6%95%B0/</id>
    <published>2024-10-29T08:10:00.000Z</published>
    <updated>2024-10-29T08:40:27.196Z</updated>
    
    <content type="html"><![CDATA[<p>在 Linux 系统中，我们经常需要确认某个函数是否在特定的库文件中。以下是几种常用的查找方法。</p><span id="more"></span><h2 id="1-nm-命令（最常用）"><a href="#1-nm-命令（最常用）" class="headerlink" title="1. nm 命令（最常用）"></a>1. nm 命令（最常用）</h2><p><code>nm</code> 命令用于查看库文件中的符号表，是最直接的方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本语法</span></span><br><span class="line">nm -D /path/to/library.so | grep <span class="string">&#x27;function_name&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际示例</span></span><br><span class="line">nm -D /usr/lib/libc.so.6 | grep <span class="string">&#x27;printf&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="2-objdump-命令（详细信息）"><a href="#2-objdump-命令（详细信息）" class="headerlink" title="2. objdump 命令（详细信息）"></a>2. objdump 命令（详细信息）</h2><p><code>objdump</code> 提供了更详细的库文件信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本语法</span></span><br><span class="line">objdump -T /path/to/library.so | grep <span class="string">&#x27;function_name&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际示例</span></span><br><span class="line">objdump -T /usr/lib/libc.so.6 | grep <span class="string">&#x27;printf&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="3-readelf-命令（ELF-文件专用）"><a href="#3-readelf-命令（ELF-文件专用）" class="headerlink" title="3. readelf 命令（ELF 文件专用）"></a>3. readelf 命令（ELF 文件专用）</h2><p>专门用于分析 ELF 格式文件的工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本语法</span></span><br><span class="line">readelf -Ws /path/to/library.so | grep <span class="string">&#x27;function_name&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际示例</span></span><br><span class="line">readelf -Ws /usr/lib/libc.so.6 | grep <span class="string">&#x27;printf&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="4-批量查找方法"><a href="#4-批量查找方法" class="headerlink" title="4. 批量查找方法"></a>4. 批量查找方法</h2><h3 id="使用-find-配合-nm-命令"><a href="#使用-find-配合-nm-命令" class="headerlink" title="使用 find 配合 nm 命令"></a>使用 find 配合 nm 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在指定目录下查找所有.so文件中的特定函数</span></span><br><span class="line">find /usr/lib -name <span class="string">&quot;*.so&quot;</span> -<span class="built_in">exec</span> nm -D &#123;&#125; \; | grep <span class="string">&#x27;function_name&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="使用-grep-直接搜索"><a href="#使用-grep-直接搜索" class="headerlink" title="使用 grep 直接搜索"></a>使用 grep 直接搜索</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在库目录中搜索函数名</span></span><br><span class="line">grep -R <span class="string">&#x27;function_name&#x27;</span> /usr/lib/</span><br></pre></td></tr></table></figure><h2 id="5-依赖关系查看（ldd）"><a href="#5-依赖关系查看（ldd）" class="headerlink" title="5. 依赖关系查看（ldd）"></a>5. 依赖关系查看（ldd）</h2><p>虽然不能直接查看函数，但可以查看库的依赖关系。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看可执行文件的库依赖</span></span><br><span class="line">ldd /path/to/executable</span><br></pre></td></tr></table></figure><h2 id="常见参数说明"><a href="#常见参数说明" class="headerlink" title="常见参数说明"></a>常见参数说明</h2><table><thead><tr><th>命令</th><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>nm</td><td>-D</td><td>只显示动态符号</td></tr><tr><td>objdump</td><td>-T</td><td>显示动态符号表</td></tr><tr><td>readelf</td><td>-W</td><td>使用宽格式显示</td></tr><tr><td></td><td>-s</td><td>显示符号表</td></tr></tbody></table><h2 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h2><ol><li><strong>快速查找</strong>：优先使用 <code>nm -D</code> 命令</li><li><strong>详细分析</strong>：需要更多信息时使用 <code>objdump</code> 或 <code>readelf</code></li><li><strong>批量查找</strong>：使用 <code>find</code> 配合 <code>nm</code> 命令</li><li><strong>依赖确认</strong>：使用 <code>ldd</code> 确认库是否正确链接</li></ol><h2 id="常见问题排查"><a href="#常见问题排查" class="headerlink" title="常见问题排查"></a>常见问题排查</h2><p>如果找到函数但链接失败，请检查：</p><ul><li>库文件的链接路径是否正确</li><li>库版本是否兼容</li><li>符号修饰（symbol mangling）是否匹配</li><li>编译器选项是否正确</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 Linux 系统中，我们经常需要确认某个函数是否在特定的库文件中。以下是几种常用的查找方法。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://hmmmmmya.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://hmmmmmya.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>018_为什么我们常见的 IP 都是 192.168 开头的</title>
    <link href="https://hmmmmmya.github.io/2024/10/29/018_%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E5%B8%B8%E8%A7%81%E7%9A%84%20IP%20%E9%83%BD%E6%98%AF%20192.168%20%E5%BC%80%E5%A4%B4%E7%9A%84/"/>
    <id>https://hmmmmmya.github.io/2024/10/29/018_%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E5%B8%B8%E8%A7%81%E7%9A%84%20IP%20%E9%83%BD%E6%98%AF%20192.168%20%E5%BC%80%E5%A4%B4%E7%9A%84/</id>
    <published>2024-10-29T07:56:00.000Z</published>
    <updated>2024-10-31T04:28:37.103Z</updated>
    
    <content type="html"><![CDATA[<p>为什么我们常见的 IP 都是 192.168 开头的</p><span id="more"></span><h2 id="ip-地址划分"><a href="#ip-地址划分" class="headerlink" title="ip 地址划分"></a>ip 地址划分</h2><p>参考：<a href="https://xiaolincoding.com/network/4_ip/ip_base.html#ip-%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%86%E7%B1%BB">IP 地址的分类</a></p><p>互联网诞生之初，IP 地址显得很充裕，于是计算机科学家们设计了分类地址。</p><p>IP 地址分类成了 5 种类型，分别是 A 类、B 类、C 类、D 类、E 类。</p><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20241029151149.png" alt="IP 地址的分类"></p><p>上图中黄色部分为分类号，用以区分 IP 地址类别。</p><h2 id="私网地址划分"><a href="#私网地址划分" class="headerlink" title="私网地址划分"></a>私网地址划分</h2><blockquote><p>10.0.0.0–10.255.255.255</p><p>172.16.0.0–172.31.255.255</p><p>192.168.0.0–192.168.255.255</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/image-20241029144309499.png" alt="私网地址"></p><p>除了这三个 ip 地址段为私有 ip 地址外，其它的都为公网 ip。</p><p>这些地址已被声明私有化，任何内网中的设备可以任意使用这些地址，但是在这三个范围内的 IP 地址不允许出现在 Internet（外网）上。所以我们平台在内部组网时用的比较多，比如监控项目与公司内部电脑 ip 设置，用的多的就是 192.168.xx。</p><p>通常情况下，按照需要容纳的主机数选择私有地址段。家庭网络规模比较小，一个 C 类地址，192.168.1.x 可以容纳 254 个终端，足够使用。</p><p>学校或者大型企业可能使用 B 类甚至 A 类作为内部网络的地址段。比如手机上网很可能获取的也是一个 10 开头的内网地址，而不是公网地址。</p><h2 id="NAT-地址转换"><a href="#NAT-地址转换" class="headerlink" title="NAT 地址转换"></a>NAT 地址转换</h2><p>私网地址只能在局域网中使用，不同的局域网可以使用同样的私网地址，私网地址是不能出现在互联网上的。那么私网地址如何访问互联网呢？这就需要用到 NAT 地址转换，将内网地址映射到外网地址。</p><p>而<strong>NAT 地址转换</strong>它实现内网的 IP 地址与公网的地址之间的相互转换，将大量的内网 IP 地址转换为一个或少量的公网 IP 地址，减少对公网 IP 地址的占用。</p><p>家庭网络普遍使用端口映射的方式，NAT 的核心是一张映射表（源 IP 地址，源端口，目的 IP 地址，目的端口），将内网源 IP 地址和端口映射到同一个公网地址的不同端口，如下图所示。</p><table><thead><tr><th>内网 IP（源地址:端口）</th><th>外网 IP（目标地址:端口）</th></tr></thead><tbody><tr><td>192.168.1.55:5566</td><td>219.152.168.222:9200</td></tr><tr><td>192.168.1.59:80</td><td>219.152.168.222:9201</td></tr><tr><td>192.168.1.59:4465</td><td>219.152.168.222:9202</td></tr></tbody></table><p>总之，家庭网络由于网络规模比较小，通常使用了 192.168 开头的私网地址，光猫拨号获取了一个公网地址（或者运营商私网地址），通过 NAT 方式的映射到这个公网地址的不同端口，访问互联网。主要注意的 NAT 模式和路由模式是不同的。</p><h2 id="无分类地址-CIDR"><a href="#无分类地址-CIDR" class="headerlink" title="无分类地址 CIDR"></a>无分类地址 CIDR</h2><p>正因为 IP 分类存在许多缺点，所以后面提出了无分类地址的方案，即 CIDR。</p><p>这种方式不再有分类地址的概念，32 比特的 IP 地址被划分为两部分，前面是网络号，后面是主机号。</p><p>怎么划分网络号和主机号的呢？</p><p>表示形式 a.b.c.d&#x2F;x，其中 &#x2F;x 表示前 x 位属于网络号， x 的范围是 0 ~ 32，这就使得 IP 地址更加具有灵活性。</p><p>比如 10.100.122.2&#x2F;24，这种地址表示形式就是 CIDR，&#x2F;24 表示前 24 位是网络号，剩余的 8 位是主机号。</p><h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><p>子网掩码和 CIDR 是配套使用的，CIDR 表示网络号，子网掩码表示主机号。掩码的意思就是掩盖掉主机号，剩余的就是网络号。</p><p>子网掩码和 IP 地址一样，也是 32 比特，左边是网络号，右边是主机号。</p><h2 id="网络号和主机号"><a href="#网络号和主机号" class="headerlink" title="网络号和主机号"></a>网络号和主机号</h2><p>网络号和主机号在 IP 地址中有着各自重要的作用，帮助计算机网络有效地传输数据和管理地址。具体来说：</p><h3 id="网络号-Network-Part"><a href="#网络号-Network-Part" class="headerlink" title="网络号 (Network Part)"></a>网络号 (Network Part)</h3><ul><li><p>定义：网络号是 IP 地址的前一部分，用于标识一个特定的网络。</p></li><li><p>作用：</p><ul><li><p>路由：网络设备（如路由器）利用网络号将数据包发送到正确的子网或网络。只需要检查数据包的网络号，就可以决定将其转发到哪个子网。</p></li><li><p>网络管理：网络号有助于网络管理员管理和组织不同的子网。通过网络号，管理员可以轻松地分配和控制 IP 地址资源。</p></li></ul></li></ul><h3 id="主机号-Host-Part"><a href="#主机号-Host-Part" class="headerlink" title="主机号 (Host Part)"></a>主机号 (Host Part)</h3><ul><li><p>定义：主机号是 IP 地址的后一部分，用于标识网络中的特定设备或节点。</p></li><li><p>作用：</p><ul><li><p>设备标识：主机号唯一标识网络中的每一个设备，确保数据包能准确地到达目标设备。</p></li><li><p>地址分配：在同一子网内，主机号确保每一个设备都有一个独一无二的地址，以避免地址冲突。</p></li></ul></li></ul><p>例如：<br>对于 IP 地址 192.168.1.1 和 子网掩码 255.255.255.0（C 类地址）：</p><ul><li><p>网络号：192.168.1（前 24 位）</p></li><li><p>主机号：1（后 8 位）</p></li></ul><p>这个地址划分方式确保了不同网络可以通过网络号来区分，同时在同一网络内的每个设备通过主机号来区分，从而实现高效的网络管理和数据传输。</p><h2 id="192-168"><a href="#192-168" class="headerlink" title="192.168"></a>192.168</h2><p>192.168.x.x 是 ipv4 的 c 类地址划分的一部分</p><p>C 类网络地址划分: 110 开头，21 位网络号，8 位主机号。C 类网络地址的 192.168 号段才是私有地址，其他号段是公有地址。</p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/image-20241029144154815.png" alt="image-20241029144154815" style="zoom: 67%;" /><p>C 类网络中，192.168 划分为私有地址，从 192.168.0.0 到 192.168.255.255。</p><h2 id="192-168-11-63"><a href="#192-168-11-63" class="headerlink" title="192.168.11.63"></a>192.168.11.63</h2><p>inet: 192.168.11.63<br>netmask: 255.255.248.0&#x2F;21</p><p>192.168.11.63 是 C 类网络地址，192.168 是网络号，11 是子网号，63 是主机号。</p><p>192.168.11.63 的二进制表示：</p><p>11000000.10101000.00001011.01111111</p><p>网络号：11000000.10101000.00001, 21 位网络号, 用于标识同一子网。</p><p>主机号：011 11111, 8 位主机号, 用于标识同一子网内的不同设备。</p><p>255.255.248.0 的二进制表示：</p><p>11111111.11111111.11111000.00000000</p><h3 id="同一子网"><a href="#同一子网" class="headerlink" title="同一子网"></a>同一子网</h3><p>从 11000000.10101000.00001000.00000000 到 11000000.10101000.00001111.11111111</p><p>即: 192.168.8.0 到 192.168.15.255</p><p>可用设备数: 2^8 - 2 &#x3D; 254</p><p>特殊地址:</p><ul><li><p>192.168.8.0: 网络地址, 不能分配给设备, 用于标识子网</p></li><li><p>192.168.15.255: 广播地址</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;为什么我们常见的 IP 都是 192.168 开头的&lt;/p&gt;</summary>
    
    
    
    <category term="网络" scheme="https://hmmmmmya.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络" scheme="https://hmmmmmya.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>017_开发工具推荐</title>
    <link href="https://hmmmmmya.github.io/2024/10/23/017_%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/"/>
    <id>https://hmmmmmya.github.io/2024/10/23/017_%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/</id>
    <published>2024-10-23T06:30:00.000Z</published>
    <updated>2024-10-24T01:33:48.744Z</updated>
    
    <content type="html"><![CDATA[<p>开发工具推荐</p><span id="more"></span><h3 id="开发工具推荐"><a href="#开发工具推荐" class="headerlink" title="开发工具推荐"></a>开发工具推荐</h3><table><thead><tr><th>平台</th><th>工具名称</th><th>功能描述</th><th>网址</th></tr></thead><tbody><tr><td><strong>IDE</strong></td><td>cursor</td><td>内置大模型, 完美兼容 vscode</td><td></td></tr><tr><td></td><td>vscode</td><td>插件丰富</td><td></td></tr><tr><td><strong>Git</strong></td><td>git</td><td>版本控制</td><td></td></tr><tr><td></td><td>Github Desktop</td><td>github 桌面客户端</td><td></td></tr><tr><td><strong>比较</strong></td><td>Beyond Compare</td><td>文件对比</td><td></td></tr><tr><td><strong>远程</strong></td><td>MobaXterm</td><td>远程连接</td><td></td></tr><tr><td><strong>数据库</strong></td><td>Navicat Premium Lite</td><td>数据库管理</td><td><a href="https://www.navicat.com.cn/download/navicat-premium-lite">https://www.navicat.com.cn/download/navicat-premium-lite</a></td></tr><tr><td><strong>容器</strong></td><td>Docker Desktop</td><td>容器化</td><td></td></tr><tr><td><strong>代理</strong></td><td>clash</td><td>代理工具</td><td></td></tr><tr><td><strong>抓包</strong></td><td>wireshark</td><td>抓包工具</td><td></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;开发工具推荐&lt;/p&gt;</summary>
    
    
    
    <category term="工具" scheme="https://hmmmmmya.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="工具" scheme="https://hmmmmmya.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>016_笔记工具推荐</title>
    <link href="https://hmmmmmya.github.io/2024/10/23/016_%E7%AC%94%E8%AE%B0%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/"/>
    <id>https://hmmmmmya.github.io/2024/10/23/016_%E7%AC%94%E8%AE%B0%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/</id>
    <published>2024-10-23T04:00:00.000Z</published>
    <updated>2024-10-25T01:29:42.320Z</updated>
    
    <content type="html"><![CDATA[<p>笔记工具推荐</p><span id="more"></span><h3 id="笔记工具推荐"><a href="#笔记工具推荐" class="headerlink" title="笔记工具推荐"></a>笔记工具推荐</h3><table><thead><tr><th>平台</th><th>工具名称</th><th>功能描述</th></tr></thead><tbody><tr><td>windows</td><td>vscode</td><td>编辑功能强大, 代码管控</td></tr><tr><td>windows</td><td>typora</td><td>界面优雅, pin 目录后可以快速切换</td></tr><tr><td>windows</td><td><del>vnote</del></td><td>快速切换, 快速修改, 不够优雅, 配置麻烦</td></tr><tr><td>windows</td><td>heynote</td><td>程序员笔记</td></tr><tr><td>windows</td><td>navicat</td><td>数据库</td></tr><tr><td>跨平台</td><td>wps</td><td>表格</td></tr><tr><td>跨平台</td><td>flomo</td><td>简短, 方便同步</td></tr><tr><td>跨平台</td><td>幕布</td><td>思维导图</td></tr><tr><td>跨平台</td><td>github</td><td>笔记托管</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;笔记工具推荐&lt;/p&gt;</summary>
    
    
    
    <category term="工具" scheme="https://hmmmmmya.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="工具" scheme="https://hmmmmmya.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>015_windows实用工具推荐</title>
    <link href="https://hmmmmmya.github.io/2024/10/23/015_windows%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/"/>
    <id>https://hmmmmmya.github.io/2024/10/23/015_windows%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/</id>
    <published>2024-10-23T02:09:14.000Z</published>
    <updated>2024-10-24T01:32:46.825Z</updated>
    
    <content type="html"><![CDATA[<p>windows 实用工具推荐</p><span id="more"></span><h3 id="Windows-实用工具推荐"><a href="#Windows-实用工具推荐" class="headerlink" title="Windows 实用工具推荐"></a>Windows 实用工具推荐</h3><table><thead><tr><th>分类</th><th>工具名称</th><th>功能描述</th><th>网址</th></tr></thead><tbody><tr><td>截图工具</td><td>Snipaste</td><td>支持截图后贴图，贴图后可继续截图</td><td><a href="https://zh.snipaste.com/download.html">https://zh.snipaste.com/download.html</a></td></tr><tr><td>文件管理</td><td>Everything</td><td>快速文件搜索工具，比 Windows 自带搜索更快</td><td><a href="https://www.voidtools.com/zh-cn/downloads/">https://www.voidtools.com/zh-cn/downloads/</a></td></tr><tr><td>系统维护</td><td>Geek Uninstaller</td><td>卸载软件工具，可彻底清理残留文件</td><td></td></tr><tr><td>桌面管理</td><td>DeskPins</td><td>桌面置顶工具，可置顶任何窗口</td><td></td></tr><tr><td>翻译工具</td><td>网易有道翻译</td><td>多语言翻译工具</td><td></td></tr><tr><td>网盘</td><td>百度网盘</td><td>文件存储与下载</td><td></td></tr><tr><td>聊天工具</td><td>CleanMyWechat</td><td>微信清理工具</td><td></td></tr></tbody></table><p>这些工具可以大大提高 Windows 系统的使用效率和体验。根据个人需求，选择合适的工具来优化您的工作流程。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;windows 实用工具推荐&lt;/p&gt;</summary>
    
    
    
    <category term="工具" scheme="https://hmmmmmya.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="工具" scheme="https://hmmmmmya.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>014_rss订阅</title>
    <link href="https://hmmmmmya.github.io/2024/10/12/014_rss%E8%AE%A2%E9%98%85%20copy/"/>
    <id>https://hmmmmmya.github.io/2024/10/12/014_rss%E8%AE%A2%E9%98%85%20copy/</id>
    <published>2024-10-12T02:09:14.000Z</published>
    <updated>2024-10-23T06:56:10.303Z</updated>
    
    <content type="html"><![CDATA[<p>rss 可以绕过算法推荐, 并且不遗漏地接收关注的动态, 重新成为订阅的主人</p><span id="more"></span><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ol><li><a href="https://www.inoreader.com/">Inoreader</a></li><li><a href="https://github.com/DIYgod/RSSHub">RssHub</a></li><li><a href="https://vercel.com/">Vercel</a></li></ol><h3 id="Inoreader"><a href="#Inoreader" class="headerlink" title="Inoreader"></a>Inoreader</h3><p>多端同步的 rss 阅读器, 亲测是最方便, 最容易同步, 加载源最容易成功的 rss 服务器, 页面也很高大上</p><p>包含了网页端、浏览器插件、app</p><h3 id="RssHub"><a href="#RssHub" class="headerlink" title="RssHub"></a>RssHub</h3><p>集成了最新的 rss 订阅源, 号称是让每一个网站都能做成 rss 订阅。当前绝大部分的网站都不主动公开 rss 订阅的方式了, RssHub 可以弥补这一点。</p><h3 id="Vercel"><a href="#Vercel" class="headerlink" title="Vercel"></a>Vercel</h3><p>很多网站对爬虫源进行了屏蔽, RssHub 也是一种网络爬虫的方式。将 RssHub 部署到自己的服务器, 有了新的域名, 便可以绕过这一层。Vercel 可以部署 RssHub 项目, 从而省去了购买服务器的花销。</p><p>Vercel 部署 RssHub 的教程可以参考: <a href="https://cloud.tencent.com/developer/article/2432561">手把手教你用 Vercel 免费部署 RSSHub</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;rss 可以绕过算法推荐, 并且不遗漏地接收关注的动态, 重新成为订阅的主人&lt;/p&gt;</summary>
    
    
    
    
    <category term="rss" scheme="https://hmmmmmya.github.io/tags/rss/"/>
    
  </entry>
  
  <entry>
    <title>013_内网穿透工具</title>
    <link href="https://hmmmmmya.github.io/2024/09/21/013_%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7/"/>
    <id>https://hmmmmmya.github.io/2024/09/21/013_%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7/</id>
    <published>2024-09-21T02:24:14.000Z</published>
    <updated>2024-10-29T04:05:24.333Z</updated>
    
    <content type="html"><![CDATA[<p>localtunnel 和 Cloudflare Tunnels 都是内网穿透工具，可以方便快捷的将本地 Localhost 暴露给全世界，无需修改 DNS 和防火墙设置</p><span id="more"></span><h2 id="localtunnel"><a href="#localtunnel" class="headerlink" title="localtunnel"></a>localtunnel</h2><p>localtunnel 是一款基于 node.js 的内网穿透工具，非常流行，可以方便快捷的将本地 Localhost 暴露给全世界，无需修改 DNS 和防火墙设置</p><p>github 地址: <code>https://github.com/localtunnel/localtunnel</code></p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><ol><li><p>安装: <code>npm install -g localtunnel</code></p></li><li><p>绑定端口: <code>lt --port 8000</code>, 绑定要访问内网服务的端口, 即本地访问该服务的端口</p></li><li><p>公网 ip:之后会生成一个 https 的公网 ip 地址, 通过该地址可以访问内网</p></li><li><p>访问密码: 本地访问该 ip, 点击查看密码, 即可看到。从外网访问 ip，并输出密码即可</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240921095753.png" alt="获取并输入密码"></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol><li>服务关闭后, 外网不可访问, 再次开启后会分配新的 ip</li></ol><h2 id="Cloudflare-Tunnels"><a href="#Cloudflare-Tunnels" class="headerlink" title="Cloudflare Tunnels"></a>Cloudflare Tunnels</h2><p>Tunnels：如果你想在外网访问家里的设备，又很难申请到公网 IP，就可以使用 Cloudflare Tunnels 实现的免费内网穿透服务，这种方案配置简单，无数量限制、无流量限制</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;localtunnel 和 Cloudflare Tunnels 都是内网穿透工具，可以方便快捷的将本地 Localhost 暴露给全世界，无需修改 DNS 和防火墙设置&lt;/p&gt;</summary>
    
    
    
    <category term="网络" scheme="https://hmmmmmya.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络" scheme="https://hmmmmmya.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>012_修改wsl环境下的docker container 端口</title>
    <link href="https://hmmmmmya.github.io/2024/09/19/012_%E4%BF%AE%E6%94%B9wsl%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84docker%20container%20%E7%AB%AF%E5%8F%A3/"/>
    <id>https://hmmmmmya.github.io/2024/09/19/012_%E4%BF%AE%E6%94%B9wsl%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84docker%20container%20%E7%AB%AF%E5%8F%A3/</id>
    <published>2024-09-19T01:52:12.000Z</published>
    <updated>2024-10-09T02:01:16.488Z</updated>
    
    <content type="html"><![CDATA[<p>wsl 下, 修改已创建容器的端口</p><p>工具: wsl, docker</p><span id="more"></span><p>路径: <code>\\wsl.localhost\docker-desktop-data\data\docker\containers\</code></p><p>容器文件名参考 <code>docker desktop</code> 的容器名下的序列号</p><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240919100031.png" alt="容器文件名"></p><p>修改文件: <code>hostconfig.json</code> 中的 <code>PortBindings</code> 的 <code>HostPort</code></p><p>重启 <code>docker desktop</code>, 注意需要退出后再开启, 不能仅 restart docker, 否则修改被抹除</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;wsl 下, 修改已创建容器的端口&lt;/p&gt;
&lt;p&gt;工具: wsl, docker&lt;/p&gt;</summary>
    
    
    
    <category term="docker" scheme="https://hmmmmmya.github.io/categories/docker/"/>
    
    
    <category term="docker" scheme="https://hmmmmmya.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>011_Linux配置依赖环境</title>
    <link href="https://hmmmmmya.github.io/2024/06/25/011_Linux%E9%85%8D%E7%BD%AE%E4%BE%9D%E8%B5%96%E7%8E%AF%E5%A2%83/"/>
    <id>https://hmmmmmya.github.io/2024/06/25/011_Linux%E9%85%8D%E7%BD%AE%E4%BE%9D%E8%B5%96%E7%8E%AF%E5%A2%83/</id>
    <published>2024-06-25T03:47:32.000Z</published>
    <updated>2024-10-29T08:40:39.540Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 依赖各种库，有的是项目文件夹 lib 里面已经有了，有的需要安装。本文介绍了在 WSL2 编译一个项目遇到的环境问题。在一天半的时间尝试下，终于解决了，记录下解决的过程。</p><span id="more"></span><h2 id="配置-Linux-依赖"><a href="#配置-Linux-依赖" class="headerlink" title="配置 Linux 依赖"></a>配置 Linux 依赖</h2><h3 id="查找库或依赖"><a href="#查找库或依赖" class="headerlink" title="查找库或依赖"></a>查找库或依赖</h3><ol><li><p><strong>使用包管理工具</strong>：</p><ul><li><p>在 Debian 或 Ubuntu 系统上，可以使用<code>apt-cache search</code>命令查找库。例如，要查找包含“mat”关键字的库：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-cache search mat</span><br></pre></td></tr></table></figure></li><li><p>在 CentOS 或 Red Hat 系统上，可以使用<code>yum search</code>命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum search mat</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>使用<code>ldconfig</code>命令</strong>：</p><ul><li><p><code>ldconfig</code>命令用于配置和管理共享库的符号链接和缓存。</p></li><li><p>可以使用<code>ldconfig -p | grep libmat</code>命令查看系统中已知的库：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldconfig -p | grep libmat</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>手动查找</strong>：</p><ul><li><p>使用<code>find</code>或<code>locate</code>命令在系统中搜索特定的库文件。例如，查找<code>libmat.so</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name libmat.so 2&gt;/dev/null</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate libmat</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="设置路径"><a href="#设置路径" class="headerlink" title="设置路径"></a>设置路径</h3><ol><li><p><strong>编译时设置库路径</strong>：</p><ul><li><p>使用<code>-L</code>选项指定库文件所在的目录。例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o your_program your_program.c -L/path/to/library -lmat</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>运行时设置库路径</strong>：</p><ul><li><p>设置<code>LD_LIBRARY_PATH</code>环境变量以包括库文件所在的目录。例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/path/to/library:<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure></li><li><p>将上述命令添加到<code>.bashrc</code>或<code>.bash_profile</code>文件中以使其在每次终端启动时生效：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export LD_LIBRARY_PATH=/path/to/library:$LD_LIBRARY_PATH&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>使用<code>ldconfig</code>配置共享库</strong>：</p><ul><li><p>将库文件路径添加到系统的共享库配置中。编辑或创建文件<code>/etc/ld.so.conf.d/custom_libs.conf</code>，添加库路径：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/path/to/library</span><br></pre></td></tr></table></figure></li><li><p>然后运行<code>ldconfig</code>命令更新缓存：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>假设你在<code>/home/user/libs</code>目录下有<code>libmat.so</code>和<code>libmx.so</code>库文件，并且需要在编译和运行时使用这些库。</p><ol><li><p><strong>编译时设置路径</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o my_program my_program.c -L/home/user/libs -lmat -lmx</span><br></pre></td></tr></table></figure></li><li><p><strong>运行时设置路径</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/home/user/libs:<span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line">./my_program</span><br></pre></td></tr></table></figure></li><li><p><strong>永久设置路径</strong>：<br>编辑<code>~/.bashrc</code>文件，添加以下行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/home/user/libs:<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure><p>然后运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure></li></ol><p>通过以上步骤，你可以查找和配置所需的库路径，确保程序能够正确链接和运行。</p><h2 id="安装的库版本不匹配"><a href="#安装的库版本不匹配" class="headerlink" title="安装的库版本不匹配"></a>安装的库版本不匹配</h2><p>根据您提供的信息，链接器无法找到<code>libjsoncpp.so.1</code>，而是找到了其他版本的<code>libjsoncpp.so</code>。这是因为系统上安装的<code>libjsoncpp</code>库版本不匹配。您可以通过以下步骤解决这个问题：</p><h3 id="解决方案-1：使用-rpath或-rpath-link"><a href="#解决方案-1：使用-rpath或-rpath-link" class="headerlink" title="解决方案 1：使用-rpath或-rpath-link"></a>解决方案 1：使用<code>-rpath</code>或<code>-rpath-link</code></h3><p>您可以在链接时使用<code>-rpath</code>或<code>-rpath-link</code>选项来指定库的路径。</p><p>假设您的库文件在<code>/usr/lib/x86_64-Linux-gnu</code>目录下，可以这样做：</p><ol><li><p>修改您的编译命令以包含<code>-Wl,-rpath,/usr/lib/x86_64-Linux-gnu</code></p></li><li><p>或者在 CMakeLists.txt 文件中设置链接器路径：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_INSTALL_RPATH <span class="string">&quot;/usr/lib/x86_64-Linux-gnu&quot;</span>)</span><br></pre></td></tr></table></figure></li></ol><h3 id="解决方案-2：创建符号链接"><a href="#解决方案-2：创建符号链接" class="headerlink" title="解决方案 2：创建符号链接"></a>解决方案 2：创建符号链接</h3><p>如果您需要的<code>libjsoncpp.so.1</code>确实存在于不同的位置，可以创建一个符号链接以便系统能够找到它。</p><ol><li><p>创建符号链接：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">ln</span> -s /usr/lib/x86_64-Linux-gnu/libjsoncpp.so.1.9.5 /usr/lib/x86_64-Linux-gnu/libjsoncpp.so.1</span><br></pre></td></tr></table></figure><p>如果使用<code>locate</code>定位不到新建的包, 更新 locate 数据库运行以下命令来更新 locate 数据库：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo updatedb</span><br></pre></td></tr></table></figure><p>然后再次运行 locate 命令</p></li></ol><h3 id="解决方案-3：安装正确版本的库"><a href="#解决方案-3：安装正确版本的库" class="headerlink" title="解决方案 3：安装正确版本的库"></a>解决方案 3：安装正确版本的库</h3><p>如果库的版本不匹配，您可以尝试安装正确版本的<code>libjsoncpp</code>。</p><ol><li><p>更新包管理器并安装正确的版本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install libjsoncpp1</span><br></pre></td></tr></table></figure></li></ol><h3 id="解决方案-4：指定库路径"><a href="#解决方案-4：指定库路径" class="headerlink" title="解决方案 4：指定库路径"></a>解决方案 4：指定库路径</h3><p>确保在链接器中指定正确的库路径。在编译时添加正确的路径：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o your_program your_program.cpp -L/usr/lib/x86_64-Linux-gnu -ljsoncpp</span><br></pre></td></tr></table></figure><h3 id="解决方案-5：环境变量"><a href="#解决方案-5：环境变量" class="headerlink" title="解决方案 5：环境变量"></a>解决方案 5：环境变量</h3><p>通过设置环境变量<code>LD_LIBRARY_PATH</code>来指定库的路径：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/usr/lib/x86_64-Linux-gnu:<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure><p>将上述命令添加到<code>.bashrc</code>文件中，以便每次启动终端时都生效：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export LD_LIBRARY_PATH=/usr/lib/x86_64-Linux-gnu:$LD_LIBRARY_PATH&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><p>通过这些步骤，您应该能够解决链接器找不到<code>libjsoncpp.so.1</code>的问题并成功编译您的程序。</p><h2 id="Q-A"><a href="#Q-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ol><li><p>shell 脚本文件没有可执行权限</p><p>matlab.sh 负责将 matlab 所用的库拷贝到&#x2F;build&#x2F;lib 文件夹, 这里发现 matlab.sh 并没有执行, 增加可执行权限后正常执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@DESKTOP-S5NII96:/home/guo/code/WT328/api<span class="comment"># ./matlab.sh</span></span><br><span class="line">bash: ./matlab.sh: Permission denied</span><br></pre></td></tr></table></figure></li><li><p>安装的软件版本不匹配</p><p>手动复制一份并重命名为所需软件(不行)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> /usr/lib/x86_64-Linux-gnu/libjsoncpp.so.1.9.5 /usr/lib/x86_64-Linux-gnu/libjsoncpp.so.1</span><br></pre></td></tr></table></figure><p>增加软链接(手动增加软连接无效)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@DESKTOP-S5NII96:/home/guo/code/WT328/source<span class="comment"># ls -l /usr/lib/x86_64-Linux-gnu/libjson*</span></span><br><span class="line">lrwxrwxrwx 1 root root     18 Aug 24  2023 /usr/lib/x86_64-Linux-gnu/libjson-c.so.5 -&gt; libjson-c.so.5.1.0</span><br><span class="line">-rw-r--r-- 1 root root  72080 Aug 24  2023 /usr/lib/x86_64-Linux-gnu/libjson-c.so.5.1.0</span><br><span class="line">lrwxrwxrwx 1 root root     16 Jan 30  2022 /usr/lib/x86_64-Linux-gnu/libjsoncpp.so -&gt; libjsoncpp.so.25</span><br><span class="line">-rwxrwxrwx 1 root root 215792 Jun 24 15:57 /usr/lib/x86_64-Linux-gnu/libjsoncpp.so.1</span><br><span class="line">-rw-r--r-- 1 root root 215792 Jan 30  2022 /usr/lib/x86_64-Linux-gnu/libjsoncpp.so.1.9.5</span><br><span class="line">lrwxrwxrwx 1 root root     19 Jan 30  2022 /usr/lib/x86_64-Linux-gnu/libjsoncpp.so.25 -&gt; libjsoncpp.so.1.9.5</span><br></pre></td></tr></table></figure><p>检查报错地方的依赖，能找到啊！！！怎么还报错呢</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@DESKTOP-S5NII96:/home/guo/code/WT328/source<span class="comment"># ldd /home/guo/code/WT328/source/../extlib/lib/libwt-calibration.so</span></span><br><span class="line"></span><br><span class="line">Linux-vdso.so.1 (0x00007fffab961000)</span><br><span class="line">libjsoncpp.so.1 =&gt; /lib/x86_64-Linux-gnu/libjsoncpp.so.1 (0x00007f466786a000)</span><br><span class="line">libstdc++.so.6 =&gt; /lib/x86_64-Linux-gnu/libstdc++.so.6 (0x00007f466763e000)</span><br><span class="line">libgcc_s.so.1 =&gt; /lib/x86_64-Linux-gnu/libgcc_s.so.1 (0x00007f466761e000)</span><br><span class="line">libpthread.so.0 =&gt; /lib/x86_64-Linux-gnu/libpthread.so.0 (0x00007f4667619000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-Linux-gnu/libc.so.6 (0x00007f46673f0000)</span><br><span class="line">libm.so.6 =&gt; /lib/x86_64-Linux-gnu/libm.so.6 (0x00007f4667309000)</span><br><span class="line">/lib64/ld-Linux-x86-64.so.2 (0x00007f4667922000)</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@DESKTOP-S5NII96:/home/guo/code/WT328/source<span class="comment"># locate libjsoncpp</span></span><br><span class="line"></span><br><span class="line">/usr/lib/x86_64-Linux-gnu/libjsoncpp.so</span><br><span class="line">/usr/lib/x86_64-Linux-gnu/libjsoncpp.so.1</span><br><span class="line">/usr/lib/x86_64-Linux-gnu/libjsoncpp.so.1.9.5</span><br><span class="line">/usr/lib/x86_64-Linux-gnu/libjsoncpp.so.25</span><br><span class="line">/usr/share/doc/libjsoncpp-dev</span><br><span class="line">/usr/share/doc/libjsoncpp25</span><br><span class="line">/usr/share/doc/libjsoncpp-dev/changelog.Debian.gz</span><br><span class="line">/usr/share/doc/libjsoncpp-dev/copyright</span><br><span class="line">/usr/share/doc/libjsoncpp25/README.Debian</span><br><span class="line">/usr/share/doc/libjsoncpp25/README.md</span><br><span class="line">/usr/share/doc/libjsoncpp25/changelog.Debian.gz</span><br><span class="line">/usr/share/doc/libjsoncpp25/copyright</span><br><span class="line">/var/lib/dpkg/info/libjsoncpp-dev:amd64.list</span><br><span class="line">/var/lib/dpkg/info/libjsoncpp-dev:amd64.md5sums</span><br><span class="line">/var/lib/dpkg/info/libjsoncpp25:amd64.list</span><br><span class="line">/var/lib/dpkg/info/libjsoncpp25:amd64.md5sums</span><br><span class="line">/var/lib/dpkg/info/libjsoncpp25:amd64.shlibs</span><br><span class="line">/var/lib/dpkg/info/libjsoncpp25:amd64.triggers</span><br><span class="line">root@DESKTOP-S5NII96:/home/guo/code/WT328/source<span class="comment"># ^C</span></span><br><span class="line">root@DESKTOP-S5NII96:/home/guo/code/WT328/source<span class="comment">#</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ld: /home/guo/code/WT328/source/../extlib/lib/libwt-calibration.so: undefined reference to  Json::Value::operator=(Json::Value)</span><br><span class="line">collect2: error: ld returned 1 <span class="built_in">exit</span> status</span><br><span class="line">make[1]: ***[/home/guo/code/WT328/source/base.mk:15: /home/guo/code/WT328/source/bin/WT-Manager] Error 1</span><br><span class="line">make[1]: Leaving directory /home/guo/code/WT328/source/manager</span><br><span class="line">make:*** [Makefile:85: all] Error 1</span><br></pre></td></tr></table></figure><p>可能是库有问题，这个版本的没有<code>Json::Value::operator=(Json::Value)</code></p><p>明天试试装 1.7.4 的版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 卸载1.9.5版本</span><br><span class="line">dpkg --list</span><br><span class="line"></span><br><span class="line">sudo apt-get remove software</span><br><span class="line"></span><br><span class="line">// qinghua下载指定版本deb包</span><br><span class="line">// libjsoncpp1_1.7.4-3_amd64.deb 和 libjsoncpp-dev_1.7.4-3_amd64.deb</span><br><span class="line"></span><br><span class="line">// 安装</span><br><span class="line">root@DESKTOP-S5NII96:/home/guo/code<span class="comment"># dpkg -i libjsoncpp1_1.7.4-3_amd64.deb</span></span><br><span class="line"></span><br><span class="line">Selecting previously unselected package libjsoncpp1:amd64.</span><br><span class="line">(Reading database ... 49184 files and directories currently installed.)</span><br><span class="line">Preparing to unpack libjsoncpp1_1.7.4-3_amd64.deb ...</span><br><span class="line">Unpacking libjsoncpp1:amd64 (1.7.4-3) ...</span><br><span class="line">Setting up libjsoncpp1:amd64 (1.7.4-3) ...</span><br><span class="line">Processing triggers <span class="keyword">for</span> libc-bin (2.35-0ubuntu3.4) ...</span><br><span class="line">root@DESKTOP-S5NII96:/home/guo/code<span class="comment"># dpkg -i libjsoncpp-dev_1.7.4-3_amd64.deb</span></span><br><span class="line">Selecting previously unselected package libjsoncpp-dev:amd64.</span><br><span class="line">(Reading database ... 49193 files and directories currently installed.)</span><br><span class="line">Preparing to unpack libjsoncpp-dev_1.7.4-3_amd64.deb ...</span><br><span class="line">Unpacking libjsoncpp-dev:amd64 (1.7.4-3) ...</span><br><span class="line">Setting up libjsoncpp-dev:amd64 (1.7.4-3) ...</span><br><span class="line"></span><br><span class="line">// 查看效果</span><br><span class="line">root@DESKTOP-S5NII96:/usr/lib/x86_64-Linux-gnu<span class="comment"># ls -l |grep libjsonc</span></span><br><span class="line"></span><br><span class="line">-rw-r--r--  1 root root   372584 Aug 23  2016 libjsoncpp.a</span><br><span class="line">lrwxrwxrwx  1 root root       15 Aug 23  2016 libjsoncpp.so -&gt; libjsoncpp.so.1</span><br><span class="line">lrwxrwxrwx  1 root root       19 Aug 23  2016 libjsoncpp.so.1 -&gt; libjsoncpp.so.1.7.4</span><br><span class="line">-rw-r--r--  1 root root   203464 Aug 23  2016 libjsoncpp.so.1.7.4</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 编译服务器里面的依赖</span><br><span class="line">root@wt400:/home/j00503/Code/WT328/source/bin<span class="comment"># ldd libgeneral.so</span></span><br><span class="line"></span><br><span class="line">Linux-vdso.so.1 (0x00007ffe8c14c000)</span><br><span class="line">libjsoncpp.so.1 =&gt; /lib/x86_64-Linux-gnu/libjsoncpp.so.1 (0x00007f7cfb129000)</span><br><span class="line">libwt-calibration.so =&gt; not found</span><br><span class="line">libwt-crypto.so =&gt; not found</span><br><span class="line">libft4222.so =&gt; not found</span><br><span class="line">libAlg3gppVsa.so =&gt; not found</span><br><span class="line">libAlg3gppVsg.so =&gt; not found</span><br><span class="line">libAlgVsa.so =&gt; not found</span><br><span class="line">libAlgVsaGle.so =&gt; not found</span><br><span class="line">libAlgVsaSlb.so =&gt; not found</span><br><span class="line">libAlgVsaWifi11az.so =&gt; not found</span><br><span class="line">libAlgVsg.so =&gt; not found</span><br><span class="line">libAlgVsgGle.so =&gt; not found</span><br><span class="line">libAlgVsgSlb.so =&gt; not found</span><br><span class="line">libAlgVsgWifi11ah.so =&gt; not found</span><br><span class="line">libWT-Debug-Mem.so =&gt; not found</span><br><span class="line">libsqlite3.so.0 =&gt; /lib/x86_64-Linux-gnu/libsqlite3.so.0 (0x00007f7cfaffc000)</span><br><span class="line">libstdc++.so.6 =&gt; /lib/x86_64-Linux-gnu/libstdc++.so.6 (0x00007f7cfae1a000)</span><br><span class="line">libm.so.6 =&gt; /lib/x86_64-Linux-gnu/libm.so.6 (0x00007f7cfaccb000)</span><br><span class="line">libgcc_s.so.1 =&gt; /lib/x86_64-Linux-gnu/libgcc_s.so.1 (0x00007f7cfacae000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-Linux-gnu/libc.so.6 (0x00007f7cfaabc000)</span><br><span class="line">/lib64/ld-Linux-x86-64.so.2 (0x00007f7cfb806000)</span><br><span class="line">libpthread.so.0 =&gt; /lib/x86_64-Linux-gnu/libpthread.so.0 (0x00007f7cfaa99000)</span><br><span class="line">libdl.so.2 =&gt; /lib/x86_64-Linux-gnu/libdl.so.2 (0x00007f7cfaa93000)</span><br><span class="line"></span><br><span class="line">root@wt400:/home/j00503/Code/WT328/source/bin<span class="comment"># ldd /lib/x86_64-Linux-gnu/libjsoncpp.so.1</span></span><br><span class="line">Linux-vdso.so.1 (0x00007ffce2ad4000)</span><br><span class="line">libstdc++.so.6 =&gt; /lib/x86_64-Linux-gnu/libstdc++.so.6 (0x00007f3dde1ae000)</span><br><span class="line">libm.so.6 =&gt; /lib/x86_64-Linux-gnu/libm.so.6 (0x00007f3dde05f000)</span><br><span class="line">libgcc_s.so.1 =&gt; /lib/x86_64-Linux-gnu/libgcc_s.so.1 (0x00007f3dde044000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-Linux-gnu/libc.so.6 (0x00007f3ddde52000)</span><br><span class="line">/lib64/ld-Linux-x86-64.so.2 (0x00007f3dde3db000)</span><br><span class="line"></span><br><span class="line">root@wt400:/home/j00503/Code/WT328/source/bin<span class="comment"># ls -l /lib/x86_64-Linux-gnu/libjsoncpp*</span></span><br><span class="line">-rw-r--r-- 1 root root 436438 3月  21  2020 /lib/x86_64-Linux-gnu/libjsoncpp.a</span><br><span class="line">lrwxrwxrwx 1 root root     15 3月  21  2020 /lib/x86_64-Linux-gnu/libjsoncpp.so -&gt; libjsoncpp.so.1</span><br><span class="line">lrwxrwxrwx 1 root root     19 3月  21  2020 /lib/x86_64-Linux-gnu/libjsoncpp.so.1 -&gt; libjsoncpp.so.1.7.4</span><br><span class="line">-rw-r--r-- 1 root root 215840 3月  21  2020 /lib/x86_64-Linux-gnu/libjsoncpp.so.1.7.4</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240625095531.png" alt="WSL2"></p><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240625095607.png" alt="编译服务器"></p><p>又发现了 cmake 失效</p><p>cmake 依赖于<code>libjsoncpp.so.25</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 手动安装 libjsoncpp25 并使用 1.9.5-3 版本</span><br><span class="line">root@DESKTOP-S5NII96:/home/guo<span class="comment"># dpkg -i ./libjsoncpp25_1.9.5-3_amd64.deb</span></span><br><span class="line">(Reading database ... 49218 files and directories currently installed.)</span><br><span class="line">Preparing to unpack .../libjsoncpp25_1.9.5-3_amd64.deb ...</span><br><span class="line">Unpacking libjsoncpp25:amd64 (1.9.5-3) over (1.9.5-3) ...</span><br><span class="line">Setting up libjsoncpp25:amd64 (1.9.5-3) ...</span><br><span class="line">Processing triggers <span class="keyword">for</span> libc-bin (2.35-0ubuntu3.8) ...</span><br><span class="line"></span><br><span class="line">// cmake正常使用</span><br><span class="line">root@DESKTOP-S5NII96:/home/guo<span class="comment"># cmake</span></span><br><span class="line">Usage</span><br><span class="line">cmake [options] &lt;path-to-source&gt;</span><br><span class="line">cmake [options] &lt;path-to-existing-build&gt;</span><br><span class="line">cmake [options] -S &lt;path-to-source&gt; -B &lt;path-to-build&gt;</span><br><span class="line">Specify a <span class="built_in">source</span> directory to (re-)generate a build system <span class="keyword">for</span> it <span class="keyword">in</span> the</span><br><span class="line">current working directory.  Specify an existing build directory to</span><br><span class="line">re-generate its build system.</span><br><span class="line">Run <span class="string">&#x27;cmake --help&#x27;</span> <span class="keyword">for</span> more information.</span><br><span class="line"></span><br><span class="line">// 先安装 libjsoncpp.so.1.9.5 和 libjsoncpp25，cmake正常使用</span><br><span class="line">// <span class="built_in">source</span>编译还是报找不到libjsoncpp.so.1的错误</span><br><span class="line">root@DESKTOP-S5NII96:/usr/lib/x86_64-Linux-gnu<span class="comment"># ls -l libjsoncpp*</span></span><br><span class="line">lrwxrwxrwx 1 root root     16 Jan 30  2022 libjsoncpp.so -&gt; libjsoncpp.so.25</span><br><span class="line">-rw-r--r-- 1 root root 215792 Jan 30  2022 libjsoncpp.so.1.9.5</span><br><span class="line">lrwxrwxrwx 1 root root     19 Jan 30  2022 libjsoncpp.so.25 -&gt; libjsoncpp.so.1.9.5</span><br></pre></td></tr></table></figure><p>再次安装<code>libjsoncpp1_1.7.4-3_amd64.deb</code>, 编译 source 正常</p><p>总结:</p><ol><li><p>需要安装 3 个软件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">libjsoncpp-dev // 当前最新是 1.9.5 版本</span><br><span class="line">libjsoncpp25_1.9.5-3_amd64.deb // 对应上面的最新版本</span><br><span class="line">libjsoncpp1_1.7.4-3_amd64.deb // 安装 libjsoncpp1，安装1.7.4版本，后面没有更新了</span><br><span class="line"></span><br><span class="line">// 当前效果</span><br><span class="line">root@DESKTOP-S5NII96:/usr/lib/x86_64-Linux-gnu<span class="comment"># ls -l libjsoncpp*</span></span><br><span class="line"></span><br><span class="line">lrwxrwxrwx 1 root root     16 Jan 30  2022 libjsoncpp.so -&gt; libjsoncpp.so.25</span><br><span class="line">lrwxrwxrwx 1 root root     19 Aug 23  2016 libjsoncpp.so.1 -&gt; libjsoncpp.so.1.7.4</span><br><span class="line">-rw-r--r-- 1 root root 203464 Aug 23  2016 libjsoncpp.so.1.7.4</span><br><span class="line">-rw-r--r-- 1 root root 215792 Jan 30  2022 libjsoncpp.so.1.9.5</span><br><span class="line">lrwxrwxrwx 1 root root     19 Jan 30  2022 libjsoncpp.so.25 -&gt; libjsoncpp.so.1.9.5</span><br></pre></td></tr></table></figure></li><li><p>手动设置软连接是无效的, 本因是需要装三个软件</p></li><li><p>手动安装软件包。在清华源里面查找对应包，下载下来，使用<code>dpkg -i a.deb</code>来安装 &#x2F;&#x2F; 假设 a 为软件包名</p></li><li><p>卸载软件包 <code>sudo apt remove a</code></p></li><li><p>定位软件包 <code>locate a</code></p></li><li><p>更新<code>locate</code>用 <code>updatedb</code></p></li></ol></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;Linux 依赖各种库，有的是项目文件夹 lib 里面已经有了，有的需要安装。本文介绍了在 WSL2 编译一个项目遇到的环境问题。在一天半的时间尝试下，终于解决了，记录下解决的过程。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://hmmmmmya.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://hmmmmmya.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>010_wsl2使用介绍</title>
    <link href="https://hmmmmmya.github.io/2024/06/21/010_wsl2%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/"/>
    <id>https://hmmmmmya.github.io/2024/06/21/010_wsl2%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/</id>
    <published>2024-06-21T07:06:34.000Z</published>
    <updated>2024-10-23T06:56:18.350Z</updated>
    
    <content type="html"><![CDATA[<p>适用于 Linux 的 Windows 子系统 (WSL) 是 Windows 的一项功能，可用于在 Windows 计算机上运行 Linux 环境，而无需单独的虚拟机或双引导。 WSL 旨在为希望同时使用 Windows 和 Linux 的开发人员提供无缝高效的体验。比 VMWare 或 Virtual Box 等虚拟机更轻量, 最主要是 Windows 原生支持。</p><span id="more"></span><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>开发人员可以在 Windows 计算机上同时访问 Windows 和 Linux 的强大功能。</p><ul><li><a href="https://learn.microsoft.com/zh-cn/windows/wsl/install#step-1---enable-the-windows-subsystem-for-linux">安装 WSL2</a></li></ul><h2 id="管理-Linux"><a href="#管理-Linux" class="headerlink" title="管理 Linux"></a>管理 Linux</h2><p><a href="https://learn.microsoft.com/zh-cn/windows/wsl/basic-commands">WSL 的基本命令</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">安装</span><br><span class="line">将目录更改为主页</span><br><span class="line">Help 命令</span><br><span class="line">以特定用户的身份运行</span><br><span class="line">更改发行版的默认用户</span><br><span class="line">标识 IP 地址</span><br><span class="line">导出分发版</span><br><span class="line">导入分发版</span><br><span class="line">就地导入发行版</span><br><span class="line">装载磁盘或设备</span><br><span class="line">卸载磁盘</span><br><span class="line">已弃用的 WSL 命令</span><br></pre></td></tr></table></figure><table><thead><tr><th>功能</th><th>命令</th></tr></thead><tbody><tr><td>列出可用(可在线安装)的 Linux 发行版</td><td><code>wsl --list --online</code></td></tr><tr><td>列出已安装的 Linux 发行版</td><td><code>wsl --list --verbose</code></td></tr><tr><td>安装指定 Linux 发行版</td><td><code>wsl --install &lt;Distribution Name&gt;</code></td></tr><tr><td>检查正在运行的 WSL 版本</td><td><code>wsl -l -v</code></td></tr><tr><td>将 WSL 版本设置为 1 或 2</td><td><code>wsl --set-version &lt;distribution name&gt; &lt;versionNumber&gt;</code></td></tr><tr><td>检查 WSL 版本</td><td><code>wsl --version</code></td></tr><tr><td>设置默认版本为 WSL 1 或 WSL 2</td><td><code>wsl --set-default-version &lt;Version#&gt;</code>，将 <code>Version#</code> 替换为 1 或 2</td></tr><tr><td>检查 WSL 状态</td><td><code>wsl --status</code></td></tr><tr><td>更新 WSL</td><td><code>wsl --update</code></td></tr><tr><td>设置默认 Linux 发行版</td><td><code>wsl --set-default &lt;Distribution Name&gt;</code></td></tr><tr><td>通过 PowerShell 或 CMD 运行特定的 Linux 发行版</td><td><code>wsl --distribution &lt;Distribution Name&gt; --user &lt;User Name&gt;</code></td></tr><tr><td>关闭</td><td><code>wsl --shutdown</code></td></tr><tr><td>Terminate</td><td><code>wsl --terminate &lt;Distribution Name&gt;</code></td></tr><tr><td>注销或卸载 Linux 发行版</td><td><code>wsl --unregister &lt;DistributionName&gt;</code></td></tr></tbody></table><h3 id="设置-Linux-用户名和密码"><a href="#设置-Linux-用户名和密码" class="headerlink" title="设置 Linux 用户名和密码"></a>设置 Linux 用户名和密码</h3><p>参考: <a href="https://learn.microsoft.com/zh-cn/windows/wsl/setup/environment#set-up-your-linux-username-and-password">https://learn.microsoft.com/zh-cn/windows/wsl/setup/environment#set-up-your-linux-username-and-password</a></p><h3 id="vscode-中连接-wsl"><a href="#vscode-中连接-wsl" class="headerlink" title="vscode 中连接 wsl"></a>vscode 中连接 wsl</h3><ul><li><p>安装 WSL 插件</p></li><li><p>安装 Remote - SSH 插件</p></li><li><p>F9 输入<code>WSL</code>, 选择<code>WSL:Connect to WSL using Distro</code></p><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240621145853.png" alt="命名面板输入WSL"></p></li><li><p>选择已安装的版本</p><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240621145749.png" alt="选择已安装的版本"></p></li><li><p>连接成功后, 打开 wsl 文件夹</p><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240621150828.png" alt="打开wsl文件夹"></p></li></ul><h2 id="Q-A"><a href="#Q-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ul><li><p>wsl: 检测到 localhost 代理配置，但未镜像到 WSL。NAT 模式下的 WSL 不支持 localhost 代理。</p><ul><li><code>wsl.exe --update</code></li></ul></li><li><p>进入不了 root</p><ul><li>使用 sudo su 进入 root, 账号密码都是创建时的, 即管理员账号</li></ul><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240621143616.png" alt="使用sudo su进入root"></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;适用于 Linux 的 Windows 子系统 (WSL) 是 Windows 的一项功能，可用于在 Windows 计算机上运行 Linux 环境，而无需单独的虚拟机或双引导。 WSL 旨在为希望同时使用 Windows 和 Linux 的开发人员提供无缝高效的体验。比 VMWare 或 Virtual Box 等虚拟机更轻量, 最主要是 Windows 原生支持。&lt;/p&gt;</summary>
    
    
    
    
    <category term="wsl2" scheme="https://hmmmmmya.github.io/tags/wsl2/"/>
    
  </entry>
  
  <entry>
    <title>009_使用vscode调试rust项目</title>
    <link href="https://hmmmmmya.github.io/2024/06/20/009_%E4%BD%BF%E7%94%A8vscode%E8%B0%83%E8%AF%95rust%E9%A1%B9%E7%9B%AE/"/>
    <id>https://hmmmmmya.github.io/2024/06/20/009_%E4%BD%BF%E7%94%A8vscode%E8%B0%83%E8%AF%95rust%E9%A1%B9%E7%9B%AE/</id>
    <published>2024-06-20T06:44:58.000Z</published>
    <updated>2024-11-07T04:17:04.257Z</updated>
    
    <content type="html"><![CDATA[<p>windows 下, 使用 vscode 调试 rust 项目</p><p>工具: vscode, rust-analyzer 插件, rust 环境</p><span id="more"></span><ul><li><p>安装 vscode 插件: rust-analyzer</p></li><li><p>创建 rust 项目</p><ul><li>终端输入命令 <code>cargo new ProjectName</code></li></ul></li><li><p>使用<code>cargo run</code>或者<code>cargo build</code>命令编译项目, 生成可执行文件<code>target/debug/ProjectName.exe</code></p><p>注意: 必须编译通过生成可执行文件后才能进行 debug</p></li><li><p>创建 launch.json 文件</p><ul><li><p>debug 点击创建 launch.json 文件<br><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240620164934.png" alt="创建 launch.json文件"></p></li><li><p>调试器选择 LLDB (rust 调试器为 LLDB)</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240620165044.png" alt="调试器选择LLDB"></p><ul><li>选择 yes, 调试环境会自动配置好</li></ul><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240620165225.png" alt="选择yes"></p></li><li><p>设置断点</p></li><li><p>F5 或者 运行-&gt;终端-&gt;开启调试</p></li><li><p>在左侧查看 debug 的变量和堆栈<br><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240620150545.png" alt="debug结果"></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;windows 下, 使用 vscode 调试 rust 项目&lt;/p&gt;
&lt;p&gt;工具: vscode, rust-analyzer 插件, rust 环境&lt;/p&gt;</summary>
    
    
    
    
    <category term="vscode" scheme="https://hmmmmmya.github.io/tags/vscode/"/>
    
    <category term="rust" scheme="https://hmmmmmya.github.io/tags/rust/"/>
    
    <category term="debug" scheme="https://hmmmmmya.github.io/tags/debug/"/>
    
  </entry>
  
  <entry>
    <title>008_vscode插件推荐</title>
    <link href="https://hmmmmmya.github.io/2024/06/17/008_vscode%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
    <id>https://hmmmmmya.github.io/2024/06/17/008_vscode%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/</id>
    <published>2024-06-17T02:14:14.000Z</published>
    <updated>2024-10-23T06:10:35.325Z</updated>
    
    <content type="html"><![CDATA[<p>自用 vscode 插件推荐</p><span id="more"></span><table><thead><tr><th>类别</th><th>插件名称</th><th>备注</th></tr></thead><tbody><tr><td><strong>开发语言与框架</strong></td><td></td><td></td></tr><tr><td>C&#x2F;C++</td><td>C&#x2F;C++ Extension Pack</td><td>包含 C&#x2F;C++, C&#x2F;C++ Themes, CMake, CMake Tools</td></tr><tr><td></td><td>C&#x2F;C++</td><td>C++ 编译、调试 (需提前安装编译器, 如 MinGW)</td></tr><tr><td></td><td>CMake</td><td>语法高亮, 代码补全</td></tr><tr><td></td><td>CMake Tools</td><td>CMake 工具包</td></tr><tr><td>Rust</td><td>rust-analyzer</td><td>Rust 语言支持</td></tr><tr><td><strong>开发工具</strong></td><td></td><td></td></tr><tr><td>路径智能提示</td><td>Path Intellisense</td><td>文件路径自动补全</td></tr><tr><td>文档编辑</td><td>Markdown All in One</td><td>Markdown 全功能支持</td></tr><tr><td>版本控制</td><td>GitLens</td><td>增强的 Git 功能，查看修改历史，Git blame</td></tr><tr><td></td><td>SVN</td><td>Subversion 版本控制支持</td></tr><tr><td></td><td>SVN Lens</td><td>SVN blame 功能</td></tr><tr><td>远程开发</td><td>Remote - SSH</td><td>通过 SSH 进行远程开发</td></tr><tr><td>容器化</td><td>Docker</td><td>Docker 容器支持</td></tr><tr><td>虚拟化</td><td>WSL</td><td>Windows Subsystem for Linux 支持</td></tr><tr><td>数据库</td><td>SQLite</td><td>SQLite 数据库支持</td></tr><tr><td><strong>效率工具</strong></td><td></td><td></td></tr><tr><td>项目管理</td><td>Project Manager</td><td>快速切换项目，支持标签</td></tr><tr><td>AI IDE</td><td>Cursor</td><td>智能 IDE</td></tr><tr><td>AI 代码补全</td><td>Codeium</td><td>智能代码补全</td></tr><tr><td>代码运行</td><td>Code Runner</td><td>快速运行各种语言的代码片段</td></tr><tr><td><strong>界面美化</strong></td><td></td><td></td></tr><tr><td>本地化</td><td>Chinese (Simplified)</td><td>简体中文界面</td></tr><tr><td>图标主题</td><td>Material Icon Theme</td><td>美化文件图标</td></tr><tr><td>颜色主题</td><td>Night Owl</td><td>深色主题</td></tr><tr><td></td><td>One Dark Pro</td><td>另一款流行的深色主题</td></tr><tr><td><strong>代码质量</strong></td><td></td><td></td></tr><tr><td>代码格式化</td><td>Prettier</td><td>支持多种语言的代码格式化</td></tr><tr><td></td><td>markdownlint</td><td>Markdown 语法检查和格式化</td></tr><tr><td><strong>可视化工具</strong></td><td></td><td></td></tr><tr><td>JSON 可视化</td><td>JSON Crack</td><td>JSON 数据可视化工具</td></tr><tr><td>思维导图</td><td>markmap</td><td>将 Markdown 转换为思维导图</td></tr><tr><td>PDF 阅读</td><td>vscode-pdf</td><td>PDF 阅读工具</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;自用 vscode 插件推荐&lt;/p&gt;</summary>
    
    
    
    <category term="工具" scheme="https://hmmmmmya.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="vscode" scheme="https://hmmmmmya.github.io/tags/vscode/"/>
    
  </entry>
  
</feed>
