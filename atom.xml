<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hymns</title>
  
  
  <link href="https://hmmmmmya.github.io/atom.xml" rel="self"/>
  
  <link href="https://hmmmmmya.github.io/"/>
  <updated>2024-11-15T02:23:38.999Z</updated>
  <id>https://hmmmmmya.github.io/</id>
  
  <author>
    <name>Hymns</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>042-使用cmake编译项目</title>
    <link href="https://hmmmmmya.github.io/2024/11/14/042-%E4%BD%BF%E7%94%A8cmake%E7%BC%96%E8%AF%91%E9%A1%B9%E7%9B%AE/"/>
    <id>https://hmmmmmya.github.io/2024/11/14/042-%E4%BD%BF%E7%94%A8cmake%E7%BC%96%E8%AF%91%E9%A1%B9%E7%9B%AE/</id>
    <published>2024-11-14T14:35:48.000Z</published>
    <updated>2024-11-15T02:23:38.999Z</updated>
    
    <content type="html"><![CDATA[<p>要编译一个已有 <code>CMakeLists.txt</code> 文件的 C++ 项目，你需要按照以下步骤进行操作：</p><span id="more"></span><h2 id="CMake-和-make"><a href="#CMake-和-make" class="headerlink" title="CMake 和 make"></a>CMake 和 make</h2><h3 id="1-确保安装了-CMake-和编译工具"><a href="#1-确保安装了-CMake-和编译工具" class="headerlink" title="1. 确保安装了 CMake 和编译工具"></a>1. <strong>确保安装了 CMake 和编译工具</strong></h3><p>首先，确保你的系统已经安装了 <code>CMake</code> 和适当的 C++ 编译工具。具体取决于你的操作系统，下面是一些常见的安装方式：</p><ul><li><strong>Windows</strong>：安装 <a href="https://cmake.org/download/">CMake</a> 和 <strong>Visual Studio</strong> 或 <strong>MinGW</strong>（如果你使用的是命令行编译器）。</li><li><strong>Linux&#x2F;Mac</strong>：可以通过包管理器安装 <code>CMake</code> 和 <code>g++</code> 编译器：<ul><li>Linux: <code>sudo apt-get install cmake g++</code></li><li>macOS: <code>brew install cmake</code>（如果使用 Homebrew）</li></ul></li></ul><h3 id="2-创建构建目录"><a href="#2-创建构建目录" class="headerlink" title="2. 创建构建目录"></a>2. <strong>创建构建目录</strong></h3><p>通常我们不直接在项目的根目录中进行构建，而是创建一个单独的构建目录，这样可以保持项目目录的整洁。</p><p>在项目的根目录下，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br></pre></td></tr></table></figure><h3 id="3-运行-CMake-配置项目"><a href="#3-运行-CMake-配置项目" class="headerlink" title="3. 运行 CMake 配置项目"></a>3. <strong>运行 CMake 配置项目</strong></h3><p>在构建目录中，使用 <code>cmake</code> 命令来配置项目。这会生成平台特定的构建文件（如 Makefile 或 Visual Studio 工程文件）。你可以指定源代码的目录（即 <code>CMakeLists.txt</code> 文件所在的目录）。</p><p>假设 <code>CMakeLists.txt</code> 文件在上级目录，你可以运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake ..</span><br></pre></td></tr></table></figure><p>这个命令会让 CMake 读取上级目录中的 <code>CMakeLists.txt</code> 文件，并生成相应的构建配置。如果没有问题，CMake 会自动检测到编译工具链并设置好相关构建配置。</p><p>如果你想指定编译器或者生成不同的构建文件格式（例如使用 Visual Studio 或者 Ninja），可以使用 <code>-G</code> 选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cmake .. -G <span class="string">&quot;Visual Studio 16 2019&quot;</span>  <span class="comment"># 如果你使用 Visual Studio 2019</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">cmake .. -G <span class="string">&quot;Ninja&quot;</span>  <span class="comment"># 如果你使用 Ninja 作为构建工具</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">cmake .. -G <span class="string">&quot;NMake Makefiles&quot;</span> <span class="comment"># 如果你使用 MinGW</span></span><br></pre></td></tr></table></figure><h3 id="4-编译项目"><a href="#4-编译项目" class="headerlink" title="4. 编译项目"></a>4. <strong>编译项目</strong></h3><p>一旦 CMake 配置完毕，接下来可以进行编译：</p><ul><li><p><strong>如果你使用的是 Makefile</strong>，可以运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure></li><li><p><strong>如果你使用的是 Visual Studio</strong>，你可以直接打开生成的 <code>.sln</code> 文件并通过 Visual Studio 编译，或者在命令行中使用 <code>MSBuild</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msbuild your_project.sln</span><br></pre></td></tr></table></figure></li><li><p><strong>如果你使用的是 Ninja</strong>，可以直接运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ninja</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-运行程序"><a href="#5-运行程序" class="headerlink" title="5. 运行程序"></a>5. <strong>运行程序</strong></h3><p>编译成功后，生成的可执行文件会放在构建目录中（具体位置取决于 <code>CMakeLists.txt</code> 配置）。你可以运行它：</p><ul><li><p>在 Linux&#x2F;macOS 中，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./your_executable</span><br></pre></td></tr></table></figure></li><li><p>在 Windows 中，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">your_executable.exe</span><br></pre></td></tr></table></figure></li></ul><h3 id="6-清理构建文件（可选）"><a href="#6-清理构建文件（可选）" class="headerlink" title="6. 清理构建文件（可选）"></a>6. <strong>清理构建文件（可选）</strong></h3><p>如果你想清理构建目录并重新构建，可以使用以下命令：</p><ul><li><p>使用 <strong>CMake</strong> 清理构建文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --build . --target clean</span><br></pre></td></tr></table></figure></li><li><p>或者直接删除构建目录中的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf *</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="总结步骤"><a href="#总结步骤" class="headerlink" title="总结步骤"></a>总结步骤</h3><ol><li>创建 <code>build</code> 目录：<code>mkdir build &amp;&amp; cd build</code></li><li>运行 <code>cmake ..</code> 配置项目。</li><li>使用 <code>make</code>、<code>ninja</code> 或者 Visual Studio 等工具进行编译。</li><li>执行生成的可执行文件。</li></ol><h2 id="配置默认编译器"><a href="#配置默认编译器" class="headerlink" title="配置默认编译器"></a>配置默认编译器</h2><p>直接使用 <code>cmake</code> 命令可能失败，因为 <code>cmake</code> 找不到默认的编译器，这时需要指定编译器。</p><p>可以在运行 CMake 时指定 MinGW 编译器。使用 <code>-D</code> 参数设置 <code>CMAKE_C_COMPILER</code> 和 <code>CMAKE_CXX_COMPILER</code> 变量。假设你的 MinGW 安装在默认位置，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake .. -G <span class="string">&quot;MinGW Makefiles&quot;</span> -D CMAKE_C_COMPILER=gcc -D CMAKE_CXX_COMPILER=g++</span><br></pre></td></tr></table></figure><p>如果需要指定 MinGW 的完整路径（推荐这样做以避免路径问题），可以这样写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake .. -G <span class="string">&quot;MinGW Makefiles&quot;</span> -D CMAKE_C_COMPILER=<span class="string">&quot;D:/mingw64/bin/gcc.exe&quot;</span> -D CMAKE_CXX_COMPILER=<span class="string">&quot;D:/mingw64/bin/g++.exe&quot;</span></span><br></pre></td></tr></table></figure><p>请根据你的 MinGW 实际安装路径调整上述路径。</p><p>你也可以通过设置环境变量 <code>CC</code> 和 <code>CXX</code> 来指定编译器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> CC=D:/mingw64/bin/gcc.exe</span><br><span class="line"><span class="built_in">set</span> CXX=D:/mingw64/bin/g++.exe</span><br><span class="line">cmake .. -G <span class="string">&quot;MinGW Makefiles&quot;</span></span><br></pre></td></tr></table></figure><p>如果你想让这个设置持久化，可以将编译器路径添加到你的 CMake 设置文件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;cmake.sourceDirectory&quot;: &quot;D:/Code/GitHub/hello-algo/codes/cpp&quot;,</span><br><span class="line">    &quot;cmake.cmakePath&quot;: &quot;D:/software/CMake/cmake-3.31.0-windows-x86_64/bin/cmake.exe&quot;,</span><br><span class="line">    &quot;cmake.configureSettings&quot;: &#123;</span><br><span class="line">        &quot;CMAKE_C_COMPILER&quot;: &quot;D:/mingw64/bin/gcc.exe&quot;,</span><br><span class="line">        &quot;CMAKE_CXX_COMPILER&quot;: &quot;D:/mingw64/bin/g++.exe&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;cmake.generator&quot;: &quot;MinGW Makefiles&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记得替换为你系统中 MinGW 的实际安装路径。</p><p>如果指定生成器失败，可以用 <code>cmake .. -G &quot;NMake Makefiles&quot;</code> 来指定生成器。</p><p>在项目根目录下运行 <code>cmake --list-generators</code> 可以查看所有可用的生成器。能看到默认的生成器。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;要编译一个已有 &lt;code&gt;CMakeLists.txt&lt;/code&gt; 文件的 C++ 项目，你需要按照以下步骤进行操作：&lt;/p&gt;</summary>
    
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/categories/c/"/>
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>042-network-learning</title>
    <link href="https://hmmmmmya.github.io/2024/11/14/042-network-learning/"/>
    <id>https://hmmmmmya.github.io/2024/11/14/042-network-learning/</id>
    <published>2024-11-14T10:00:39.000Z</published>
    <updated>2024-11-14T10:03:17.457Z</updated>
    
    <content type="html"><![CDATA[<p>计算机网络学习资料</p><span id="more"></span><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h3><ul><li>《网络是怎样连接的》</li></ul><h3 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h3><ul><li><a href="https://xiaolincoding.com/network/">图解网络 - 小林 coding</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;计算机网络学习资料&lt;/p&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="https://hmmmmmya.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://hmmmmmya.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>041-c++ learning</title>
    <link href="https://hmmmmmya.github.io/2024/11/14/041-cpp-learning/"/>
    <id>https://hmmmmmya.github.io/2024/11/14/041-cpp-learning/</id>
    <published>2024-11-14T02:12:00.000Z</published>
    <updated>2024-11-14T09:59:43.261Z</updated>
    
    <content type="html"><![CDATA[<p>自用 c++ 学习资料</p><span id="more"></span><h2 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h2><h3 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h3><ul><li>《c++ primer 5th》</li><li>《Effective c++》</li><li>《Effective modern c++》<a href="https://cntransgroup.github.io/EffectiveModernCppChinese/">中文</a></li><li>《Google c++ style guide》<a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/contents.html">中文</a>, <a href="https://google.github.io/styleguide/cppguide.html">英文</a></li><li>《C++ Concurrency in Action》</li></ul><h3 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h3><ul><li>cppreference <a href="https://zh.cppreference.com/w/">中文</a>, <a href="https://en.cppreference.com/w/">英文</a></li></ul><h3 id="c-库"><a href="#c-库" class="headerlink" title="c++库"></a>c++库</h3><ul><li><a href="https://www.boost.org/">boost</a></li><li><a href="https://github.com/fffaraz/awesome-cpp">awesome-cpp</a></li><li><a href="https://zh.cppreference.com/w/cpp/links/libs">开源 C++ 库- cppreference</a></li></ul><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ul><li><a href="https://c.runoob.com/compile/12/">c++在线编译</a></li><li><a href="https://www.geeksforgeeks.org/cpp-data-types/?ref=shm">c++数据类型</a></li><li><a href="https://blog.csdn.net/rongrongyaofeiqi/article/details/52442169">c++数据类型转换</a></li></ul><h3 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h3><ul><li><a href="https://roadmap.sh/cpp">c++学习路线</a></li><li><a href="https://light-city.github.io/stories_things/">c++那些事-光城</a></li><li><a href="https://changkun.de/modern-cpp/zh-cn/00-preface/">现代 c++教程-changkun</a></li><li><a href="https://www.cnblogs.com/cate/cpp/">博客园-c++</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;自用 c++ 学习资料&lt;/p&gt;</summary>
    
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/categories/c/"/>
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>040-c++递归互斥锁、lock_guard和unique_lock</title>
    <link href="https://hmmmmmya.github.io/2024/11/14/040-cpp%E9%80%92%E5%BD%92%E4%BA%92%E6%96%A5%E9%94%81%E3%80%81lock_guard%E5%92%8Cunique_lock/"/>
    <id>https://hmmmmmya.github.io/2024/11/14/040-cpp%E9%80%92%E5%BD%92%E4%BA%92%E6%96%A5%E9%94%81%E3%80%81lock_guard%E5%92%8Cunique_lock/</id>
    <published>2024-11-14T01:54:49.000Z</published>
    <updated>2024-11-14T02:58:24.126Z</updated>
    
    <content type="html"><![CDATA[<p><code>std::recursive_mutex</code>可以在同一个线程中嵌套使用。介绍了 lock_guard 和 mutex 是什么关系, lock_guard 和 unique_lock 的区别</p><span id="more"></span><p><code>std::recursive_mutex</code>是一种递归锁，它允许同一线程多次加锁而不会导致死锁。在使用普通的<code>std::mutex</code>时，同一线程如果多次尝试加锁会造成死锁；而<code>std::recursive_mutex</code>则不会。它会跟踪当前线程的加锁次数，并在解锁时，只有当解锁次数与加锁次数相同时，锁才会真正释放。</p><p>以下是一个简单的示例，展示了如何在同一线程中嵌套使用<code>std::recursive_mutex</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::recursive_mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recursiveFunction</span><span class="params">(<span class="type">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    mtx.<span class="built_in">lock</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Lock acquired, count = &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归调用</span></span><br><span class="line">    <span class="built_in">recursiveFunction</span>(count - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Releasing lock, count = &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">    mtx.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(recursiveFunction, <span class="number">3</span>)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>recursiveFunction</code>函数递归调用自己，每次调用时都会加锁，直到<code>count</code>为零时停止递归。由于使用了<code>std::recursive_mutex</code>，即使在同一线程中多次加锁，也不会发生死锁。</p><h2 id="lock-guard-和-mutex-是什么关系"><a href="#lock-guard-和-mutex-是什么关系" class="headerlink" title="lock_guard 和 mutex 是什么关系"></a>lock_guard 和 mutex 是什么关系</h2><p><code>std::lock_guard</code>和<code>std::mutex</code>在 C++中是协同使用的关系。<code>std::lock_guard</code>是一个用于管理<code>std::mutex</code>（或其他锁类型）的 RAII（资源获取即初始化）机制，旨在更安全和便捷地管理互斥锁的加锁和解锁过程。</p><h3 id="它们的关系"><a href="#它们的关系" class="headerlink" title="它们的关系"></a>它们的关系</h3><ul><li>**<code>std::mutex</code>**：是 C++标准库中提供的基础互斥锁类，用于在线程间保护共享资源，避免数据竞争。通过显式调用<code>lock()</code>和<code>unlock()</code>函数加锁和解锁来控制对共享资源的访问。</li><li>**<code>std::lock_guard</code>**：是一个模板类，用于自动管理<code>std::mutex</code>的加锁和解锁操作。它在构造时自动对传入的<code>std::mutex</code>对象加锁，在销毁时（通常是作用域结束时）自动解锁。因此，使用<code>std::lock_guard</code>可以确保即使在异常或函数提前返回时，锁也会被正确释放。</li></ul><h3 id="为什么要使用std-lock-guard"><a href="#为什么要使用std-lock-guard" class="headerlink" title="为什么要使用std::lock_guard"></a>为什么要使用<code>std::lock_guard</code></h3><p>如果手动控制<code>std::mutex</code>的加锁和解锁，很容易因漏掉解锁操作或在出现异常时未释放锁而导致死锁。<code>std::lock_guard</code>简化了这一过程，通过在其生命周期内自动加锁和解锁，确保了代码的安全性和可读性。</p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safeFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 lock_guard 管理 mtx 的加锁和解锁</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 临界区，安全访问共享资源</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; is in critical section.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock 离开作用域后会自动解锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(safeFunction)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(safeFunction)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，<code>std::lock_guard</code>构造时会锁住<code>mtx</code>，在<code>safeFunction</code>结束时，<code>std::lock_guard</code>自动析构并解锁，从而避免了手动解锁可能带来的问题。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>std::lock_guard</code>和<code>std::mutex</code>是合作关系：<code>std::mutex</code>是互斥锁的实现，而<code>std::lock_guard</code>是用于自动管理<code>std::mutex</code>加锁和解锁的工具。</p><h2 id="lock-guard-和-unique-lock-的区别"><a href="#lock-guard-和-unique-lock-的区别" class="headerlink" title="lock_guard 和 unique_lock 的区别"></a>lock_guard 和 unique_lock 的区别</h2><p><code>std::lock_guard</code>和<code>std::unique_lock</code>都是用于管理<code>std::mutex</code>的 RAII 类型锁，但它们在功能和灵活性上有一些区别。下面详细解释它们的差异。</p><h3 id="1-锁的灵活性"><a href="#1-锁的灵活性" class="headerlink" title="1. 锁的灵活性"></a>1. 锁的灵活性</h3><ul><li>**<code>std::lock_guard</code>**：<code>std::lock_guard</code>非常简单，在构造时自动加锁，并且在析构时自动解锁。它没有提供其他任何锁管理的接口，因此无法手动解锁后再重新加锁。</li><li>**<code>std::unique_lock</code>**：<code>std::unique_lock</code>更灵活，它提供了加锁、解锁和重锁的功能。你可以在代码中选择性地调用<code>lock()</code>和<code>unlock()</code>来手动控制锁的状态。</li></ul><h3 id="2-延迟加锁和解锁"><a href="#2-延迟加锁和解锁" class="headerlink" title="2. 延迟加锁和解锁"></a>2. 延迟加锁和解锁</h3><ul><li>**<code>std::lock_guard</code>**：在创建<code>std::lock_guard</code>对象时必须立即加锁，没有延迟加锁的选项。</li><li>**<code>std::unique_lock</code>**：支持延迟加锁，即可以在构造时不加锁，稍后在需要的时候调用<code>lock()</code>来加锁。可以使用<code>std::defer_lock</code>标志来延迟加锁。</li></ul><h3 id="3-条件变量的支持"><a href="#3-条件变量的支持" class="headerlink" title="3. 条件变量的支持"></a>3. 条件变量的支持</h3><ul><li>**<code>std::lock_guard</code>**：无法与<code>std::condition_variable</code>配合使用，因为条件变量要求能够临时解锁和重新加锁，这需要更灵活的锁管理。</li><li>**<code>std::unique_lock</code>**：可以与<code>std::condition_variable</code>配合使用。在等待条件变量时，<code>std::unique_lock</code>可以暂时解锁互斥锁，以便其他线程获得锁，并在条件满足后重新加锁。</li></ul><h3 id="4-开销"><a href="#4-开销" class="headerlink" title="4. 开销"></a>4. 开销</h3><ul><li>**<code>std::lock_guard</code>**：轻量级，没有额外的状态信息，因为它一旦加锁，就保持锁定状态直到销毁。适用于简单的场景。</li><li>**<code>std::unique_lock</code>**：稍微重一些，因为它维护了更多的状态信息（比如是否锁定、是否延迟等），以便支持更多功能。适用于需要灵活控制锁的场景。</li></ul><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><h4 id="std-lock-guard"><a href="#std-lock-guard" class="headerlink" title="std::lock_guard"></a><code>std::lock_guard</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safeFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;  <span class="comment">// 构造时自动加锁</span></span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; is in critical section.\n&quot;</span>;</span><br><span class="line">&#125;  <span class="comment">// 作用域结束，自动解锁</span></span><br></pre></td></tr></table></figure><h4 id="std-unique-lock"><a href="#std-unique-lock" class="headerlink" title="std::unique_lock"></a><code>std::unique_lock</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">waitingThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;  <span class="comment">// 构造时加锁</span></span><br><span class="line">    cv.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> ready; &#125;);     <span class="comment">// 等待条件变量，期间自动解锁并在条件满足后重新加锁</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; finished waiting.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setReady</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    ready = <span class="literal">true</span>;</span><br><span class="line">    cv.<span class="built_in">notify_all</span>();  <span class="comment">// 唤醒所有等待的线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(waitingThread)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(setReady)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>特性</th><th><code>std::lock_guard</code></th><th><code>std::unique_lock</code></th></tr></thead><tbody><tr><td>加锁和解锁灵活性</td><td>固定，只能自动加锁和解锁</td><td>灵活，支持手动加锁、解锁、重新加锁</td></tr><tr><td>延迟加锁</td><td>不支持</td><td>支持，通过<code>std::defer_lock</code>指定</td></tr><tr><td>条件变量支持</td><td>不支持</td><td>支持</td></tr><tr><td>适用场景</td><td>简单加锁、解锁</td><td>需要更多锁管理控制的复杂场景</td></tr><tr><td>性能</td><td>更轻量级</td><td>较重，带有额外状态信息</td></tr></tbody></table><p>总体而言，如果只需要简单的加锁解锁，<code>std::lock_guard</code>更合适；如果需要更灵活的锁控制（如条件变量、延迟加锁等），则<code>std::unique_lock</code>是更好的选择。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;std::recursive_mutex&lt;/code&gt;可以在同一个线程中嵌套使用。介绍了 lock_guard 和 mutex 是什么关系, lock_guard 和 unique_lock 的区别&lt;/p&gt;</summary>
    
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/categories/c/"/>
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/tags/c/"/>
    
    <category term="c++11" scheme="https://hmmmmmya.github.io/tags/c-11/"/>
    
  </entry>
  
  <entry>
    <title>039-linux-mv</title>
    <link href="https://hmmmmmya.github.io/2024/11/13/039-linux-mv/"/>
    <id>https://hmmmmmya.github.io/2024/11/13/039-linux-mv/</id>
    <published>2024-11-13T09:14:08.000Z</published>
    <updated>2024-11-13T09:46:16.680Z</updated>
    
    <content type="html"><![CDATA[<p>以下是关于 <code>mv</code> 命令在不同情况下的用法：</p><span id="more"></span><h2 id="将文件夹移动到另一个文件夹内"><a href="#将文件夹移动到另一个文件夹内" class="headerlink" title="将文件夹移动到另一个文件夹内"></a>将文件夹移动到另一个文件夹内</h2><h3 id="1-将文件夹移动到另一个文件夹内"><a href="#1-将文件夹移动到另一个文件夹内" class="headerlink" title="1. 将文件夹移动到另一个文件夹内"></a>1. <strong>将文件夹移动到另一个文件夹内</strong></h3><p>假设要将文件夹 <code>source_folder</code> 移动到 <code>destination_folder</code> 内：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> source_folder destination_folder/</span><br></pre></td></tr></table></figure><p>这样会将 <code>source_folder</code> 以及其中的所有内容移动到 <code>destination_folder</code> 中。</p><h3 id="2-将文件夹内的文件移动到另一个文件夹"><a href="#2-将文件夹内的文件移动到另一个文件夹" class="headerlink" title="2. 将文件夹内的文件移动到另一个文件夹"></a>2. <strong>将文件夹内的文件移动到另一个文件夹</strong></h3><p>假设要将 <code>source_folder</code> 中的所有文件移动到 <code>destination_folder</code> 中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> source_folder/* destination_folder/</span><br></pre></td></tr></table></figure><p>这会将 <code>source_folder</code> 中的所有文件（不包含子文件夹）移动到 <code>destination_folder</code>。</p><p>如果希望同时移动子文件夹，可以使用 <code>-r</code> 选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> source_folder/* destination_folder/ -r</span><br></pre></td></tr></table></figure><h3 id="3-将文件夹覆盖为另一个文件夹"><a href="#3-将文件夹覆盖为另一个文件夹" class="headerlink" title="3. 将文件夹覆盖为另一个文件夹"></a>3. <strong>将文件夹覆盖为另一个文件夹</strong></h3><p>如果 <code>destination_folder</code> 已经存在，并希望用 <code>source_folder</code> 的内容替换它，可以先删除 <code>destination_folder</code>，再移动 <code>source_folder</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf destination_folder</span><br><span class="line"><span class="built_in">mv</span> source_folder destination_folder</span><br></pre></td></tr></table></figure><p>这会先删除 <code>destination_folder</code> 及其内容，然后将 <code>source_folder</code> 重命名为 <code>destination_folder</code>。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>使用 <code>rm -rf</code> 删除时要小心，这将永久删除指定文件夹及其中的所有内容。</li></ul><h2 id="T-和-t-选项"><a href="#T-和-t-选项" class="headerlink" title="-T 和 -t 选项"></a>-T 和 -t 选项</h2><p><strong>cp</strong>、<strong>install</strong>、<strong>ln</strong> 和 <strong>mv</strong> 命令在处理目录或符号链接到目录时：</p><ul><li><strong>避免特殊处理</strong>：使用 <strong>-T</strong> 选项可以避免将最后一个操作数作为目录处理，即视为普通文件，防止在共享区域操作时出现竞态条件。不是目录，而是普通文件。</li><li><strong>目标目录</strong>：使用 <strong>–target-directory (-t)</strong> 选项可以确保最后一个操作数被视为目录，并在与 <strong>xargs</strong> 配合使用时更加方便。是目录。</li><li><strong>处理特殊字符</strong>：结合 <strong>GNU find</strong> 和 <strong>GNU xargs</strong> 可以处理文件名中包含空格或特殊字符的情况。</li></ul><p>这些选项和方法可以帮助用户更灵活地控制文件操作，避免常见的错误和问题。</p><p>如果不加 <code>-T</code> 或 <code>-t</code> 选项，如果最后一个操作数是目录，并且该目录存在，<code>mv</code> 命令会将源目录移动到目标目录下。不加的话，操作效果无法保证。</p><h2 id="mv-原理"><a href="#mv-原理" class="headerlink" title="mv 原理"></a>mv 原理</h2><ul><li>如果移动一个文件，<code>mv</code> 命令会直接重命名目标文件。</li><li>如果移动一个目录，<code>mv</code> 命令会将源目录拷贝到目标目录下，并删除源目录。</li><li>如果拷贝失败，<code>mv</code> 命令会清理拷贝的文件，并保留源目录。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;以下是关于 &lt;code&gt;mv&lt;/code&gt; 命令在不同情况下的用法：&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://hmmmmmya.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://hmmmmmya.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>038-网关</title>
    <link href="https://hmmmmmya.github.io/2024/11/13/038-%E7%BD%91%E5%85%B3/"/>
    <id>https://hmmmmmya.github.io/2024/11/13/038-%E7%BD%91%E5%85%B3/</id>
    <published>2024-11-13T06:20:46.000Z</published>
    <updated>2024-11-13T06:21:50.158Z</updated>
    
    <content type="html"><![CDATA[<p>网关（Gateway）是一种网络设备，充当不同网络之间的接口或连接点，允许不同网络协议或架构之间的通信。它不仅仅是数据的转发者，还可以进行数据的转换、协议的转换、地址转换和流量控制。以下是关于网关的一些详细信息：</p><span id="more"></span><h2 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h2><h3 id="1-基本功能"><a href="#1-基本功能" class="headerlink" title="1. 基本功能"></a>1. <strong>基本功能</strong></h3><p>网关在两个不同的网络之间进行数据包的传输和转换。它可以处理不同协议之间的通信，确保数据能够在异构网络之间正确传递。</p><h3 id="2-协议转换"><a href="#2-协议转换" class="headerlink" title="2. 协议转换"></a>2. <strong>协议转换</strong></h3><p>网关可以在两个不同协议的网络之间转换数据。例如，从 IPv4 网络到 IPv6 网络，或从 TCP&#x2F;IP 网络到另一种非 IP 网络。</p><h3 id="3-应用场景"><a href="#3-应用场景" class="headerlink" title="3. 应用场景"></a>3. <strong>应用场景</strong></h3><p>网关常用于以下场景：</p><ul><li><strong>企业网络</strong>：在企业内部网与外部互联网之间充当连接点。</li><li><strong>家庭网络</strong>：在家庭局域网和互联网之间进行数据传输，通常路由器具有网关功能。</li><li><strong>物联网</strong>：在物联网设备和传统网络之间进行数据转换。</li></ul><h3 id="4-类型"><a href="#4-类型" class="headerlink" title="4. 类型"></a>4. <strong>类型</strong></h3><p>根据功能和应用场景的不同，网关可以分为几种类型：</p><ul><li><strong>路由器网关</strong>：用于家庭和企业网络的路由器，经常充当网关，连接内部网络和互联网。</li><li><strong>防火墙网关</strong>：在网络安全方面起作用，控制内部网络和外部网络之间的通信，防止非法访问。</li><li><strong>应用层网关（ALG）</strong>：处理应用层协议，如 HTTP、FTP 等，进行协议转换和数据过滤。</li></ul><h3 id="5-示例"><a href="#5-示例" class="headerlink" title="5. 示例"></a>5. <strong>示例</strong></h3><ul><li><strong>家庭网络网关</strong>：家庭路由器通常作为网关，连接家庭的所有设备到互联网。</li><li><strong>企业网关</strong>：企业使用网关连接内部网络到外部网络（如互联网），并可能使用 VPN 网关来实现安全的远程连接。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>网关在现代网络架构中起到关键作用，通过连接和转换不同网络和协议，实现数据的无缝传输。</p><h2 id="网关和路由器"><a href="#网关和路由器" class="headerlink" title="网关和路由器"></a>网关和路由器</h2><p>网关和路由器虽然都有连接网络的功能，但它们在用途和功能上有显著的区别。以下是两者的主要区别：</p><h3 id="网关-1"><a href="#网关-1" class="headerlink" title="网关"></a>网关</h3><ol><li><strong>基本功能</strong>：网关主要用于连接不同类型的网络，负责协议转换和数据传输。它可以在不同协议或架构的网络之间进行通信，例如从 IPv4 到 IPv6 网络，或从 TCP&#x2F;IP 网络到非 IP 网络。</li><li><strong>使用场景</strong>：常用于连接两种不同类型的网络，如企业内部网和外部互联网、物联网设备与传统网络等。</li><li><strong>协议转换</strong>：网关能够转换不同协议的数据格式，使得不同网络中的设备能够互相通信。</li><li><strong>复杂度</strong>：通常比路由器更复杂，因为它需要处理不同协议之间的转换。</li></ol><h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><ol><li><strong>基本功能</strong>：路由器主要用于在同类型的网络之间传输数据包。它根据网络层协议（如 IP 协议）进行数据包的路由选择，确保数据包能够到达正确的目的地。</li><li><strong>使用场景</strong>：常用于连接同一类型的网络，如家庭网络和互联网之间的连接，或者企业内部不同子网之间的连接。</li><li><strong>数据转发</strong>：路由器主要关注数据包的转发和路由选择，使用路由表来决定数据包的最佳传输路径。</li><li><strong>简单性</strong>：相对网关，路由器的功能更简单，因为它主要处理相同协议的数据包转发。</li></ol><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>网关</strong>：主要用于连接不同类型的网络，执行协议转换和数据传输。</li><li><strong>路由器</strong>：主要用于在同类型的网络之间转发数据包，负责路由选择和数据包传输。</li></ul><p>通过这两种设备，网络能够实现灵活、高效的通信。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;网关（Gateway）是一种网络设备，充当不同网络之间的接口或连接点，允许不同网络协议或架构之间的通信。它不仅仅是数据的转发者，还可以进行数据的转换、协议的转换、地址转换和流量控制。以下是关于网关的一些详细信息：&lt;/p&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="https://hmmmmmya.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://hmmmmmya.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>037-服务器的分类</title>
    <link href="https://hmmmmmya.github.io/2024/11/13/037-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB/"/>
    <id>https://hmmmmmya.github.io/2024/11/13/037-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB/</id>
    <published>2024-11-13T03:56:05.000Z</published>
    <updated>2024-11-13T03:56:41.780Z</updated>
    
    <content type="html"><![CDATA[<p>服务器可以根据用途、性能、架构等多种因素进行分类。下面是一些常见的服务器分类：</p><span id="more"></span><h3 id="1-按用途分类"><a href="#1-按用途分类" class="headerlink" title="1. 按用途分类"></a>1. 按用途分类</h3><ul><li><strong>Web 服务器</strong>: 用于存储和提供网页内容，例如 Apache HTTP Server、Nginx 等。Web 服务器就是这一类。</li><li><strong>应用服务器</strong>: 用于运行应用程序的服务器，例如 JBoss、WebLogic 等。</li><li><strong>数据库服务器</strong>: 用于存储和管理数据库的服务器，例如 MySQL、Oracle Database 等。</li><li><strong>文件服务器</strong>: 用于存储和管理文件的服务器，例如 Windows File Server、Samba 等。</li><li><strong>邮件服务器</strong>: 用于处理电子邮件的服务器，例如 Microsoft Exchange、Postfix 等。</li><li><strong>DNS 服务器</strong>: 用于域名解析的服务器，例如 BIND、Microsoft DNS 等。</li><li><strong>FTP 服务器</strong>: 用于文件传输的服务器，例如 vsftpd、FileZilla Server 等。</li></ul><h3 id="2-按性能分类"><a href="#2-按性能分类" class="headerlink" title="2. 按性能分类"></a>2. 按性能分类</h3><ul><li><strong>高性能服务器</strong>: 配置高端硬件，处理大量并发请求和数据处理任务，例如大数据处理服务器、企业级数据库服务器等。</li><li><strong>中性能服务器</strong>: 用于中小型企业，处理一般业务需求的服务器。</li><li><strong>低性能服务器</strong>: 用于处理简单任务或开发测试环境的服务器。</li></ul><h3 id="3-按架构分类"><a href="#3-按架构分类" class="headerlink" title="3. 按架构分类"></a>3. 按架构分类</h3><ul><li><strong>单机服务器</strong>: 单独一台计算机作为服务器，适用于小型企业或个人。</li><li><strong>集群服务器</strong>: 由多台服务器组成的集群，协同工作以提高性能和可靠性，常见于大企业和数据中心。</li><li><strong>虚拟服务器</strong>: 通过虚拟化技术在一台物理服务器上运行多个虚拟服务器，例如 VMware、Hyper-V 等。</li></ul><h3 id="4-按操作系统分类"><a href="#4-按操作系统分类" class="headerlink" title="4. 按操作系统分类"></a>4. 按操作系统分类</h3><ul><li><strong>Windows 服务器</strong>: 运行 Windows Server 操作系统。</li><li><strong>Linux 服务器</strong>: 运行各种 Linux 发行版，例如 Ubuntu Server、CentOS 等。</li><li><strong>Unix 服务器</strong>: 运行 Unix 或类似 Unix 的操作系统，例如 FreeBSD、AIX 等。</li></ul><h3 id="5-按部署方式分类"><a href="#5-按部署方式分类" class="headerlink" title="5. 按部署方式分类"></a>5. 按部署方式分类</h3><ul><li><strong>本地服务器</strong>: 部署在本地数据中心或机房的服务器。</li><li><strong>云服务器</strong>: 部署在云计算平台上的服务器，例如 AWS EC2、Microsoft Azure、Google Cloud 等。</li></ul><p>Web 服务器属于按用途分类中的一种，专门用于存储和提供网页内容。它们处理客户端（如浏览器）的 HTTP 请求，返回网页资源，如 HTML 文件、图像、样式表和脚本。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;服务器可以根据用途、性能、架构等多种因素进行分类。下面是一些常见的服务器分类：&lt;/p&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="https://hmmmmmya.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://hmmmmmya.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>036-std::funtion</title>
    <link href="https://hmmmmmya.github.io/2024/11/13/036-std-funtion/"/>
    <id>https://hmmmmmya.github.io/2024/11/13/036-std-funtion/</id>
    <published>2024-11-13T02:18:39.000Z</published>
    <updated>2024-11-13T02:18:59.099Z</updated>
    
    <content type="html"><![CDATA[<p><code>std::function</code> 是 C++11 引入的标准库组件，用于包装任意可调用的目标。它可以用来存储、传递和调用各种类型的可调用对象，如普通函数、Lambda 表达式、函数对象和成员函数等。下面是 <code>std::function</code> 的一些关键特点和用法：</p><span id="more"></span><h3 id="1-定义和用法"><a href="#1-定义和用法" class="headerlink" title="1. 定义和用法"></a>1. <strong>定义和用法</strong></h3><p><code>std::function</code> 模板类定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::function&lt;返回类型(参数类型...)&gt; 函数对象;</span><br></pre></td></tr></table></figure><p>例如，定义一个接收两个 <code>int</code> 参数并返回 <code>int</code> 的函数对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func;</span><br></pre></td></tr></table></figure><h3 id="2-存储和调用不同类型的可调用对象"><a href="#2-存储和调用不同类型的可调用对象" class="headerlink" title="2. 存储和调用不同类型的可调用对象"></a>2. <strong>存储和调用不同类型的可调用对象</strong></h3><h4 id="存储普通函数"><a href="#存储普通函数" class="headerlink" title="存储普通函数"></a>存储普通函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func = add;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">func</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; std::endl; <span class="comment">// 输出 3</span></span><br></pre></td></tr></table></figure><h4 id="存储-Lambda-表达式"><a href="#存储-Lambda-表达式" class="headerlink" title="存储 Lambda 表达式"></a>存储 Lambda 表达式</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> lambda = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line">std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func = lambda;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">func</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; std::endl; <span class="comment">// 输出 3</span></span><br></pre></td></tr></table></figure><h4 id="存储函数对象"><a href="#存储函数对象" class="headerlink" title="存储函数对象"></a>存储函数对象</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Adder</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Adder adder;</span><br><span class="line">std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func = adder;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">func</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; std::endl; <span class="comment">// 输出 3</span></span><br></pre></td></tr></table></figure><h4 id="存储成员函数"><a href="#存储成员函数" class="headerlink" title="存储成员函数"></a>存储成员函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Calculator calc;</span><br><span class="line">std::function&lt;<span class="type">int</span>(<span class="type">const</span> Calculator&amp;, <span class="type">int</span>, <span class="type">int</span>)&gt; func = &amp;Calculator::add;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">func</span>(calc, <span class="number">1</span>, <span class="number">2</span>) &lt;&lt; std::endl; <span class="comment">// 输出 3</span></span><br></pre></td></tr></table></figure><h3 id="3-捕获上下文"><a href="#3-捕获上下文" class="headerlink" title="3. 捕获上下文"></a>3. <strong>捕获上下文</strong></h3><p><code>std::function</code> 允许存储并捕获上下文信息，例如 Lambda 表达式中捕获的外部变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> lambda = [x](<span class="type">int</span> a) &#123; <span class="keyword">return</span> a + x; &#125;;</span><br><span class="line">std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; func = lambda;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">func</span>(<span class="number">5</span>) &lt;&lt; std::endl; <span class="comment">// 输出 15</span></span><br></pre></td></tr></table></figure><h3 id="4-可变性和赋值"><a href="#4-可变性和赋值" class="headerlink" title="4. 可变性和赋值"></a>4. <strong>可变性和赋值</strong></h3><p><code>std::function</code> 可以动态改变所包装的可调用目标：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">func</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; std::endl; <span class="comment">// 输出 3</span></span><br><span class="line"></span><br><span class="line">func = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a * b; &#125;;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">func</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; std::endl; <span class="comment">// 输出 2</span></span><br></pre></td></tr></table></figure><p>通过 <code>std::function</code>，C++ 提供了一种灵活的方法来处理各种可调用对象，使得编写高效、易读和维护的代码变得更加容易。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;std::function&lt;/code&gt; 是 C++11 引入的标准库组件，用于包装任意可调用的目标。它可以用来存储、传递和调用各种类型的可调用对象，如普通函数、Lambda 表达式、函数对象和成员函数等。下面是 &lt;code&gt;std::function&lt;/code&gt; 的一些关键特点和用法：&lt;/p&gt;</summary>
    
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/categories/c/"/>
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>035-lamda表达式的应用场景</title>
    <link href="https://hmmmmmya.github.io/2024/11/13/035-lamda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>https://hmmmmmya.github.io/2024/11/13/035-lamda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</id>
    <published>2024-11-13T01:32:51.000Z</published>
    <updated>2024-11-13T01:37:40.518Z</updated>
    
    <content type="html"><![CDATA[<p>Lambda 表达式在 C++中是一个非常强大且灵活的特性，它在以下场景中会特别有用：</p><span id="more"></span><h3 id="1-简化代码"><a href="#1-简化代码" class="headerlink" title="1. 简化代码"></a>1. <strong>简化代码</strong></h3><p>Lambda 表达式可以用来简化代码，特别是在需要定义短小的匿名函数时。例如，在 STL 算法（如<code>std::sort</code>）中传递自定义比较函数时：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-捕获局部变量"><a href="#2-捕获局部变量" class="headerlink" title="2. 捕获局部变量"></a>2. <strong>捕获局部变量</strong></h3><p>Lambda 表达式可以捕获所在作用域内的变量，这样可以在回调或处理函数中使用这些变量，而不需要传递额外的参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> add_x = [x](<span class="type">int</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">add_x</span>(<span class="number">5</span>) &lt;&lt; std::endl; <span class="comment">// 输出 15</span></span><br></pre></td></tr></table></figure><h3 id="3-并行和异步编程"><a href="#3-并行和异步编程" class="headerlink" title="3. 并行和异步编程"></a>3. <strong>并行和异步编程</strong></h3><p>在并行和异步编程中，lambda 表达式经常用于定义线程函数或异步任务的工作内容。例如，使用<code>std::async</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> future = std::<span class="built_in">async</span>([]() &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;等待结果...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;结果是: &quot;</span> &lt;&lt; future.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-事件处理"><a href="#4-事件处理" class="headerlink" title="4. 事件处理"></a>4. <strong>事件处理</strong></h3><p>在 GUI 编程或事件驱动的编程模型中，lambda 表达式可用于定义事件处理器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">button_click</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; callback)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">callback</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">button_click</span>([]() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;按钮被点击了！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-通用编程"><a href="#5-通用编程" class="headerlink" title="5. 通用编程"></a>5. <strong>通用编程</strong></h3><p>在模板编程中，lambda 表达式可以用作函数对象，特别是在需要高效、内联的函数对象时：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Func&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(Func func)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">func</span>(<span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">apply</span>([](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x * x; &#125;); <span class="comment">// 输出25</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用 lambda 表达式，你可以写出更简洁、高效和易于维护的代码。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Lambda 表达式在 C++中是一个非常强大且灵活的特性，它在以下场景中会特别有用：&lt;/p&gt;</summary>
    
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/categories/c/"/>
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>034_端口号的划分</title>
    <link href="https://hmmmmmya.github.io/2024/11/12/034-%E7%AB%AF%E5%8F%A3%E5%8F%B7%E7%9A%84%E5%88%92%E5%88%86/"/>
    <id>https://hmmmmmya.github.io/2024/11/12/034-%E7%AB%AF%E5%8F%A3%E5%8F%B7%E7%9A%84%E5%88%92%E5%88%86/</id>
    <published>2024-11-12T09:48:08.000Z</published>
    <updated>2024-11-13T06:33:51.296Z</updated>
    
    <content type="html"><![CDATA[<p>端口号用于标识网络通信中的特定进程或服务，它们在 TCP&#x2F;IP 协议中有特定的划分方式。以下是端口号的分类：</p><span id="more"></span><h2 id="端口号的划分"><a href="#端口号的划分" class="headerlink" title="端口号的划分"></a>端口号的划分</h2><h3 id="1-系统端口-0-1023"><a href="#1-系统端口-0-1023" class="headerlink" title="1. 系统端口 (0-1023)"></a>1. <strong>系统端口 (0-1023)</strong></h3><p>这些端口号是为系统进程或特权服务预留的，只有超级用户或具有特定权限的用户才能使用。例如：</p><ul><li><strong>80</strong>: HTTP</li><li><strong>443</strong>: HTTPS</li><li><strong>21</strong>: FTP</li><li><strong>22</strong>: SSH</li></ul><h3 id="2-用户端口-1024-49151"><a href="#2-用户端口-1024-49151" class="headerlink" title="2. 用户端口 (1024-49151)"></a>2. <strong>用户端口 (1024-49151)</strong></h3><p>这些端口号通常用于用户进程或应用程序，普通用户可以使用。例如：</p><ul><li><strong>3306</strong>: MySQL 数据库</li><li><strong>8080</strong>: 通常用于 HTTP 备用端口或 Web 服务器端口</li></ul><h3 id="3-动态-私有端口-49152-65535"><a href="#3-动态-私有端口-49152-65535" class="headerlink" title="3. 动态&#x2F;私有端口 (49152-65535)"></a>3. <strong>动态&#x2F;私有端口 (49152-65535)</strong></h3><p>这些端口号通常用于临时或短期的通信，客户端在连接到服务器时常用这些端口。例如，临时打开的 Web 浏览器与服务器进行通信时使用的端口。</p><h3 id="详细示例"><a href="#详细示例" class="headerlink" title="详细示例"></a>详细示例</h3><p>假设你在浏览器中访问一个网站，过程可能涉及多个端口号：</p><ol><li><strong>浏览器</strong>（客户端）使用一个动态端口（如 49152）发送请求。</li><li><strong>服务器</strong>接收到请求，监听端口 80（HTTP）或 443（HTTPS）。</li><li><strong>服务器</strong>响应，发送数据回到客户端的动态端口（49152）。</li></ol><p>通过这种端口号划分，可以有效地管理和分配网络资源，确保不同服务和应用程序之间的通信不会互相干扰。</p><h2 id="访问一个网站要写上对应的端口号吗-什么时候用端口号"><a href="#访问一个网站要写上对应的端口号吗-什么时候用端口号" class="headerlink" title="访问一个网站要写上对应的端口号吗,什么时候用端口号"></a>访问一个网站要写上对应的端口号吗,什么时候用端口号</h2><p>通常情况下，当你访问一个网站时，不需要手动写上端口号，因为浏览器会默认使用标准端口号：</p><ul><li>HTTP 默认使用端口号 80</li><li>HTTPS 默认使用端口号 443</li></ul><h3 id="什么时候需要写上端口号"><a href="#什么时候需要写上端口号" class="headerlink" title="什么时候需要写上端口号"></a>什么时候需要写上端口号</h3><ol><li><p><strong>非标准端口</strong>：如果网站使用了非标准端口，你需要在域名后面手动指定端口号。例如，访问使用端口号 8080 的 HTTP 服务，地址可能是 <code>http://www.example.com:8080</code>。</p></li><li><p><strong>调试和开发</strong>：在进行网站开发和调试时，常常使用非标准端口来运行开发服务器或测试环境。例如，许多开发框架默认使用端口号 3000 或 5000。</p></li><li><p><strong>多服务部署</strong>：同一服务器上可能运行多个服务，每个服务使用不同的端口号。例如，一个服务器上运行多个 Web 应用程序，分别监听端口 8080 和 9090。</p></li><li><p><strong>特殊服务</strong>：某些特定服务可能会使用自定义端口，如数据库管理界面、管理控制台等。例如，Jenkins 通常在端口 8080 上运行，phpMyAdmin 可能在端口 8000 上运行。</p></li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ul><li>标准 HTTP 访问：<code>http://www.example.com</code></li><li>标准 HTTPS 访问：<code>https://www.example.com</code></li><li>非标准端口的 HTTP 访问：<code>http://www.example.com:8080</code></li><li>非标准端口的 HTTPS 访问：<code>https://www.example.com:8443</code></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>大多数情况下，你不需要手动写上端口号，但在使用非标准端口或访问特定服务时，需要明确指定端口号。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;端口号用于标识网络通信中的特定进程或服务，它们在 TCP&amp;#x2F;IP 协议中有特定的划分方式。以下是端口号的分类：&lt;/p&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="https://hmmmmmya.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://hmmmmmya.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>033_集线器_交换机_路由器_光猫的区别</title>
    <link href="https://hmmmmmya.github.io/2024/11/12/033-%E9%9B%86%E7%BA%BF%E5%99%A8-%E4%BA%A4%E6%8D%A2%E6%9C%BA-%E8%B7%AF%E7%94%B1%E5%99%A8-%E5%85%89%E7%8C%AB%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://hmmmmmya.github.io/2024/11/12/033-%E9%9B%86%E7%BA%BF%E5%99%A8-%E4%BA%A4%E6%8D%A2%E6%9C%BA-%E8%B7%AF%E7%94%B1%E5%99%A8-%E5%85%89%E7%8C%AB%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2024-11-12T08:50:14.000Z</published>
    <updated>2024-11-12T08:55:36.447Z</updated>
    
    <content type="html"><![CDATA[<h3 id="路由器和交换机的主要区别"><a href="#路由器和交换机的主要区别" class="headerlink" title="路由器和交换机的主要区别"></a>路由器和交换机的主要区别</h3><h4 id="路由器和交换机不同点在于，它的每个网口下，都有一个-MAC-地址和-IP-地址"><a href="#路由器和交换机不同点在于，它的每个网口下，都有一个-MAC-地址和-IP-地址" class="headerlink" title="路由器和交换机不同点在于，它的每个网口下，都有一个 MAC 地址和 IP 地址"></a>路由器和交换机不同点在于，它的每个网口下，都有一个 MAC 地址和 IP 地址</h4><p>前面提到交换机，是不具备 MAC 地址的，而 MAC 报头是需要填上目的 MAC 地址的。因此交换机从来都不是数据的目的地，它只简单转发数据帧到目的地。</p><p>但路由器，是有 MAC 地址的，因此 MAC 报头就可以写上，下一站目的地就是 xx 路由。</p><p>到了路由器后，路由器可以再次组装下一站的目的 MAC 地址是再下一个路由，通过这一点，让数据在路由和路由之间传输。</p><p>而同时因为交换机不具有 MAC 地址，因此也不会校验收到的数据帧的 MAC 地址是不是自己的，全部收下做转发。而路由器则会校验数据帧的 MAC 报头里的目的 MAC 地址是不是自己，是的话才会收入内存缓冲区，否则丢弃。</p><h4 id="找不到转发目的地时的处理方式有区别"><a href="#找不到转发目的地时的处理方式有区别" class="headerlink" title="找不到转发目的地时的处理方式有区别"></a>找不到转发目的地时的处理方式有区别</h4><p>如果在路由表中无法找到匹配的记录，路由器会丢弃这个包，并通过 ICMP 消息告知发送方。</p><p>而交换机在 MAC 地址表里找不到转发端口时会选择广播。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>两台电脑可以通过一根网线直接连接，进行通信。</li><li>机器一多，可以把网线都接到集线器（物理层）上，但是集线器会不管三七二十一进行广播。</li><li>不想广播，可以用（二层）交换机（数据链路层），又叫多端口网桥，它比较聪明，会自我学习生产 MAC 地址表，知道消息发到哪，那就不需要广播啦</li><li>互联网电脑这么多，交换机 MAC 地址表总不能全放下吧。改用路由器（网络层），也叫三层交换机，通过网段的方式定位要把消息转发到哪，就不需要像交换机那样苦哈哈一条一条记录 MAC 地址啦。</li><li>路由器和光猫之间是好搭档，光猫负责把光纤里的光信号转换成电信号给路由器。</li><li>现在一般情况下，家里已经不用集线器和交换机了，大部分路由器也支持交换机的功能。所以可以看到，家里的台式机电脑一般就连到一个路由器，再连个光猫就够能快乐上网了。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20241112165453.png" alt="网络连接模型"></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h3 id=&quot;路由器和交换机的主要区别&quot;&gt;&lt;a href=&quot;#路由器和交换机的主要区别&quot; class=&quot;headerlink&quot; title=&quot;路由器和交换机的主要区别&quot;&gt;&lt;/a&gt;路由器和交换机的主要区别&lt;/h3&gt;&lt;h4</summary>
        
      
    
    
    
    <category term="计算机网络" scheme="https://hmmmmmya.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://hmmmmmya.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>032_报文结构</title>
    <link href="https://hmmmmmya.github.io/2024/11/11/032_%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84/"/>
    <id>https://hmmmmmya.github.io/2024/11/11/032_%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84/</id>
    <published>2024-11-11T06:21:59.000Z</published>
    <updated>2024-11-11T06:25:18.903Z</updated>
    
    <content type="html"><![CDATA[<p>报文结构是指在网络通信中，各种协议规定的数据报文格式。不同的协议会有不同的报文结构，以下是一些常见协议的报文结构示例。</p><span id="more"></span><h3 id="TCP-报文结构"><a href="#TCP-报文结构" class="headerlink" title="TCP 报文结构"></a>TCP 报文结构</h3><p>TCP（传输控制协议）的报文结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+-------------------------+</span><br><span class="line">|       源端口号 (16位)      |</span><br><span class="line">+-------------------------+</span><br><span class="line">|       目的端口号 (16位)     |</span><br><span class="line">+-------------------------+</span><br><span class="line">|       序列号 (32位)       |</span><br><span class="line">+-------------------------+</span><br><span class="line">|      确认号 (32位)       |</span><br><span class="line">+-------------------------+</span><br><span class="line">| 数据偏移 (4位) | 保留 (6位) | 标志位 (6位) | 窗口大小 (16位) |</span><br><span class="line">+-------------------------+</span><br><span class="line">|     校验和 (16位)        |</span><br><span class="line">+-------------------------+</span><br><span class="line">|     紧急指针 (16位)       |</span><br><span class="line">+-------------------------+</span><br><span class="line">|     选项 (可变)          |</span><br><span class="line">+-------------------------+</span><br><span class="line">|     数据 (可变)          |</span><br><span class="line">+-------------------------+</span><br></pre></td></tr></table></figure><h3 id="UDP-报文结构"><a href="#UDP-报文结构" class="headerlink" title="UDP 报文结构"></a>UDP 报文结构</h3><p>UDP（用户数据报协议）的报文结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+-------------------------+</span><br><span class="line">|       源端口号 (16位)      |</span><br><span class="line">+-------------------------+</span><br><span class="line">|       目的端口号 (16位)     |</span><br><span class="line">+-------------------------+</span><br><span class="line">|    数据报长度 (16位)     |</span><br><span class="line">+-------------------------+</span><br><span class="line">|       校验和 (16位)       |</span><br><span class="line">+-------------------------+</span><br><span class="line">|     数据 (可变)          |</span><br><span class="line">+-------------------------+</span><br></pre></td></tr></table></figure><h3 id="IP-报文结构"><a href="#IP-报文结构" class="headerlink" title="IP 报文结构"></a>IP 报文结构</h3><p>IP（Internet 协议）分为 IPv4 和 IPv6，这里以 IPv4 为例，其报文结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">+-------------------------------+</span><br><span class="line">| 版本 (4位) | 头部长度 (4位)   |</span><br><span class="line">+-------------------------------+</span><br><span class="line">|      服务类型 (8位)             |</span><br><span class="line">+-------------------------------+</span><br><span class="line">|     总长度 (16位)              |</span><br><span class="line">+-------------------------------+</span><br><span class="line">|     标识 (16位)               |</span><br><span class="line">+-------------------------------+</span><br><span class="line">| 标志 (3位) | 片偏移 (13位)     |</span><br><span class="line">+-------------------------------+</span><br><span class="line">|   生存时间 (8位) | 协议 (8位)   |</span><br><span class="line">+-------------------------------+</span><br><span class="line">|     头部校验和 (16位)          |</span><br><span class="line">+-------------------------------+</span><br><span class="line">|     源IP地址 (32位)            |</span><br><span class="line">+-------------------------------+</span><br><span class="line">|     目的IP地址 (32位)          |</span><br><span class="line">+-------------------------------+</span><br><span class="line">|     选项 (可变)                |</span><br><span class="line">+-------------------------------+</span><br><span class="line">|     数据 (可变)                |</span><br><span class="line">+-------------------------------+</span><br></pre></td></tr></table></figure><h3 id="HTTP-报文结构"><a href="#HTTP-报文结构" class="headerlink" title="HTTP 报文结构"></a>HTTP 报文结构</h3><p>HTTP（超文本传输协议）的报文结构相对简单，以 HTTP 请求报文为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">请求行:</span><br><span class="line">  GET /path/resource HTTP/1.1</span><br><span class="line"></span><br><span class="line">头部字段:</span><br><span class="line">  Host: www.example.com</span><br><span class="line">  User-Agent: Mozilla/5.0</span><br><span class="line">  Accept: text/html,application/xhtml+xml</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">空行:</span><br><span class="line">  （头部与数据之间的空行）</span><br><span class="line"></span><br><span class="line">数据:</span><br><span class="line">  （可选，例如POST请求的数据）</span><br></pre></td></tr></table></figure><p>这些报文结构定义了通信双方在传输数据时必须遵循的格式，确保数据可以正确地传输和解析。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;报文结构是指在网络通信中，各种协议规定的数据报文格式。不同的协议会有不同的报文结构，以下是一些常见协议的报文结构示例。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="https://hmmmmmya.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://hmmmmmya.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>031_DHCP的作用</title>
    <link href="https://hmmmmmya.github.io/2024/11/11/031_DHCP%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <id>https://hmmmmmya.github.io/2024/11/11/031_DHCP%E7%9A%84%E4%BD%9C%E7%94%A8/</id>
    <published>2024-11-11T04:28:02.000Z</published>
    <updated>2024-11-11T04:28:30.870Z</updated>
    
    <content type="html"><![CDATA[<p>DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）的主要作用是自动为网络上的设备分配 IP 地址和其他网络配置参数，如子网掩码、默认网关和 DNS 服务器。这样做的目的是简化网络管理，避免手动配置每个设备的网络设置。以下是 DHCP 的具体功能：</p><span id="more"></span><h3 id="1-自动-IP-地址分配"><a href="#1-自动-IP-地址分配" class="headerlink" title="1. 自动 IP 地址分配"></a>1. <strong>自动 IP 地址分配</strong></h3><p>DHCP 服务器可以自动分配 IP 地址给网络中的设备，确保每个设备都有一个唯一的 IP 地址，避免地址冲突。</p><h3 id="2-分配网络配置参数"><a href="#2-分配网络配置参数" class="headerlink" title="2. 分配网络配置参数"></a>2. <strong>分配网络配置参数</strong></h3><p>除了 IP 地址，DHCP 还可以分配其他重要的网络配置参数，如：</p><ul><li><strong>子网掩码</strong>：用于确定 IP 地址的网络部分和主机部分。</li><li><strong>默认网关</strong>：用于设备访问外部网络。</li><li><strong>DNS 服务器</strong>：用于将域名解析为 IP 地址。</li></ul><h3 id="3-IP-地址租赁"><a href="#3-IP-地址租赁" class="headerlink" title="3. IP 地址租赁"></a>3. <strong>IP 地址租赁</strong></h3><p>DHCP 使用租赁机制，IP 地址的分配是有时间限制的。设备在租期到期之前，可以向 DHCP 服务器请求续租以继续使用当前的 IP 地址。</p><h3 id="4-网络管理简化"><a href="#4-网络管理简化" class="headerlink" title="4. 网络管理简化"></a>4. <strong>网络管理简化</strong></h3><p>通过 DHCP，网络管理员不需要手动为每个设备配置网络设置，简化了网络管理工作，尤其是在有大量设备的网络环境中。</p><h3 id="5-移动设备支持"><a href="#5-移动设备支持" class="headerlink" title="5. 移动设备支持"></a>5. <strong>移动设备支持</strong></h3><p>对于移动设备，如笔记本电脑、智能手机等，当它们从一个网络移动到另一个网络时，DHCP 可以自动为它们分配新的 IP 地址和配置参数，确保设备可以无缝连接到新网络。</p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>DHCP 的工作流程通常包括以下几个步骤：</p><ol><li><strong>DHCP Discover</strong>：客户端广播一个 DHCP 发现报文，寻找 DHCP 服务器。</li><li><strong>DHCP Offer</strong>：DHCP 服务器响应发现报文，提供一个 IP 地址和配置参数。</li><li><strong>DHCP Request</strong>：客户端选择一个提供的 IP 地址，并向服务器发送请求报文。</li><li><strong>DHCP Acknowledgment</strong>：服务器确认请求，并正式分配 IP 地址及其他配置参数。</li></ol><p>通过这些功能，DHCP 大大简化了网络配置和管理过程，使得网络设备可以更容易地连接和通信。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）的主要作用是自动为网络上的设备分配 IP 地址和其他网络配置参数，如子网掩码、默认网关和 DNS 服务器。这样做的目的是简化网络管理，避免手动配置每个设备的网络设置。以下是 DHCP 的具体功能：&lt;/p&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="https://hmmmmmya.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://hmmmmmya.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>030_计算机网络应用层</title>
    <link href="https://hmmmmmya.github.io/2024/11/11/030_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <id>https://hmmmmmya.github.io/2024/11/11/030_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%B1%82/</id>
    <published>2024-11-11T04:06:25.000Z</published>
    <updated>2024-11-11T04:09:39.798Z</updated>
    
    <content type="html"><![CDATA[<p>应用层是 OSI 模型中的第七层，直接面向用户和应用程序。它主要负责提供网络服务的接口和实现数据交换。以下是应用层的主要功能：</p><span id="more"></span><h2 id="应用层的主要功能"><a href="#应用层的主要功能" class="headerlink" title="应用层的主要功能"></a>应用层的主要功能</h2><h3 id="1-提供网络服务接口"><a href="#1-提供网络服务接口" class="headerlink" title="1. 提供网络服务接口"></a>1. 提供网络服务接口</h3><p>应用层为各种应用程序提供网络服务接口，使得用户可以通过这些应用程序进行通信和数据交换。例如，Web 浏览器、电子邮件客户端和文件传输应用都通过应用层协议与网络进行交互。</p><h3 id="2-数据表示和转换"><a href="#2-数据表示和转换" class="headerlink" title="2. 数据表示和转换"></a>2. 数据表示和转换</h3><p>应用层负责数据的表示和转换，确保不同系统之间的数据可以正确理解和处理。这包括字符编码、数据格式转换和数据压缩等功能。例如，HTTP 协议在传输 HTML 文件时，需要将字符数据编码为网络传输格式。</p><h3 id="3-数据加密和安全性"><a href="#3-数据加密和安全性" class="headerlink" title="3. 数据加密和安全性"></a>3. 数据加密和安全性</h3><p>应用层提供数据加密和解密功能，确保数据在传输过程中的机密性和完整性。例如，HTTPS 协议通过 SSL&#x2F;TLS 加密数据，保护用户的敏感信息。</p><h3 id="4-资源共享和远程访问"><a href="#4-资源共享和远程访问" class="headerlink" title="4. 资源共享和远程访问"></a>4. 资源共享和远程访问</h3><p>应用层支持资源共享和远程访问功能，使得用户可以访问远程服务器的资源。例如，FTP 协议允许用户上传和下载远程服务器上的文件，Telnet 协议允许用户远程登录到另一台计算机。</p><h3 id="5-消息传递和电子邮件"><a href="#5-消息传递和电子邮件" class="headerlink" title="5. 消息传递和电子邮件"></a>5. 消息传递和电子邮件</h3><p>应用层支持消息传递和电子邮件服务，例如 SMTP、POP3 和 IMAP 协议，用于发送、接收和管理电子邮件。</p><h3 id="6-文件传输和访问"><a href="#6-文件传输和访问" class="headerlink" title="6. 文件传输和访问"></a>6. 文件传输和访问</h3><p>应用层提供文件传输和访问功能，使得用户可以在网络中传输和访问文件。常见的应用层协议包括 FTP 和 HTTP，用于文件上传、下载和网页访问。</p><h3 id="7-会话管理"><a href="#7-会话管理" class="headerlink" title="7. 会话管理"></a>7. 会话管理</h3><p>应用层管理通信会话的建立、维护和终止，确保通信的有效性和可靠性。例如，SIP 协议用于管理 VoIP（互联网语音）通信会话。</p><p>通过上述功能，应用层确保用户和应用程序能够方便地使用网络资源，实现高效的数据交换和通信。</p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><p>Socket 通信主要涉及传输层和应用层。具体来说：</p><ul><li><p>传输层：在传输层，Socket 与 TCP（传输控制协议）和 UDP（用户数据报协议）一起工作。TCP 提供可靠的、面向连接的通信，而 UDP 提供无连接的、不可靠的通信。Socket 用于建立和管理这些传输层连接。</p></li><li><p>应用层：应用层通过 Socket 接口与传输层进行交互，发送和接收数据。例如，HTTP、FTP、SMTP 等应用层协议都是通过 Socket 来进行数据传输的。</p></li></ul><p>Socket 可以看作是传输层与应用层之间的桥梁，使得应用程序能够方便地使用网络传输功能。</p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>DNS（域名系统）是应用层的协议。它的主要功能是将人类可读的域名（如 <code>www.example.com</code>）转换为计算机可读的 IP 地址（如 <code>192.0.2.1</code>）。这一转换过程被称为域名解析。</p><p>在 OSI 模型中，DNS 位于应用层，并通过 UDP 或 TCP 协议在传输层上传输数据。通常情况下，DNS 查询使用 UDP 端口 53 进行通信，但也可以在某些情况下使用 TCP 端口 53，例如当返回的数据包大小超过 UDP 协议的限制时。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;应用层是 OSI 模型中的第七层，直接面向用户和应用程序。它主要负责提供网络服务的接口和实现数据交换。以下是应用层的主要功能：&lt;/p&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="https://hmmmmmya.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://hmmmmmya.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>029_计算机网络网络层</title>
    <link href="https://hmmmmmya.github.io/2024/11/11/029_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <id>https://hmmmmmya.github.io/2024/11/11/029_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BD%91%E7%BB%9C%E5%B1%82/</id>
    <published>2024-11-11T03:53:23.000Z</published>
    <updated>2024-11-11T04:08:43.004Z</updated>
    
    <content type="html"><![CDATA[<p>网络层（Network Layer）在计算机网络中扮演着关键的角色，负责数据在网络中的传输路径选择和数据包的路由。以下是网络层的主要功能：</p><span id="more"></span><h2 id="网络层的主要功能"><a href="#网络层的主要功能" class="headerlink" title="网络层的主要功能"></a>网络层的主要功能</h2><h3 id="1-路由选择"><a href="#1-路由选择" class="headerlink" title="1. 路由选择"></a>1. 路由选择</h3><p>网络层负责确定数据包从源地址到目标地址的最佳路径。路由器（Routers）使用路由协议（如 OSPF、BGP）来动态更新和维护路由表，并根据网络拓扑的变化调整路径。</p><h3 id="2-数据包转发"><a href="#2-数据包转发" class="headerlink" title="2. 数据包转发"></a>2. 数据包转发</h3><p>网络层将数据包从一个网络节点转发到下一个节点，直到数据包到达目标地址。这个过程涉及查找路由表，并根据表中的信息确定数据包的下一跳地址。</p><h3 id="3-IP-地址编址"><a href="#3-IP-地址编址" class="headerlink" title="3. IP 地址编址"></a>3. IP 地址编址</h3><p>网络层使用 IP 地址来唯一标识网络中的每个设备。IP 地址分为 IPv4 和 IPv6 两种格式，网络层通过 IP 地址来确定数据包的源和目的地。</p><h3 id="4-分段与重组"><a href="#4-分段与重组" class="headerlink" title="4. 分段与重组"></a>4. 分段与重组</h3><p>网络层将较大的数据包分割成适合传输的较小片段（分段），并在到达目标后重新组装（重组）这些片段。这对于跨越不同网络的传输尤为重要，因为不同网络可能对数据包大小有不同的限制。</p><h3 id="5-差错处理与流量控制"><a href="#5-差错处理与流量控制" class="headerlink" title="5. 差错处理与流量控制"></a>5. 差错处理与流量控制</h3><p>虽然主要的差错检测和流量控制功能在传输层，但网络层也具备一定的错误检测机制。例如，IPv4 报头包含一个校验和字段，用于检查数据包头部的完整性。此外，ICMP 协议（如 Ping）用于报告网络层错误和提供诊断功能。</p><h3 id="6-拥塞控制"><a href="#6-拥塞控制" class="headerlink" title="6. 拥塞控制"></a>6. 拥塞控制</h3><p>网络层协议需要处理网络拥塞问题，确保数据包能够高效传输。例如，通过减少数据包的转发速率，或丢弃低优先级的数据包，来缓解网络拥塞。</p><h3 id="7-安全性"><a href="#7-安全性" class="headerlink" title="7. 安全性"></a>7. 安全性</h3><p>网络层的某些协议（如 IPSec）提供了数据加密和验证功能，确保数据在传输过程中不被窃取或篡改，提高数据传输的安全性。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>网络层的主要功能是管理数据包的传输和路由，确保数据能从源地址正确、安全地传递到目标地址。这些功能对于网络的正常运行和数据的有效传输至关重要。</p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="网络层协议"><a href="#网络层协议" class="headerlink" title="网络层协议"></a>网络层协议</h3><ul><li>IP 协议</li><li>ICMP 协议</li><li>ARP 协议</li><li>RARP 协议</li></ul><h3 id="网络模型各层的作用"><a href="#网络模型各层的作用" class="headerlink" title="网络模型各层的作用"></a>网络模型各层的作用</h3><p>应用层相当于用户，负责处理应用层的逻辑。</p><p>运输层相当于快递员，负责将数据从源地址传递到目标地址。</p><p>网络层相当于邮局，负责将数据从源地址传递到目标地址。</p><p>网络接口层相当于邮局分拣员，负责将数据分拣到不同的邮局。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;网络层（Network Layer）在计算机网络中扮演着关键的角色，负责数据在网络中的传输路径选择和数据包的路由。以下是网络层的主要功能：&lt;/p&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="https://hmmmmmya.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://hmmmmmya.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>028_计算机网络传输层</title>
    <link href="https://hmmmmmya.github.io/2024/11/11/028_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    <id>https://hmmmmmya.github.io/2024/11/11/028_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%B1%82/</id>
    <published>2024-11-11T03:30:45.000Z</published>
    <updated>2024-11-11T03:55:28.394Z</updated>
    
    <content type="html"><![CDATA[<p>在计算机网络中，传输层（Transport Layer）负责在网络端点之间传输数据。它是 OSI 模型中的第四层，提供了关键的功能，以确保数据在网络中能够有效、可靠地传输。以下是传输层的一些主要功能和作用：</p><span id="more"></span><h2 id="传输层的主要功能"><a href="#传输层的主要功能" class="headerlink" title="传输层的主要功能"></a>传输层的主要功能</h2><h3 id="1-数据分段和重组"><a href="#1-数据分段和重组" class="headerlink" title="1. 数据分段和重组"></a>1. <strong>数据分段和重组</strong></h3><p>传输层将应用层传递下来的数据分割成更小的段（segments），每个段包含必要的控制信息。接收方传输层会将这些段重组成原始的数据流。</p><h3 id="2-传输控制"><a href="#2-传输控制" class="headerlink" title="2. 传输控制"></a>2. <strong>传输控制</strong></h3><p>传输层确保数据可靠传输。常见协议如 TCP（传输控制协议）提供了数据包的确认（acknowledgment）、序号（sequence numbering）、超时重传（retransmission）、流控制（flow control）和拥塞控制（congestion control）等机制。</p><h3 id="3-端到端通信"><a href="#3-端到端通信" class="headerlink" title="3. 端到端通信"></a>3. <strong>端到端通信</strong></h3><p>传输层建立并管理端到端的通信连接。TCP 协议通过三次握手（three-way handshake）建立连接，确保通信双方准备就绪，而 UDP（用户数据报协议）则是不可靠的连接，通常用于实时应用如视频流和在线游戏。</p><h3 id="4-数据完整性"><a href="#4-数据完整性" class="headerlink" title="4. 数据完整性"></a>4. <strong>数据完整性</strong></h3><p>传输层通过校验和（checksum）等技术，确保数据在传输过程中没有被篡改或损坏。TCP 协议在接收数据时会计算并验证校验和，以检测传输中的错误。</p><h3 id="5-多路复用和解复用"><a href="#5-多路复用和解复用" class="headerlink" title="5. 多路复用和解复用"></a>5. <strong>多路复用和解复用</strong></h3><p>传输层允许多个应用程序同时使用网络连接，通过使用端口号（port numbers）来区分不同的应用流。多路复用（multiplexing）指的是将多个应用数据流合并到一个物理网络连接上，而解复用（demultiplexing）则是将收到的数据分配给正确的应用程序。</p><h3 id="6-流控制"><a href="#6-流控制" class="headerlink" title="6. 流控制"></a>6. <strong>流控制</strong></h3><p>传输层可以管理发送方和接收方的速率，避免网络拥塞和数据丢失。流控制机制确保发送方不会过快地发送数据，以至于接收方来不及处理。</p><h3 id="7-拥塞控制"><a href="#7-拥塞控制" class="headerlink" title="7. 拥塞控制"></a>7. <strong>拥塞控制</strong></h3><p>在 TCP 协议中，传输层负责监控网络的拥塞状态，并动态调整数据发送速率，以避免网络过载。常见的拥塞控制算法包括慢启动（slow start）、拥塞避免（congestion avoidance）等。</p><p>通过提供上述功能，传输层在确保数据可靠、有效传输方面发挥了关键作用。</p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><p>Socket 通信主要涉及传输层和应用层。具体来说：</p><ol><li><p><strong>传输层</strong>：在传输层，Socket 与 TCP（传输控制协议）和 UDP（用户数据报协议）一起工作。TCP 提供可靠的、面向连接的通信，而 UDP 提供无连接的、不可靠的通信。Socket 用于建立和管理这些传输层连接。</p></li><li><p><strong>应用层</strong>：应用层通过 Socket 接口与传输层进行交互，发送和接收数据。例如，HTTP、FTP、SMTP 等应用层协议都是通过 Socket 来进行数据传输的。</p></li></ol><p>Socket 可以看作是传输层与应用层之间的桥梁，使得应用程序能够方便地使用网络传输功能。</p><p>socket 是传输层提供给应用层的编程接口。</p><p>socket 是应用层与传输层之间的抽象，socket 不止是 TCP 才有，UDP 也有 socket。</p><p>socket 是基于文件描述符的，socket 是文件描述符的一种。</p><h3 id="传输层的信息要发送到哪里"><a href="#传输层的信息要发送到哪里" class="headerlink" title="传输层的信息要发送到哪里"></a>传输层的信息要发送到哪里</h3><p>传输层的信息会发送到传输层协议所指定的端口，这些端口是与应用层的特定服务或应用程序关联的。例如，当你在浏览器中访问一个网站时，HTTP 协议会在传输层使用 TCP 端口 80 或者 HTTPS 的 443 端口来发送和接收数据。</p><p>具体过程如下：</p><ol><li><p><strong>发送端</strong>：传输层将应用层的数据封装成数据段，并添加头部信息（例如源端口号和目标端口号）。然后，它将这些数据段传递给网络层。</p></li><li><p><strong>网络层</strong>：网络层会根据 IP 地址将数据包路由到目标计算机。</p></li><li><p><strong>接收端</strong>：在目标计算机上，网络层接收到数据包后，会将其传递给传输层。传输层根据数据包中的端口号，将数据转发给对应的应用程序。</p></li></ol><p>因此，传输层的信息最终会交给运行在指定端口上的应用程序或服务。</p><h3 id="使用传输层所需的信息"><a href="#使用传输层所需的信息" class="headerlink" title="使用传输层所需的信息"></a>使用传输层所需的信息</h3><p>要使用传输层进行通信，通常需要以下信息：</p><ol><li><strong>源端口号</strong>：发送方传输层使用的端口号，用于标识发送方的应用程序或服务。</li><li><strong>目标端口号</strong>：接收方传输层使用的端口号，用于标识接收方的应用程序或服务。例如，HTTP 使用端口 80，HTTPS 使用端口 443。</li><li><strong>源 IP 地址</strong>：发送方设备的 IP 地址，用于标识发送数据包的设备。</li><li><strong>目标 IP 地址</strong>：接收方设备的 IP 地址，用于标识接收数据包的设备。</li><li><strong>传输协议</strong>：例如 TCP 或 UDP，用于定义数据传输的方式。TCP 提供可靠的传输，而 UDP 则是无连接的、不保证可靠性的传输方式。</li><li><strong>序号和确认号</strong>（对于 TCP）：用于确保数据包按顺序到达并确认接收，防止数据丢失或重复。每个数据段都有一个序号，接收方确认收到的数据段时会返回一个确认号。</li><li><strong>控制信息</strong>：包括各种标志位（如 SYN、ACK、FIN 等），用于控制数据传输的状态和流程。例如，SYN 和 ACK 用于 TCP 连接的建立和确认。</li><li><strong>校验和</strong>：用于数据完整性校验，确保传输过程中数据未被篡改或损坏。</li><li><strong>窗口大小</strong>：流控制信息，指示接收方可接受的最大数据量，用于控制发送方的发送速率，防止网络拥塞。</li></ol><p>通过提供这些信息，传输层能够在发送方和接收方之间建立可靠的数据传输通道，确保数据能够正确、有效地到达目标。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在计算机网络中，传输层（Transport Layer）负责在网络端点之间传输数据。它是 OSI 模型中的第四层，提供了关键的功能，以确保数据在网络中能够有效、可靠地传输。以下是传输层的一些主要功能和作用：&lt;/p&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="https://hmmmmmya.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://hmmmmmya.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>027_GOF设计模式分类</title>
    <link href="https://hmmmmmya.github.io/2024/11/07/027_GOF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB/"/>
    <id>https://hmmmmmya.github.io/2024/11/07/027_GOF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB/</id>
    <published>2024-11-07T04:15:10.000Z</published>
    <updated>2024-11-07T04:23:15.514Z</updated>
    
    <content type="html"><![CDATA[<p>GOF 设计模式是经过总结、优化的代码设计经验，用于解决软件设计中的特定问题。设计模式通常分为三大类：<strong>创建型模式</strong>、<strong>结构型模式</strong>和<strong>行为型模式</strong>。以下是每个分类中的常见设计模式：</p><span id="more"></span><h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h3><p>这些模式处理对象的创建问题，并提供更灵活、可复用的创建机制。</p><ol><li><strong>单例模式（Singleton Pattern）</strong>: 确保一个类只有一个实例，并提供全局访问点。</li><li><strong>工厂方法模式（Factory Method Pattern）</strong>: 定义一个创建对象的接口，但由子类决定要实例化的类。</li><li><strong>抽象工厂模式（Abstract Factory Pattern）</strong>: 提供一个创建一系列相关或依赖对象的接口，而无需指定具体类。</li><li><strong>生成器模式（Builder Pattern）</strong>: 将对象的构建过程与表示分离，使得同样的构建过程可以创建不同的表示。</li><li><strong>原型模式（Prototype Pattern）</strong>: 通过复制现有对象来创建新对象，避免了对象的重复初始化。</li></ol><h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><p>这些模式关注类和对象的组合关系，解决系统的结构问题。</p><ol><li><strong>适配器模式（Adapter Pattern）</strong>: 使得原本由于接口不兼容而不能一起工作的类可以一起工作。</li><li><strong>桥接模式（Bridge Pattern）</strong>: 将抽象部分与它的实现部分分离，使它们都可以独立地变化。</li><li><strong>组合模式（Composite Pattern）</strong>: 将对象组合成树形结构以表示”部分-整体”的层次结构，使得客户端可以统一地处理单个对象和组合对象。</li><li><strong>装饰者模式（Decorator Pattern）</strong>: 动态地给对象增加额外的职责。</li><li><strong>外观模式（Facade Pattern）</strong>: 提供一个统一的接口，用来访问子系统中的一群接口。</li><li><strong>享元模式（Flyweight Pattern）</strong>: 运用共享技术来支持大量细粒度的对象。</li><li><strong>代理模式（Proxy Pattern）</strong>: 为其他对象提供一种代理，以控制对这个对象的访问。</li></ol><h3 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h3><p>这些模式关注对象之间的职责划分和相互协作。</p><ol><li><strong>策略模式（Strategy Pattern）</strong>: 定义一系列算法，将每一个算法封装起来，并且使它们可以互换。</li><li><strong>模板方法模式（Template Method Pattern）</strong>: 在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。</li><li><strong>观察者模式（Observer Pattern）</strong>: 定义对象之间的一种一对多的依赖关系。</li><li><strong>迭代器模式（Iterator Pattern）</strong>: 提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。</li><li><strong>职责链模式（Chain of Responsibility Pattern）</strong>: 为请求创建一个接收者对象的链。</li><li><strong>命令模式（Command Pattern）</strong>: 将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。</li><li><strong>备忘录模式（Memento Pattern）</strong>: 在不破坏封装性的前提下，捕获并外部化一个对象的内部状态。</li><li><strong>状态模式（State Pattern）</strong>: 允许对象在内部状态改变时改变它的行为。</li><li><strong>中介者模式（Mediator Pattern）</strong>: 用一个中介对象来封装一系列对象的交互。</li><li><strong>解释器模式（Interpreter Pattern）</strong>: 给定一种语言，定义它的文法表示，并定义一个解释器来处理这个文法。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;GOF 设计模式是经过总结、优化的代码设计经验，用于解决软件设计中的特定问题。设计模式通常分为三大类：&lt;strong&gt;创建型模式&lt;/strong&gt;、&lt;strong&gt;结构型模式&lt;/strong&gt;和&lt;strong&gt;行为型模式&lt;/strong&gt;。以下是每个分类中的常见设计模式：&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://hmmmmmya.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://hmmmmmya.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>026_gitignore</title>
    <link href="https://hmmmmmya.github.io/2024/11/04/026_gitignore/"/>
    <id>https://hmmmmmya.github.io/2024/11/04/026_gitignore/</id>
    <published>2024-11-04T10:05:52.000Z</published>
    <updated>2024-11-04T10:06:53.478Z</updated>
    
    <content type="html"><![CDATA[<p>Git 忽略文件的规则</p><span id="more"></span><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><code>.gitignore</code> 文件是用来告诉 Git 哪些文件或目录在版本控制中应该被忽略的。这对于排除编译生成的文件、临时文件、日志文件以及敏感数据等非常有用。下面是一些编写 <code>.gitignore</code> 文件的基本规则和示例：</p><ol><li><p><strong>文件名匹配规则</strong>：</p><ul><li><code>*</code>：匹配零个或多个字符。</li><li><code>?</code>：匹配任意一个字符。</li><li><code>[]</code>：匹配方括号内的任意一个字符。</li><li><code>!</code>：在模式前加上感叹号表示取反，即排除匹配的文件或目录。</li></ul></li><li><p><strong>注释</strong>：以 <code>#</code> 开头的行表示注释，Git 会忽略这些行。</p></li><li><p><strong>示例</strong>：</p><ul><li><p>忽略所有 <code>.a</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*.a</span><br></pre></td></tr></table></figure></li><li><p>但是跟踪 <code>lib.a</code>，即使在忽略 <code>.a</code> 文件的规则下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!lib.a</span><br></pre></td></tr></table></figure></li><li><p>忽略所有以 <code>.o</code> 结尾的文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*.o</span><br></pre></td></tr></table></figure></li><li><p>忽略所有以 <code>~</code> 结尾的临时文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*~</span><br></pre></td></tr></table></figure></li><li><p>忽略 <code>TODO</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TODO</span><br></pre></td></tr></table></figure></li><li><p>忽略 <code>build/</code> 目录下的所有文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build/</span><br></pre></td></tr></table></figure></li><li><p>忽略 <code>doc/notes.txt</code> 文件，但不包括 <code>doc/server/arch.txt</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doc/notes.txt</span><br></pre></td></tr></table></figure></li><li><p>忽略 <code>doc/</code> 目录下的 <code>.pdf</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doc/*.pdf</span><br></pre></td></tr></table></figure></li><li><p>忽略 <code>doc/</code> 目录下的所有 <code>.pdf</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="取消忽略后无效果"><a href="#取消忽略后无效果" class="headerlink" title="取消忽略后无效果"></a>取消忽略后无效果</h3><p>如果上述 <code>.gitignore</code> 规则没有达到预期效果，可以尝试更具体的忽略和取消忽略规则。在 <code>.gitignore</code> 文件中，顺序和具体路径可能会影响规则的应用。以下是调整后的版本，确保首先取消忽略特定的文件夹，然后忽略一般的文件夹：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 取消忽略以 hexo-theme- 开头的文件夹</span><br><span class="line">!node_modules/hexo-theme-*/</span><br><span class="line"></span><br><span class="line"># 忽略 node_modules 文件夹及其所有内容</span><br><span class="line">node_modules/</span><br><span class="line"></span><br><span class="line"># 忽略 node_modules 文件夹下的 hexo-theme-landscape 文件夹</span><br><span class="line">node_modules/hexo-theme-landscape/</span><br></pre></td></tr></table></figure><p>另外，请确保这些文件夹已经被 Git 跟踪（即它们之前没有被忽略）。如果这些文件夹之前已经被忽略，需要先将它们从缓存中移除，然后重新添加它们。可以按照以下步骤操作：</p><ol><li><p>从 Git 缓存中移除 <code>node_modules</code> 文件夹（但保留本地文件）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> -r --cached node_modules</span><br></pre></td></tr></table></figure></li><li><p>确认 <code>.gitignore</code> 文件中的规则。</p></li><li><p>重新添加 <code>node_modules</code> 文件夹：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add node_modules</span><br></pre></td></tr></table></figure></li><li><p>提交更改：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;Update .gitignore rules&quot;</span></span><br></pre></td></tr></table></figure></li></ol><p>通过这些步骤，Git 将正确应用 <code>.gitignore</code> 文件中的规则。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Git 忽略文件的规则&lt;/p&gt;</summary>
    
    
    
    <category term="git" scheme="https://hmmmmmya.github.io/categories/git/"/>
    
    
    <category term="git" scheme="https://hmmmmmya.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>025_PR和MR的区别</title>
    <link href="https://hmmmmmya.github.io/2024/11/04/025_PR%E5%92%8CMR%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://hmmmmmya.github.io/2024/11/04/025_PR%E5%92%8CMR%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2024-11-04T09:59:06.000Z</published>
    <updated>2024-11-04T10:00:45.416Z</updated>
    
    <content type="html"><![CDATA[<p>PR（Pull Request）和 MR（Merge Request）是代码版本控制系统中的两个概念，它们主要用于在多人协作开发项目时合并代码变更。这两个术语在功能上非常相似，但在不同的代码托管平台上有不同的称呼。</p><span id="more"></span><h2 id="PR（Pull-Request）"><a href="#PR（Pull-Request）" class="headerlink" title="PR（Pull Request）"></a>PR（Pull Request）</h2><ul><li><strong>定义</strong>: Pull Request 是 GitHub、Bitbucket、GitLab 等平台上用于代码合并的一种请求机制。当开发者在自己的分支上完成了一组代码更改后，他们可以创建一个 Pull Request 请求，将这些更改合并到主分支（例如 <code>main</code> 或 <code>master</code>）或者其他目标分支。</li><li><strong>使用场景</strong>:<ul><li>开发者完成功能或修复后，创建 PR 并向代码库的维护者或团队成员发出请求，要求对这些更改进行审查。</li><li>审查通过后，维护者可以批准并合并 PR，将这些更改合并到目标分支中。</li></ul></li><li><strong>平台</strong>: PR 这个术语主要用于 GitHub 和 Bitbucket 等平台。</li></ul><h2 id="MR（Merge-Request）"><a href="#MR（Merge-Request）" class="headerlink" title="MR（Merge Request）"></a>MR（Merge Request）</h2><ul><li><p><strong>定义</strong>: Merge Request 是 GitLab 上使用的术语，功能上与 Pull Request 类似。MR 用于向项目中的其他开发者或团队发出合并代码更改的请求。</p></li><li><p><strong>使用场景</strong>:</p><ul><li>在开发者完成某个功能或修复后，他们提交 MR 请求，将代码合并到主分支或其他目标分支。</li><li>代码库的维护者或团队成员审查 MR，并决定是否合并这些更改。</li></ul></li><li><p><strong>平台</strong>: MR 主要在 GitLab 上使用。</p></li></ul><h2 id="PR-和-MR-的区别"><a href="#PR-和-MR-的区别" class="headerlink" title="PR 和 MR 的区别"></a>PR 和 MR 的区别</h2><ul><li><strong>平台不同</strong>: PR 主要用于 GitHub 和 Bitbucket，MR 主要用于 GitLab。</li><li><strong>功能相同</strong>: 尽管名称不同，PR 和 MR 的核心功能都是相同的，即允许开发者在合并代码之前发起请求进行代码审查。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>无论是 PR 还是 MR，它们的主要目的是通过让代码库的维护者或团队成员审查代码，确保在代码合并到主分支之前能够发现并解决潜在的问题。这种机制有助于提高代码质量，减少引入的错误，同时也便于多人协作开发。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;PR（Pull Request）和 MR（Merge Request）是代码版本控制系统中的两个概念，它们主要用于在多人协作开发项目时合并代码变更。这两个术语在功能上非常相似，但在不同的代码托管平台上有不同的称呼。&lt;/p&gt;</summary>
    
    
    
    <category term="git" scheme="https://hmmmmmya.github.io/categories/git/"/>
    
    
    <category term="git" scheme="https://hmmmmmya.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>024_cpp初始化</title>
    <link href="https://hmmmmmya.github.io/2024/10/31/024_cpp%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>https://hmmmmmya.github.io/2024/10/31/024_cpp%E5%88%9D%E5%A7%8B%E5%8C%96/</id>
    <published>2024-10-31T09:43:25.000Z</published>
    <updated>2024-10-31T09:59:00.923Z</updated>
    
    <content type="html"><![CDATA[<p>介绍下 c++ 的初始化</p><span id="more"></span><h2 id="一-自动初始化为-0-的情况"><a href="#一-自动初始化为-0-的情况" class="headerlink" title="一. 自动初始化为 0 的情况"></a>一. 自动初始化为 0 的情况</h2><p>在 C++中，初始化为 0 的情况取决于变量的类型、存储位置和初始化方式。以下是 C++中会自动初始化为 0 的几种情况：</p><h3 id="1-全局变量和静态变量"><a href="#1-全局变量和静态变量" class="headerlink" title="1. 全局变量和静态变量"></a>1. <strong>全局变量和静态变量</strong></h3><ul><li><p><strong>全局变量</strong>（包括命名空间作用域的变量）和<strong>静态变量</strong>（<code>static</code>）在定义时会被自动初始化为 0。</p></li><li><p>这种自动初始化包括整型初始化为 0，浮点型初始化为 0.0，指针初始化为<code>nullptr</code>，类对象会调用默认构造函数。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> globalVar;          <span class="comment">// 自动初始化为0</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> staticVar;    <span class="comment">// 静态变量自动初始化为0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> funcStaticVar;  <span class="comment">// 函数内部的静态变量自动初始化为0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-类中的非静态成员变量（使用值初始化）"><a href="#2-类中的非静态成员变量（使用值初始化）" class="headerlink" title="2. 类中的非静态成员变量（使用值初始化）"></a>2. <strong>类中的非静态成员变量（使用值初始化）</strong></h3><ul><li><p>如果对象的非静态成员变量没有显式初始化，在值初始化时这些成员变量会被自动初始化为 0。</p></li><li><p>值初始化通常发生在使用花括号初始化或默认初始化的情况下。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">double</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj&#123;&#125;;  <span class="comment">// obj.a 和 obj.b 都会被初始化为0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-数组的值初始化"><a href="#3-数组的值初始化" class="headerlink" title="3. 数组的值初始化"></a>3. <strong>数组的值初始化</strong></h3><ul><li><p>如果数组通过值初始化进行初始化，数组中的元素会被初始化为 0。</p></li><li><p>通常使用花括号初始化或空花括号初始化的方式触发此行为。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr1[<span class="number">5</span>] = &#123;&#125;;   <span class="comment">// 所有元素初始化为0</span></span><br><span class="line"><span class="type">int</span> arr2[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">// 所有元素初始化为0</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="4-动态分配的内存初始化"><a href="#4-动态分配的内存初始化" class="headerlink" title="4. 动态分配的内存初始化"></a>4. <strong>动态分配的内存初始化</strong></h3><ul><li><p>使用<code>new</code>时，如果使用了带括号的方式，会将分配的内存初始化为 0。</p></li><li><p>不加括号的<code>new</code>不会自动初始化（需要手动赋值）。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p1 = <span class="keyword">new</span> <span class="built_in">int</span>();       <span class="comment">// *p1 被初始化为0</span></span><br><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>]();   <span class="comment">// arr数组的每个元素都初始化为0</span></span><br><span class="line"><span class="keyword">delete</span> p1;</span><br><span class="line"><span class="keyword">delete</span>[] arr;</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-内置类型的局部变量不会自动初始化"><a href="#5-内置类型的局部变量不会自动初始化" class="headerlink" title="5. 内置类型的局部变量不会自动初始化"></a>5. <strong>内置类型的局部变量不会自动初始化</strong></h3><ul><li><p>如果是局部变量且不属于静态存储期的内置类型变量（如局部整型、浮点型或指针），则它们不会自动初始化为 0，值是未定义的，需手动初始化。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> localVar;    <span class="comment">// 未初始化，值未定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>C++中会自动初始化为 0 的主要情形包括全局&#x2F;静态变量、类中的非静态成员变量（在值初始化时）、使用值初始化的数组和使用括号初始化的动态内存。</p><h3 id="1-vector-初始化"><a href="#1-vector-初始化" class="headerlink" title="1. vector 初始化"></a>1. vector 初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>是的,使用这种方式定义 vector 时,编译器会自动将所有元素初始化为 0。</p><p>具体来说:</p><ol><li>对于内置类型(如 int, double 等),会被初始化为 0</li><li>对于类类型,会调用默认构造函数</li></ol><p>举例说明:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下定义方式都会将元素初始化为0</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">5</span>)</span></span>;           <span class="comment">// &#123;0,0,0,0,0&#125;</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">double</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">3</span>)</span></span>;        <span class="comment">// &#123;0.0,0.0,0.0&#125;</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">2</span>)</span></span>;          <span class="comment">// &#123;false,false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类类型会调用默认构造函数</span></span><br><span class="line"><span class="function">std::vector&lt;std::string&gt; <span class="title">v4</span><span class="params">(<span class="number">2</span>)</span></span>;   <span class="comment">// &#123;&quot;&quot;,&quot;&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>所以 vector 中的所有 int 元素已经被初始化为 0 了。</p><h2 id="二-存放内置类型的容器初始化"><a href="#二-存放内置类型的容器初始化" class="headerlink" title="二. 存放内置类型的容器初始化"></a>二. 存放内置类型的容器初始化</h2><p>在 C++中，存放内置类型的容器（如<code>std::vector&lt;int&gt;</code>）中的值是否会被初始化，取决于容器的构造和初始化方式。默认情况下，内置类型的元素不会自动初始化为 0，需要显式设置或采用某些特定的构造方式。以下是不同情况下的初始化行为：</p><h3 id="1-默认构造的容器"><a href="#1-默认构造的容器" class="headerlink" title="1. 默认构造的容器"></a>1. <strong>默认构造的容器</strong></h3><ul><li><p>如果使用默认构造的容器（即没有指定大小或初始值），则容器的内容为空。</p></li><li><p>例如，<code>std::vector&lt;int&gt; v;</code>会创建一个空的<code>vector</code>，没有任何元素，因此不存在初始化的问题。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;  <span class="comment">// 空容器，没有元素，因此没有初始化</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-指定大小的构造方式"><a href="#2-指定大小的构造方式" class="headerlink" title="2. 指定大小的构造方式"></a>2. <strong>指定大小的构造方式</strong></h3><ul><li><p>如果通过指定大小来构造容器，例如<code>std::vector&lt;int&gt; v(5);</code>，容器会分配出对应数量的元素。</p></li><li><p>对于内置类型的元素，使用此方式初始化时，值是未定义的，不会自动初始化为 0。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">5</span>)</span></span>;  <span class="comment">// 分配5个int元素，值未定义</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-指定大小和初始值的构造方式"><a href="#3-指定大小和初始值的构造方式" class="headerlink" title="3. 指定大小和初始值的构造方式"></a>3. <strong>指定大小和初始值的构造方式</strong></h3><ul><li><p>使用<code>std::vector&lt;int&gt; v(5, 0);</code>指定大小并提供初始值时，所有元素都会被初始化为指定的值（此处为 0）。</p></li><li><p>这种方式适用于确保容器中所有元素的初始值。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">5</span>, <span class="number">0</span>)</span></span>;  <span class="comment">// 分配5个元素，全部初始化为0</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="4-使用std-array"><a href="#4-使用std-array" class="headerlink" title="4. 使用std::array"></a>4. <strong>使用<code>std::array</code></strong></h3><ul><li><p><code>std::array</code>的大小是固定的，初始化时如果没有提供所有元素的初始值，未指定的元素会被自动初始化为 0。</p></li><li><p>例如，<code>std::array&lt;int, 5&gt; arr = &#123;1&#125;;</code>会将第一个元素初始化为 1，其他元素初始化为 0。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::array&lt;<span class="type">int</span>, 5&gt; arr = &#123;<span class="number">1</span>&#125;;  <span class="comment">// arr = &#123;1, 0, 0, 0, 0&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="5-使用std-vector的resize方法"><a href="#5-使用std-vector的resize方法" class="headerlink" title="5. 使用std::vector的resize方法"></a>5. <strong>使用<code>std::vector</code>的<code>resize</code>方法</strong></h3><ul><li><p>使用<code>resize</code>调整大小时，如果提供初始值参数（如<code>v.resize(5, 0);</code>），所有新元素会被初始化为指定值（这里是 0）。</p></li><li><p>如果不提供初始值，则新元素的值未定义。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">resize</span>(<span class="number">5</span>, <span class="number">0</span>);  <span class="comment">// 将容器扩展为5个元素，全部初始化为0</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li>**默认构造或仅指定大小的<code>vector</code>**：元素不会被初始化，值未定义。</li><li>**指定大小和初始值的<code>vector</code>**：元素会被初始化为指定值。</li><li><strong><code>std::array</code>初始化不完全填充</strong>：剩余元素会被初始化为 0。</li><li><strong><code>resize</code>时提供初始值</strong>：新元素会被初始化为该值。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍下 c++ 的初始化&lt;/p&gt;</summary>
    
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/categories/c/"/>
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/tags/c/"/>
    
  </entry>
  
</feed>
