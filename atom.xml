<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hymns</title>
  
  
  <link href="https://hmmmmmya.github.io/atom.xml" rel="self"/>
  
  <link href="https://hmmmmmya.github.io/"/>
  <updated>2025-02-26T08:00:45.200Z</updated>
  <id>https://hmmmmmya.github.io/</id>
  
  <author>
    <name>Hymns</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>076-格式化字符串参数</title>
    <link href="https://hmmmmmya.github.io/2025/02/26/076-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%82%E6%95%B0/"/>
    <id>https://hmmmmmya.github.io/2025/02/26/076-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%82%E6%95%B0/</id>
    <published>2025-02-26T07:58:01.000Z</published>
    <updated>2025-02-26T08:00:45.200Z</updated>
    
    <content type="html"><![CDATA[<think><p>好的，我需要解释用户关于 C++模板函数中<code>const char *format</code>和<code>Args &amp;&amp;...args</code>的用法的问题。用户可能不太熟悉可变参数模板和完美转发，所以需要从基础开始讲解，同时结合他们现有的日志库代码示例。</p><p>首先，用户提供的代码片段中有一个模板函数<code>trace</code>，它使用了<code>const char *format</code>和<code>Args &amp;&amp;...args</code>作为参数。我需要解释这两个部分的作用以及为什么这样设计。</p><ol><li><p>**<code>const char *format</code>**：这是一个指向常量字符的指针，通常用于格式化字符串，类似于 C 标准库中的<code>printf</code>函数。用户可能已经熟悉这种用法，但需要明确它在模板函数中的作用。</p></li><li><p>**<code>Args &amp;&amp;...args</code>**：这是可变参数模板和右值引用的结合，用于实现完美转发。需要解释模板参数包<code>...</code>的作用，以及<code>&amp;&amp;</code>在模板中的意义（即通用引用）。</p></li></ol><p>接下来，我需要考虑如何将这些概念以简单易懂的方式传达给用户。可能需要分步骤解释：</p><ul><li><strong>可变参数模板</strong>：允许函数接受任意数量和类型的参数。</li><li><strong>右值引用和完美转发</strong>：保持参数的值类别（左值或右值），以便高效传递。</li><li><strong><code>std::forward</code>的作用</strong>：在传递参数时保持其原始类型，避免不必要的拷贝。</li></ul><p>同时，需要结合用户的实际代码，说明为什么在他们的日志函数中使用这些特性是有益的，比如提高类型安全性、支持更多参数类型、避免<code>va_list</code>的问题等。</p><p>还需要注意用户可能存在的疑问点，例如：</p><ul><li>为什么使用模板而不是传统的可变参数？</li><li><code>&amp;&amp;</code>和<code>...</code>的具体作用是什么？</li><li>如何在实际调用中使用这些参数？</li></ul><p>最后，通过示例代码展示如何使用修改后的日志函数，帮助用户更好地理解这些概念的实际应用。<br></think></p><p>我将通过您日志库中的代码示例，详细解释这些语法元素的用法：</p><h2 id="1-const-char-format-的作用"><a href="#1-const-char-format-的作用" class="headerlink" title="1. const char* format 的作用"></a>1. <code>const char* format</code> 的作用</h2><p>这是 C&#x2F;C++中传统的格式化字符串参数，用于指定日志消息的格式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例调用</span></span><br><span class="line">log::<span class="built_in">trace</span>(<span class="string">&quot;Temperature: %.1f℃&quot;</span>, <span class="number">36.5f</span>);</span><br><span class="line"><span class="comment">//          ▲ format字符串       ▲ 参数</span></span><br></pre></td></tr></table></figure><p>在您的代码中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">trace</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, Args &amp;&amp;...args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    log::<span class="built_in">Instance</span>().<span class="built_in">log</span>(level::trace, format, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>format</code>参数：</p><ul><li>接收类似”Value: %d”的格式字符串</li><li>支持传统的 printf 格式说明符</li><li>作为第一个参数传递给底层日志函数</li></ul><h2 id="2-Args-args-的组成解析"><a href="#2-Args-args-的组成解析" class="headerlink" title="2. Args &amp;&amp;...args 的组成解析"></a>2. <code>Args &amp;&amp;...args</code> 的组成解析</h2><p>这个语法包含三个关键部分：</p><h3 id="1-typename-Args"><a href="#1-typename-Args" class="headerlink" title="(1) typename... Args"></a>(1) <code>typename... Args</code></h3><ul><li>声明模板参数包（Template Parameter Pack）</li><li>表示可以接受任意数量和类型的参数</li><li>例如：<code>trace(&quot;Info&quot;, 42, 3.14, &quot;test&quot;)</code>中的 42, 3.14, “test”</li></ul><h3 id="2-右值引用符号"><a href="#2-右值引用符号" class="headerlink" title="(2) &amp;&amp; 右值引用符号"></a>(2) <code>&amp;&amp;</code> 右值引用符号</h3><ul><li>在模板上下文中称为”通用引用”（Universal Reference）</li><li>可以绑定到左值或右值</li><li>保留参数的原始值类别（value category）</li></ul><h3 id="3-args-参数包展开"><a href="#3-args-参数包展开" class="headerlink" title="(3) ...args 参数包展开"></a>(3) <code>...args</code> 参数包展开</h3><ul><li>将模板参数包展开为函数参数</li><li>允许函数接受任意数量的参数</li></ul><h2 id="3-组合使用的优势"><a href="#3-组合使用的优势" class="headerlink" title="3. 组合使用的优势"></a>3. 组合使用的优势</h2><p>在您的日志函数中这样设计可以实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">trace</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, Args &amp;&amp;...args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 参数检查</span></span><br><span class="line">    <span class="keyword">if</span> (g_log_print_level &gt; level::trace) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 完美转发参数</span></span><br><span class="line">    log::<span class="built_in">Instance</span>().<span class="built_in">log</span>(level::trace,</span><br><span class="line">                         format,</span><br><span class="line">                         std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优势：</p><ol><li><strong>类型安全</strong>：编译器会在编译时检查格式字符串与参数类型是否匹配</li><li><strong>高效传递</strong>：<code>std::forward</code>保持参数的左右值特性，避免不必要的拷贝</li><li><strong>灵活扩展</strong>：支持任意数量和类型的日志参数</li><li><strong>兼容传统</strong>：保留 printf 风格的格式化方式</li></ol><h2 id="4-实际使用示例"><a href="#4-实际使用示例" class="headerlink" title="4. 实际使用示例"></a>4. 实际使用示例</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出：User &#x27;admin&#x27; logged in from 192.168.1.100</span></span><br><span class="line">log::<span class="built_in">info</span>(<span class="string">&quot;User &#x27;%s&#x27; logged in from %s&quot;</span>, <span class="string">&quot;admin&quot;</span>, <span class="string">&quot;192.168.1.100&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="支持复杂类型"><a href="#支持复杂类型" class="headerlink" title="支持复杂类型"></a>支持复杂类型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::string deviceName = <span class="string">&quot;Sensor01&quot;</span>;</span><br><span class="line"><span class="keyword">auto</span> reading = <span class="built_in">getSensorData</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动调用对象的toString方法（如果有）</span></span><br><span class="line">log::<span class="built_in">debug</span>(<span class="string">&quot;Device %s report: %s&quot;</span>,</span><br><span class="line">            deviceName.<span class="built_in">c_str</span>(),</span><br><span class="line">            reading.<span class="built_in">toString</span>().<span class="built_in">c_str</span>());</span><br></pre></td></tr></table></figure><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高效处理临时对象</span></span><br><span class="line">log::<span class="built_in">trace</span>(<span class="string">&quot;Created temporary object at %p&quot;</span>,</span><br><span class="line">            std::<span class="built_in">make_unique</span>&lt;Config&gt;().<span class="built_in">get</span>());</span><br></pre></td></tr></table></figure><h2 id="5-与传统-C-风格可变参数的对比"><a href="#5-与传统-C-风格可变参数的对比" class="headerlink" title="5. 与传统 C 风格可变参数的对比"></a>5. 与传统 C 风格可变参数的对比</h2><table><thead><tr><th>特性</th><th>模板参数包 (<code>Args&amp;&amp;...</code>)</th><th>C 风格可变参数 (<code>va_list</code>)</th></tr></thead><tbody><tr><td>类型安全</td><td>✅ 编译时检查</td><td>❌ 运行时可能崩溃</td></tr><tr><td>支持类对象</td><td>✅ 自动推导类型</td><td>❌ 只能处理 POD 类型</td></tr><tr><td>参数数量检查</td><td>✅ 编译时验证</td><td>❌ 运行时可能出错</td></tr><tr><td>性能优化</td><td>✅ 完美转发</td><td>❌ 多次拷贝</td></tr><tr><td>可读性</td><td>✅ 现代 C++风格</td><td>❌ 传统 C 风格</td></tr><tr><td>调试便利性</td><td>✅ 更好的错误信息</td><td>❌ 难以调试</td></tr></tbody></table><h2 id="6-在您代码中的具体工作流程"><a href="#6-在您代码中的具体工作流程" class="headerlink" title="6. 在您代码中的具体工作流程"></a>6. 在您代码中的具体工作流程</h2><p>当调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log::<span class="built_in">trace</span>(<span class="string">&quot;Value: %d, Name: %s&quot;</span>, <span class="number">42</span>, <span class="string">&quot;test&quot;</span>);</span><br></pre></td></tr></table></figure><p>编译器会：</p><ol><li>推导<code>Args</code>为<code>int, const char*</code></li><li>实例化模板函数：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">trace</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format, <span class="type">int</span>&amp;&amp; arg1, <span class="type">const</span> <span class="type">char</span>*&amp;&amp; arg2)</span></span></span><br></pre></td></tr></table></figure></li><li>通过<code>std::forward</code>完美转发参数</li><li>调用底层日志记录函数时保持参数原始类型</li></ol><h2 id="7-为什么需要std-forward"><a href="#7-为什么需要std-forward" class="headerlink" title="7. 为什么需要std::forward"></a>7. 为什么需要<code>std::forward</code></h2><p><code>std::forward&lt;Args&gt;(args)...</code>的作用：</p><ul><li>保持参数的左右值特性</li><li>避免不必要的拷贝构造</li><li>实现完美转发（Perfect Forwarding）</li></ul><p>示例说明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp;)</span>  </span>&#123; cout &lt;&lt; <span class="string">&quot;lvalue&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp;&amp;)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;rvalue&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(std::forward&lt;T&gt;(arg));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">log</span>(a);    <span class="comment">// 输出：lvalue</span></span><br><span class="line">    <span class="built_in">log</span>(<span class="number">20</span>);   <span class="comment">// 输出：rvalue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在您的日志函数中，这种机制可以：</p><ul><li>高效处理字符串字面量（右值）</li><li>正确传递变量（左值）</li><li>支持移动语义（move semantics）</li></ul><h2 id="8-最佳实践建议"><a href="#8-最佳实践建议" class="headerlink" title="8. 最佳实践建议"></a>8. 最佳实践建议</h2><ol><li><p><strong>格式字符串检查</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用C++20的编译时检查</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">trace</span><span class="params">([[maybe_unused]] <span class="type">const</span> <span class="type">char</span>* format, Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(<span class="keyword">sizeof</span>...(Args) == <span class="number">2</span>, <span class="string">&quot;Expected 2 arguments&quot;</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>类型安全格式化</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用C++20 std::format风格</span></span><br><span class="line">log::<span class="built_in">info</span>(<span class="string">&quot;Temperature: &#123;:.1f&#125;℃&quot;</span>, <span class="number">36.5f</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>性能敏感场景</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用编译时字符串处理</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">trace</span><span class="params">(<span class="type">const</span> <span class="type">char</span> (&amp;format)[N], Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 编译时已知格式字符串长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>异常处理</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 格式化操作</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">const</span> std::format_error&amp; e) &#123;</span><br><span class="line">    <span class="comment">// 处理格式错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这些改进可以使您的日志库：</p><ul><li>更安全</li><li>更高效</li><li>更易于维护</li><li>支持现代 C++特性</li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;think&gt;

&lt;p&gt;好的，我需要解释用户关于 C++模板函数中&lt;code&gt;const char *format&lt;/code&gt;和&lt;code&gt;Args</summary>
        
      
    
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>075-排序算法</title>
    <link href="https://hmmmmmya.github.io/2025/02/12/075-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://hmmmmmya.github.io/2025/02/12/075-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2025-02-12T08:31:22.000Z</published>
    <updated>2025-02-12T08:32:43.199Z</updated>
    
    <content type="html"><![CDATA[<p>常见的排序算法可分为比较排序和非比较排序两大类，以下是主要分类及典型算法：</p><hr><h3 id="一、比较排序"><a href="#一、比较排序" class="headerlink" title="一、比较排序"></a>一、比较排序</h3><ol><li><p><strong>基础排序</strong></p><ul><li><p><strong>冒泡排序（Bubble Sort）</strong></p><ul><li><strong>时间复杂度</strong>：O(n²)</li><li><strong>特点</strong>：相邻元素交换，稳定排序</li><li><strong>优化</strong>：加入 flag 判断提前终止</li></ul></li><li><p><strong>选择排序（Selection Sort）</strong></p><ul><li><strong>时间复杂度</strong>：O(n²)</li><li><strong>特点</strong>：每次选择最小元素放到前面，不稳定（交换可能破坏顺序）</li></ul></li><li><p><strong>插入排序（Insertion Sort）</strong></p><ul><li><strong>时间复杂度</strong>：O(n²)（最好情况 O(n)）</li><li><strong>特点</strong>：适合小规模或基本有序数据，稳定</li></ul></li></ul></li><li><p><strong>分治排序</strong></p><ul><li><p><strong>快速排序（Quick Sort）</strong></p><ul><li><strong>平均时间复杂度</strong>：O(nlogn)</li><li><strong>最坏情况</strong>：O(n²)（已排序数据+基准选择不当）</li><li><strong>特点</strong>：原地排序，不稳定，实际应用最广泛</li></ul></li><li><p><strong>归并排序（Merge Sort）</strong></p><ul><li><strong>时间复杂度</strong>：O(nlogn)</li><li><strong>特点</strong>：稳定排序，需要额外 O(n) 空间，适合外部排序</li></ul></li></ul></li><li><p><strong>高效改进型</strong></p><ul><li><p><strong>希尔排序（Shell Sort）</strong></p><ul><li><strong>时间复杂度</strong>：O(n^(1.3~2))</li><li><strong>特点</strong>：插入排序的改进，通过分组增量提升效率</li></ul></li><li><p><strong>堆排序（Heap Sort）</strong></p><ul><li><strong>时间复杂度</strong>：O(nlogn)</li><li><strong>特点</strong>：利用堆结构，不稳定，空间复杂度 O(1)</li></ul></li></ul></li></ol><hr><h3 id="二、非比较排序"><a href="#二、非比较排序" class="headerlink" title="二、非比较排序"></a>二、非比较排序</h3><ol><li><p><strong>计数排序（Counting Sort）</strong></p><ul><li><strong>时间复杂度</strong>：O(n + k)（k 为数据范围）</li><li><strong>适用场景</strong>：整数且数据范围较小（如年龄排序）</li></ul></li><li><p><strong>桶排序（Bucket Sort）</strong></p><ul><li><strong>时间复杂度</strong>：O(n + k)（k 为桶数量）</li><li><strong>特点</strong>：数据均匀分布时高效，需要额外空间</li></ul></li><li><p><strong>基数排序（Radix Sort）</strong></p><ul><li><strong>时间复杂度</strong>：O(d(n + k))（d 为位数，k 为基数）</li><li><strong>特点</strong>：按位排序，稳定，适合整数或定长字符串</li></ul></li></ol><hr><h3 id="三、算法对比"><a href="#三、算法对比" class="headerlink" title="三、算法对比"></a>三、算法对比</h3><table><thead><tr><th>算法</th><th>平均时间复杂度</th><th>最坏时间复杂度</th><th>空间复杂度</th><th>稳定性</th><th>适用场景</th></tr></thead><tbody><tr><td>冒泡排序</td><td>O(n²)</td><td>O(n²)</td><td>O(1)</td><td>稳定</td><td>教学演示</td></tr><tr><td>快速排序</td><td>O(nlogn)</td><td>O(n²)</td><td>O(logn)</td><td>不稳定</td><td>通用数据</td></tr><tr><td>归并排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(n)</td><td>稳定</td><td>大数据量外部排序</td></tr><tr><td>堆排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(1)</td><td>不稳定</td><td>实时系统（无最坏情况）</td></tr><tr><td>计数排序</td><td>O(n + k)</td><td>O(n + k)</td><td>O(k)</td><td>稳定</td><td>小范围整数</td></tr><tr><td>基数排序</td><td>O(d(n + k))</td><td>O(d(n + k))</td><td>O(n + k)</td><td>稳定</td><td>多位数排序</td></tr></tbody></table><hr><h3 id="四、工程实践建议"><a href="#四、工程实践建议" class="headerlink" title="四、工程实践建议"></a>四、工程实践建议</h3><ol><li><p><strong>语言内置排序</strong></p><ul><li>Python：<code>list.sort()</code> 使用 TimSort（归并+插入）</li><li>Java：<code>Arrays.sort()</code> 对基本类型用双轴快排，对象用 TimSort</li><li>C++：<code>std::sort()</code> 使用 IntroSort（快速+堆排序）</li></ul></li><li><p><strong>选择策略</strong></p><ul><li><strong>小数据量（n ≤ 50）</strong>：插入排序（常数项小）</li><li><strong>通用场景</strong>：快速排序（注意随机化基准选择）</li><li><strong>需要稳定</strong>：归并排序</li><li><strong>已知数据范围</strong>：计数&#x2F;桶&#x2F;基数排序</li></ul></li></ol><hr><h3 id="五、可视化对比"><a href="#五、可视化对比" class="headerlink" title="五、可视化对比"></a>五、可视化对比</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">数据规模 n=10000 的排序耗时示例（单位：毫秒）：</span><br><span class="line">- 冒泡排序：≈1200ms</span><br><span class="line">- 插入排序：≈200ms</span><br><span class="line">- 快速排序：≈2ms</span><br><span class="line">- 计数排序（k=1000）：≈1ms</span><br></pre></td></tr></table></figure><p>（测试环境：Intel i7-11800H @2.3GHz）</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;常见的排序算法可分为比较排序和非比较排序两大类，以下是主要分类及典型算法：&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;一、比较排序&quot;&gt;&lt;a href=&quot;#一、比较排序&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="算法" scheme="https://hmmmmmya.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>074-查找算法search-algorithm</title>
    <link href="https://hmmmmmya.github.io/2025/02/12/074-%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    <id>https://hmmmmmya.github.io/2025/02/12/074-%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</id>
    <published>2025-02-12T06:15:29.000Z</published>
    <updated>2025-02-12T06:32:05.397Z</updated>
    
    <content type="html"><![CDATA[<p>常见的搜索算法可分为基础查找算法、树结构搜索、图搜索和特殊结构搜索四大类，以下是主要分类及典型算法：</p><hr><h3 id="一、基础查找算法"><a href="#一、基础查找算法" class="headerlink" title="一、基础查找算法"></a>一、基础查找算法</h3><ol><li><p><strong>线性搜索（Linear Search）</strong></p><ul><li><strong>实现方式</strong>：逐个遍历元素</li><li><strong>时间复杂度</strong>：O(n)</li><li><strong>适用场景</strong>：无序数据集合</li></ul></li><li><p><strong>二分搜索（Binary Search）</strong></p><ul><li><strong>实现方式</strong>：基于有序数组的折半查找</li><li><strong>时间复杂度</strong>：O(logn)</li><li><strong>变体</strong>：插值搜索（按分布比例预测位置）、指数搜索（先确定范围再二分）</li></ul></li></ol><hr><h3 id="二、树结构搜索"><a href="#二、树结构搜索" class="headerlink" title="二、树结构搜索"></a>二、树结构搜索</h3><ol><li><p><strong>二叉搜索树（BST）</strong></p><ul><li><strong>特点</strong>：左子树值 &lt; 根节点 &lt; 右子树值</li><li><strong>时间复杂度</strong>：平均 O(logn)，最差 O(n)（退化为链表时）</li></ul></li><li><p><strong>平衡树系列</strong></p><ul><li><strong>AVL 树</strong>：严格平衡，通过旋转保持高度差 ≤1</li><li><strong>红黑树</strong>：近似平衡，插入&#x2F;删除效率更高</li><li><strong>B&#x2F;B+ 树</strong>：多路平衡，专为磁盘存储设计（数据库索引）</li></ul></li><li><p><strong>堆结构搜索</strong></p><ul><li><strong>特点</strong>：仅能快速访问堆顶元素（最大&#x2F;最小值）</li><li><strong>应用</strong>：优先队列、Top K 问题</li></ul></li></ol><hr><h3 id="三、图搜索算法"><a href="#三、图搜索算法" class="headerlink" title="三、图搜索算法"></a>三、图搜索算法</h3><ol><li><p><strong>广度优先搜索（BFS）</strong></p><ul><li><strong>实现</strong>：队列辅助，层序遍历</li><li><strong>应用</strong>：最短路径（未加权图）、社交网络关系搜索</li></ul></li><li><p><strong>深度优先搜索（DFS）</strong></p><ul><li><strong>实现</strong>：栈辅助（递归&#x2F;迭代）</li><li><strong>应用</strong>：拓扑排序、连通分量检测</li></ul></li><li><p><strong>A* 算法</strong></p><ul><li><strong>特点</strong>：启发式搜索，综合实际代价和预估代价</li><li><strong>应用</strong>：游戏 AI 路径规划、地图导航</li></ul></li></ol><hr><h3 id="四、特殊结构搜索"><a href="#四、特殊结构搜索" class="headerlink" title="四、特殊结构搜索"></a>四、特殊结构搜索</h3><ol><li><p><strong>哈希查找</strong></p><ul><li><strong>特点</strong>：通过哈希函数直接定位桶</li><li><strong>时间复杂度</strong>：平均 O(1)，冲突时可能退化为 O(n)</li><li><strong>冲突处理</strong>：链地址法、开放寻址法</li></ul></li><li><p><strong>跳表（Skip List）</strong></p><ul><li><strong>特点</strong>：多层索引加速查找</li><li><strong>时间复杂度</strong>：O(logn)，媲美平衡树</li><li><strong>应用</strong>：Redis 有序集合</li></ul></li><li><p><strong>布隆过滤器（Bloom Filter）</strong></p><ul><li><strong>特点</strong>：概率型数据结构，判断「可能存在」或「一定不存在」</li><li><strong>应用</strong>：缓存穿透防护、爬虫 URL 去重</li></ul></li></ol><hr><h3 id="五、算法对比"><a href="#五、算法对比" class="headerlink" title="五、算法对比"></a>五、算法对比</h3><table><thead><tr><th>算法</th><th>时间复杂度</th><th>空间复杂度</th><th>数据要求</th></tr></thead><tbody><tr><td>线性搜索</td><td>O(n)</td><td>O(1)</td><td>无</td></tr><tr><td>二分搜索</td><td>O(logn)</td><td>O(1)</td><td><strong>必须有序</strong></td></tr><tr><td>哈希查找</td><td>O(1)</td><td>O(n)</td><td>需要哈希函数</td></tr><tr><td>BFS&#x2F;DFS</td><td>O(V+E)</td><td>O(V)</td><td>图结构</td></tr><tr><td>红黑树搜索</td><td>O(logn)</td><td>O(n)</td><td>动态数据集合</td></tr></tbody></table><hr><h3 id="六、选择建议"><a href="#六、选择建议" class="headerlink" title="六、选择建议"></a>六、选择建议</h3><ul><li><strong>小规模无序数据</strong>：线性搜索</li><li><strong>静态有序数据</strong>：二分搜索</li><li><strong>动态数据集合</strong>：平衡树（如红黑树）</li><li><strong>极速查询场景</strong>：哈希表（需处理冲突）</li><li><strong>路径&#x2F;关系分析</strong>：BFS&#x2F;DFS</li><li><strong>海量数据去重</strong>：布隆过滤器</li></ul><hr><h3 id="七、工程实践建议"><a href="#七、工程实践建议" class="headerlink" title="七、工程实践建议"></a>七、工程实践建议</h3><table><thead><tr><th>数据规模</th><th>推荐算法</th><th>典型场景</th></tr></thead><tbody><tr><td>n ≤ 20</td><td>线性搜索</td><td>配置参数、枚举值查找</td></tr><tr><td>20 &lt; n ≤ 100</td><td>实测对比选择</td><td>用户标签、本地缓存查询</td></tr><tr><td>n &gt; 100</td><td>二分&#x2F;哈希</td><td>数据库索引、大型数据集</td></tr></tbody></table>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;常见的搜索算法可分为基础查找算法、树结构搜索、图搜索和特殊结构搜索四大类，以下是主要分类及典型算法：&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;一、基础查找算法&quot;&gt;&lt;a href=&quot;#一、基础查找算法&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="算法" scheme="https://hmmmmmya.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>073-提高c++运行效率的操作</title>
    <link href="https://hmmmmmya.github.io/2025/02/12/073-%E6%8F%90%E9%AB%98cpp%E8%BF%90%E8%A1%8C%E6%95%88%E7%8E%87%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    <id>https://hmmmmmya.github.io/2025/02/12/073-%E6%8F%90%E9%AB%98cpp%E8%BF%90%E8%A1%8C%E6%95%88%E7%8E%87%E7%9A%84%E6%93%8D%E4%BD%9C/</id>
    <published>2025-02-12T03:26:10.000Z</published>
    <updated>2025-02-12T03:26:41.141Z</updated>
    
    <content type="html"><![CDATA[<p>C++ 提高运行效率的常见优化方法包括以下几类：</p><h3 id="1-数据结构优化"><a href="#1-数据结构优化" class="headerlink" title="1. 数据结构优化"></a>1. <strong>数据结构优化</strong></h3><ul><li><strong>选择合适的数据结构</strong>：根据具体应用选择 <code>std::vector</code>、<code>std::deque</code>、<code>std::list</code>、<code>std::unordered_map</code> 等。<ul><li>例如，<code>std::vector</code> 由于数据局部性好，通常比 <code>std::list</code> 更快（适用于频繁遍历的场景）。</li><li><code>std::unordered_map</code> 适用于快速查找，而 <code>std::map</code> 适用于有序存储。</li></ul></li><li>**使用 <code>std::bitset</code> 代替 <code>std::vector&lt;bool&gt;</code>**（你已经在用 <code>std::bitset</code>）。</li><li><strong>避免不必要的动态内存分配</strong>：可以使用 <code>std::array</code> 或 <code>std::vector::reserve()</code> 预分配空间。</li></ul><h3 id="2-算法优化"><a href="#2-算法优化" class="headerlink" title="2. 算法优化"></a>2. <strong>算法优化</strong></h3><ul><li><strong>减少不必要的计算</strong>：避免重复计算中间值，使用缓存（如 <code>std::unordered_map</code> 进行记忆化）。</li><li>**使用 <code>std::sort()</code> 而非 <code>qsort()</code>**：C++ 的 <code>std::sort()</code> 采用 introsort，比 C 语言的 <code>qsort()</code> 更快。</li><li><strong>使用合适的搜索和排序算法</strong>：如二分查找 (<code>std::lower_bound</code>)、快速排序、堆排序 (<code>std::priority_queue</code>)。</li></ul><h3 id="3-减少拷贝，提高内存管理效率"><a href="#3-减少拷贝，提高内存管理效率" class="headerlink" title="3. 减少拷贝，提高内存管理效率"></a>3. <strong>减少拷贝，提高内存管理效率</strong></h3><ul><li><strong>使用 <code>std::move</code> 和 <code>std::forward</code></strong> 避免不必要的拷贝：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span>;  <span class="comment">// 返回值优化（RVO），避免拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>**使用 <code>std::unique_ptr</code> 或 <code>std::shared_ptr</code>**，避免手动 <code>new/delete</code>。</li><li><strong>使用 <code>emplace_back</code> 代替 <code>push_back</code></strong> 避免额外拷贝：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; vec;</span><br><span class="line">vec.<span class="built_in">emplace_back</span>(<span class="string">&quot;hello&quot;</span>);  <span class="comment">// 直接构造，避免额外的拷贝</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="4-减少锁的争用"><a href="#4-减少锁的争用" class="headerlink" title="4. 减少锁的争用"></a>4. <strong>减少锁的争用</strong></h3><ul><li><strong>使用 <code>std::atomic</code> 代替锁</strong>（适用于简单的数据同步）。</li><li>**使用 <code>std::shared_mutex</code>**，在读多写少的情况下，减少锁的开销。</li><li><strong>缩小锁的粒度</strong>：尽量减少锁的持有时间，你已经考虑在 <code>VxiSession::ProcessData</code> 里用 <code>swap</code> 来减少锁的影响。</li></ul><h3 id="5-提高-CPU-缓存命中率"><a href="#5-提高-CPU-缓存命中率" class="headerlink" title="5. 提高 CPU 缓存命中率"></a>5. <strong>提高 CPU 缓存命中率</strong></h3><ul><li><strong>尽量使用连续存储的容器（如 <code>std::vector</code>）</strong>，避免 <code>std::list</code> 造成的缓存不友好情况。</li><li><strong>减少指针跳转</strong>，如避免 <code>std::list&lt;std::shared_ptr&lt;T&gt;&gt;</code> 这样的嵌套结构。</li><li><strong>使用 <code>restrict</code>（仅 C++20 的 <code>__restrict__</code> 关键字）</strong> 提示编译器优化指针别名分析。</li></ul><h3 id="6-编译优化"><a href="#6-编译优化" class="headerlink" title="6. 编译优化"></a>6. <strong>编译优化</strong></h3><ul><li><strong>使用 <code>-O2</code> 或 <code>-O3</code></strong> 进行编译优化（<code>g++ -O3</code>）。</li><li>**启用 <code>-march=native</code>**，让编译器生成针对本地 CPU 的优化指令。</li><li><strong>启用 LTO（链接时优化）</strong>：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -O3 -flto -march=native</span><br></pre></td></tr></table></figure></li><li><strong>使用 <code>constexpr</code></strong> 让编译期计算结果：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n &lt;= <span class="number">1</span>) ? <span class="number">1</span> : (n * <span class="built_in">factorial</span>(n - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> result = <span class="built_in">factorial</span>(<span class="number">5</span>);  <span class="comment">// 5! 在编译期计算</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="7-多线程优化"><a href="#7-多线程优化" class="headerlink" title="7. 多线程优化"></a>7. <strong>多线程优化</strong></h3><ul><li><strong>避免 false sharing（伪共享）</strong>：在多线程中，多个线程修改同一个缓存行可能导致性能下降，可以使用 <code>alignas(64)</code> 让数据对齐。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">64</span>) Data &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-内存管理优化"><a href="#8-内存管理优化" class="headerlink" title="8. 内存管理优化"></a>8. <strong>内存管理优化</strong></h3><ul><li><strong>减少 <code>new/delete</code> 调用</strong>：可以使用对象池（如 <code>boost::pool</code>）。</li><li><strong>使用 <code>std::vector::reserve()</code> 预分配内存</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">reserve</span>(<span class="number">1000</span>);  <span class="comment">// 预分配 1000 个元素，避免频繁扩容</span></span><br></pre></td></tr></table></figure></li><li><strong>使用 <code>std::string_view</code> 代替 <code>std::string</code> 进行字符串处理，避免拷贝</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(std::string_view str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello, world&quot;</span>);  <span class="comment">// 不会创建新的字符串对象</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;C++ 提高运行效率的常见优化方法包括以下几类：&lt;/p&gt;
&lt;h3 id=&quot;1-数据结构优化&quot;&gt;&lt;a href=&quot;#1-数据结构优化&quot; class=&quot;headerlink&quot; title=&quot;1. 数据结构优化&quot;&gt;&lt;/a&gt;1.</summary>
        
      
    
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>072-spdlog使用方法</title>
    <link href="https://hmmmmmya.github.io/2025/02/11/072-spdlog%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>https://hmmmmmya.github.io/2025/02/11/072-spdlog%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</id>
    <published>2025-02-11T06:11:19.000Z</published>
    <updated>2025-02-11T06:54:39.714Z</updated>
    
    <content type="html"><![CDATA[<p>Very fast, header only, C++ logging library.</p><span id="more"></span><ol><li><p>spdlog 的 github 项目地址 <a href="https://github.com/gabime/spdlog">https://github.com/gabime/spdlog</a></p></li><li><p>在右侧的 <code>releases</code> 中下载 Latest 版本.</p></li><li><p>解压后，将 <code>include</code> 目录下的 <code>spdlog</code> <strong>文件夹</strong>拷贝到项目中。注意: <code>spdlog</code>不是单头文件，而是文件夹。</p></li><li><p>在 <code>main.cpp</code> 中添加如下内容:</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spdlog/spdlog.h&quot;</span></span></span><br></pre></td></tr></table></figure><ol start="5"><li><p>生成 CMake</p><ul><li>5.1 CMake: Qucik Start</li><li>5.2 输入项目名</li><li>5.3 选择创建 c++项目</li><li>5.4 选择 CTest 作为测试支持, 也可以选择 CPack 来打包</li><li>5.5 创建可执行文件 Executable 或者 Library</li><li>5.6 选择或创建预设配置</li></ul></li><li><p>在 <code>CMakeLists.txt</code> 中添加如下内容:</p></li></ol><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置 spdlog 头文件路径，确保 spdlog 目录在根路径</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(hello PRIVATE <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>)</span><br></pre></td></tr></table></figure><p><code>Linux</code> 环境下, 在 <code>build</code> 目录下 <code>cmake .. &amp;&amp; make -j</code></p><ol start="7"><li>运行 <code>hello</code> 程序</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;Very fast, header only, C++ logging library.&lt;/p&gt;</summary>
    
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>071-windows编译运行c++项目</title>
    <link href="https://hmmmmmya.github.io/2025/01/16/071-windows%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8Ccpp%E9%A1%B9%E7%9B%AE/"/>
    <id>https://hmmmmmya.github.io/2025/01/16/071-windows%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8Ccpp%E9%A1%B9%E7%9B%AE/</id>
    <published>2025-01-16T10:00:19.000Z</published>
    <updated>2025-02-11T06:12:40.446Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>windows 11</li><li>cmake 3.31.0</li><li>mingw 8.1.0</li><li>vscode 1.86.1</li><li>vscode 插件<ul><li>CMake Tools（提供 CMake 支持）</li><li>C&#x2F;C++（提供代码补全和调试支持）</li><li>Code Runner（可选，用于快速运行程序）</li></ul></li></ul><p>环境配置参考 <a href="007_windows%E4%B8%8B%E6%90%AD%E5%BB%BACpp%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83.md">007-windows 下搭建 Cpp 编译环境</a></p><h2 id="步骤一-Create-a-project"><a href="#步骤一-Create-a-project" class="headerlink" title="步骤一: Create a project"></a>步骤一: Create a project</h2><p>创建一个 cpp 项目</p><h2 id="步骤二-Configure-a-project"><a href="#步骤二-Configure-a-project" class="headerlink" title="步骤二: Configure a project"></a>步骤二: Configure a project</h2><h3 id="2-1-创建-CMakeLists-txt"><a href="#2-1-创建-CMakeLists-txt" class="headerlink" title="2.1 创建 CMakeLists.txt"></a>2.1 创建 CMakeLists.txt</h3><ol><li>CMake: Quick Start</li><li>输入项目名</li><li>选择创建 c++项目</li><li>选择 CTest 作为测试支持, 也可以选择 CPack 来打包</li><li>创建可执行文件 Executable 或者 Library</li></ol><h3 id="2-2-创建-CMakePresets-json"><a href="#2-2-创建-CMakePresets-json" class="headerlink" title="2.2 创建 CMakePresets.json"></a>2.2 创建 CMakePresets.json</h3><p>创建 CMakePresets.json 预设配置</p><ol><li>创建新的预设</li><li>从编译器创建, 选择本地编译器 MinGW</li><li>命名预设</li></ol><p>或者选择已有预设配置</p><p>注: 此时应该生成了 CMakeLists.txt 和 CMakePresets.json 文件</p><h3 id="2-3-两者的关系"><a href="#2-3-两者的关系" class="headerlink" title="2.3 两者的关系"></a>2.3 两者的关系</h3><ol><li><p>CMakeLists.txt 是核心，cmakepresets.json 是辅助配置文件：</p><ul><li>CMakeLists.txt 决定了项目如何构建，包含了所有的构建规则。</li><li>cmakepresets.json 定义了如何调用 CMake 来处理这些规则。</li></ul></li><li><p>cmakepresets.json 简化了构建配置：</p><ul><li>开发者无需记住或输入复杂的命令行参数，可以直接选择预设。</li><li>预设适用于不同的开发环境、构建目标或用户配置。</li></ul></li><li><p>工作流程:</p><ul><li>CMake 读取 cmakepresets.json 来确定配置选项和生成器。</li><li>根据选定的预设调用 CMakeLists.txt，生成相应的构建系统。</li></ul></li><li><p>兼容性:</p><ul><li>cmakepresets.json 在 CMake 3.19 引入，推荐使用 CMake 3.21 或更高版本以获得更好的支持。</li><li>如果没有 cmakepresets.json，则可以通过命令行参数直接配置 CMake。</li></ul></li></ol><h2 id="步骤三-Build-a-project"><a href="#步骤三-Build-a-project" class="headerlink" title="步骤三: Build a project"></a>步骤三: Build a project</h2><h3 id="3-1-选择-CMake-Preset"><a href="#3-1-选择-CMake-Preset" class="headerlink" title="3.1 选择 CMake Preset"></a>3.1 选择 CMake Preset</h3><ol><li>打开 VSCode 的命令面板, 输入 CMake: Select Configure Preset。</li><li>选择 default（或你定义的其他 preset 名称）。</li></ol><h3 id="3-2-配置项目"><a href="#3-2-配置项目" class="headerlink" title="3.2 配置项目"></a>3.2 配置项目</h3><ol><li>打开命令面板, 输入 CMake: Configure。</li><li>VSCode 会自动运行 cmake，并根据你的 CMakePresets.json 配置项目。</li></ol><p>注: 生成 build 文件夹</p><h3 id="3-3-构建项目"><a href="#3-3-构建项目" class="headerlink" title="3.3 构建项目"></a>3.3 构建项目</h3><ol><li>打开命令面板, 输入 CMake: Build。</li><li>VSCode 会调用 CMake，使用 MinGW 编译你的项目。</li></ol><p>注: 构建成功显示 Build complete</p><h2 id="步骤四-Run-a-project"><a href="#步骤四-Run-a-project" class="headerlink" title="步骤四: Run a project"></a>步骤四: Run a project</h2><ol><li>打开命令面板, 输入 CMake: Run。</li><li>VSCode 会调用 CMake，使用 MinGW 编译你的项目。</li></ol><p>注: 运行成功会在 build 目录下生成可执行文件</p><h2 id="步骤五-调试"><a href="#步骤五-调试" class="headerlink" title="步骤五: 调试"></a>步骤五: 调试</h2><ol><li>确保你的项目生成了可执行文件（通常位于 build 文件夹）。</li><li>运行 -&gt; 启动调试 -&gt; 选择调试器 g++ -&gt; 生成 .&#x2F;vscode&#x2F;tasks.json</li><li>点击创建 launch.json</li><li>配置 launch.json（用于调试）： 打开 .vscode&#x2F;launch.json，并添加以下内容：</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Debug&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/build/your_program_name.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:/Software/mingw/mingw64/bin/gdb.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Enable pretty-printing for gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>启动调试：<ul><li>在调试面板点击“启动调试”（绿色三角形）。</li></ul></li></ol><p>补充：CMake 工具栏<br>在 VSCode 的状态栏下方，你可以看到由 CMake Tools 扩展提供的工具栏：</p><ul><li>[Select Kit]：选择编译器（一般选择 MinGW）。</li><li>[Build]：一键构建。</li><li>[Debug]：直接运行调试。</li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;windows 11&lt;/li&gt;
&lt;li&gt;cmake 3.31.0&lt;/li&gt;
&lt;li&gt;mingw</summary>
        
      
    
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>070-cpp提升效率的操作</title>
    <link href="https://hmmmmmya.github.io/2025/01/15/070-cpp%E6%8F%90%E5%8D%87%E6%95%88%E7%8E%87%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    <id>https://hmmmmmya.github.io/2025/01/15/070-cpp%E6%8F%90%E5%8D%87%E6%95%88%E7%8E%87%E7%9A%84%E6%93%8D%E4%BD%9C/</id>
    <published>2025-01-15T09:32:36.000Z</published>
    <updated>2025-01-16T06:27:39.409Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><ul><li>传递引用或者指针</li><li>使用 std::move 进行移动语义, 通过所有权的转移, 减少拷贝</li><li>使用 std::forward 进行完美转发</li></ul><h2 id="编译期优化"><a href="#编译期优化" class="headerlink" title="编译期优化"></a>编译期优化</h2><ul><li>内联函数 inline</li><li>模板和编译期常量计算<ul><li>使用模板元编程或 constexpr 将某些操作推迟到编译期，避免运行时计算。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">0</span> ? <span class="number">1</span> : n * <span class="built_in">factorial</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>避免不必要的动态分配<ul><li>尽量使用自动存储（栈）而非动态分配（堆），因为堆分配的开销更大。</li><li>使用标准容器（如 std::vector）时，可以通过 reserve 提前分配足够的内存。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">vec.<span class="built_in">reserve</span>(<span class="number">100</span>); <span class="comment">// 提前分配 100 个元素的内存</span></span><br></pre></td></tr></table></figure></li></ul></li><li>避免虚函数的性能开销<ul><li>如果类不需要继承和多态，尽量避免使用虚函数。</li><li>使用 final 关键字声明不可被继承的类，帮助编译器进行优化。</li></ul></li><li>使用轻量级数据结构<ul><li>选择合适的数据结构，如 std::array 代替 std::vector 用于固定大小的数组。</li><li>如果键值较少且固定，std::unordered_map 比 std::map 快。</li></ul></li></ul><h2 id="运行期优化"><a href="#运行期优化" class="headerlink" title="运行期优化"></a>运行期优化</h2><ul><li>使用移动语义<ul><li>在可能的情况下，使用移动构造函数和移动赋值运算符避免拷贝开销。</li><li>配合 std::move 显式触发移动语义。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">std::string str2 = std::<span class="built_in">move</span>(str1);  <span class="comment">// 移动而不是拷贝</span></span><br></pre></td></tr></table></figure></li></ul></li><li>智能指针管理资源<ul><li>使用 std::unique_ptr 和 std::shared_ptr 代替裸指针，可以提高资源管理效率，避免内存泄漏。</li><li>如果对象的生命周期明确，std::unique_ptr 的开销比 std::shared_ptr 更小。</li></ul></li><li>减少不必要的拷贝<ul><li>函数参数传递时，优先选择按引用传递而非按值传递。</li></ul></li><li>缓存优化<ul><li>数据访问尽量具有局部性（时间局部性和空间局部性），减少缓存未命中。</li><li>避免频繁分配和释放小块内存。</li></ul></li><li>并行化和多线程<ul><li>使用 C++ 标准库中的多线程工具（如 std::thread、std::async）提高并行执行效率。</li><li>结合线程池（如 std::thread_pool 或自定义线程池）处理高并发任务。</li></ul></li><li>避免不必要的同步<ul><li>在多线程场景中，避免对低冲突或读多写少的资源使用过多锁。</li><li>使用无锁数据结构（如 std::atomic）或读写锁提高效率。</li></ul></li></ul><p>总结</p><ul><li>代码设计：选择合适的数据结构和算法是效率优化的基础。</li><li>语言特性：利用 C++ 的现代特性（如移动语义、智能指针、constexpr）。</li><li>资源管理：减少不必要的分配与拷贝，合理使用线程和同步。</li><li>工具分析：结合性能分析工具，找到关键性能瓶颈，优化热点代码。</li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;ul&gt;
&lt;li&gt;传递引用或者指针&lt;/li&gt;
&lt;li&gt;使用 std::move 进行移动语义, 通过所有权的转移, 减少拷贝&lt;/li&gt;
&lt;li&gt;使用 std::forward 进行完美转发&lt;/li&gt;
&lt;/ul&gt;
&lt;h2</summary>
        
      
    
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>移动语义与完美转发</title>
    <link href="https://hmmmmmya.github.io/2025/01/15/069-%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E4%B8%8E%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/"/>
    <id>https://hmmmmmya.github.io/2025/01/15/069-%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E4%B8%8E%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/</id>
    <published>2025-01-15T09:30:18.000Z</published>
    <updated>2025-01-16T09:12:56.894Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// std::move 的实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type &amp;&amp;<span class="title">move</span><span class="params">(T &amp;&amp;param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> ReturnType = <span class="keyword">typename</span> remove_reference&lt;T&gt;::type &amp;&amp;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;ReturnType&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 remove_reference 去掉 T 的引用性质（并不会去掉 cv 限定符），然后给它加上 &amp;&amp;，形成 ReturnType 类型，由于右值引用类型的返回值是右值，因此结果是实参被无条件地转换为右值。</p><p>如果没有定义移动构造函数，则使用拷贝构造函数。</p><p>std::move 是一个模板函数，用于将对象转换为右值引用。它并不直接对对象、值或内存进行任何实际的移动操作。std::move 的作用是告诉编译器可以“窃取”对象的资源，因为对象不再需要保持其原始状态。</p><ol><li>对象转换：std::move 将一个左值（通常是一个命名对象）转换为右值引用。这种转换允许你调用对象的移动构造函数或移动赋值运算符。</li><li>资源转移：在使用 std::move 后，通常会调用对象的移动构造函数或移动赋值运算符，这些函数负责实际的资源转移（如指针、动态内存、文件句柄等）。</li><li>内存管理：std::move 本身不管理内存。内存的管理和资源的转移由移动构造函数或移动赋值运算符负责。</li><li>std::move 通常用于将左值转换为右值引用，以便能够调用对象的移动构造函数或移动赋值运算符。然而，对于纯右值（即临时对象或字面值），std::move 通常是不必要并且多余的，因为它们本身已经是右值。</li></ol><h2 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h2><p>保留参数的值类别（左值、右值），是否为 const 或 volatile 修饰符，并将其传递给其他函数。</p><p>std::forward 的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> T &gt;</span></span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp; t)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> T &gt;</span></span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp;&amp; t)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="怎么判断该用-move-还是-forward？"><a href="#怎么判断该用-move-还是-forward？" class="headerlink" title="怎么判断该用 move 还是 forward？"></a>怎么判断该用 move 还是 forward？</h2><ul><li>对右值引用 move<br>右值引用只能绑定到右值上，所以可以无条件地将它转换为右值</li><li>对通用引用 forward<br>通用引用既能绑定到左值上，也能绑定到右值上，在后一种情况下，我们希望能将它转换为右值</li><li>在右值引用上调用 std::forward 表现出的行为是正确的，但由于 std::forward 没法自动做类型推导，写出来的代码会比较繁琐；但如果在通用引用上调用 std::move，可能会导致左值被错误地修改，导致异常的行为。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.cnblogs.com/ljx-null/p/16512384.html">移动语义和完美转发浅析</a></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;移动语义&quot;&gt;&lt;a href=&quot;#移动语义&quot; class=&quot;headerlink&quot; title=&quot;移动语义&quot;&gt;&lt;/a&gt;移动语义&lt;/h2&gt;&lt;figure class=&quot;highlight</summary>
        
      
    
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/categories/c/"/>
    
    
    <category term="开箱即用" scheme="https://hmmmmmya.github.io/tags/%E5%BC%80%E7%AE%B1%E5%8D%B3%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>068-单例模式</title>
    <link href="https://hmmmmmya.github.io/2025/01/10/068-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://hmmmmmya.github.io/2025/01/10/068-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2025-01-10T02:08:54.000Z</published>
    <updated>2025-01-10T02:19:22.469Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式是一种设计模式，确保一个类只有一个实例，并提供一个全局访问点。</p><span id="more"></span><h2 id="懒汉模式-Meyers’-Singleton"><a href="#懒汉模式-Meyers’-Singleton" class="headerlink" title="懒汉模式(Meyers’ Singleton)"></a>懒汉模式(Meyers’ Singleton)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">static</span> Singleton obj;  <span class="comment">// 静态局部变量</span></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>; <span class="comment">// 显示拒绝拷贝构造和复制构造</span></span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="通用化"><a href="#通用化" class="headerlink" title="通用化"></a>通用化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> T&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> T t;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton instance;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton Singleton::instance;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;单例模式是一种设计模式，确保一个类只有一个实例，并提供一个全局访问点。&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://hmmmmmya.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="开箱即用" scheme="https://hmmmmmya.github.io/tags/%E5%BC%80%E7%AE%B1%E5%8D%B3%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>067-read/write和recv/send的区别</title>
    <link href="https://hmmmmmya.github.io/2024/12/28/067-read-write%E5%92%8Crecv-send%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://hmmmmmya.github.io/2024/12/28/067-read-write%E5%92%8Crecv-send%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2024-12-28T07:50:47.000Z</published>
    <updated>2024-12-28T07:51:05.065Z</updated>
    
    <content type="html"><![CDATA[<p><code>read()</code>&#x2F;<code>write()</code> 和 <code>recv()</code>&#x2F;<code>send()</code> 是用于数据传输的系统调用，但它们有一些区别：</p><ol><li><p><strong>通用性</strong>：</p><ul><li><code>read()</code> 和 <code>write()</code> 是通用的 I&#x2F;O 操作函数，可以用于文件、管道、套接字等各种文件描述符。</li><li><code>recv()</code> 和 <code>send()</code> 专门用于套接字操作，提供了一些额外的功能。</li></ul></li><li><p><strong>功能性</strong>：</p><ul><li><code>recv()</code> 和 <code>send()</code> 可以指定额外的标志（flags），如 <code>MSG_DONTWAIT</code>、<code>MSG_PEEK</code> 等，这些标志可以改变函数的行为。</li><li><code>read()</code> 和 <code>write()</code> 没有这些额外的标志。</li></ul></li><li><p><strong>参数</strong>：</p><ul><li><code>recv()</code> 和 <code>send()</code> 的参数中包含一个 <code>flags</code> 参数，用于指定操作的行为。</li><li><code>read()</code> 和 <code>write()</code> 没有 <code>flags</code> 参数。</li></ul></li><li><p><strong>使用场景</strong>：</p><ul><li>在网络编程中，通常使用 <code>recv()</code> 和 <code>send()</code>，因为它们提供了更灵活的控制。</li><li>对于文件 I&#x2F;O，通常使用 <code>read()</code> 和 <code>write()</code>。</li></ul></li></ol><p>总结来说，<code>recv()</code> 和 <code>send()</code> 是为网络编程设计的，提供了更多的控制选项，而 <code>read()</code> 和 <code>write()</code> 是更通用的 I&#x2F;O 操作函数。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;&lt;code&gt;read()&lt;/code&gt;&amp;#x2F;&lt;code&gt;write()&lt;/code&gt; 和 &lt;code&gt;recv()&lt;/code&gt;&amp;#x2F;&lt;code&gt;send()&lt;/code&gt;</summary>
        
      
    
    
    
    <category term="网络" scheme="https://hmmmmmya.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>066-生产者消费者模型</title>
    <link href="https://hmmmmmya.github.io/2024/12/13/066-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/"/>
    <id>https://hmmmmmya.github.io/2024/12/13/066-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/</id>
    <published>2024-12-13T07:47:25.000Z</published>
    <updated>2024-12-13T07:47:44.123Z</updated>
    
    <content type="html"><![CDATA[<p>要实现 SCPI 回复与请求的匹配，可以考虑使用生产者-消费者模式或线程间同步机制。以下是一个简化的实现思路：</p><ol><li><strong>使用队列</strong>：可以使用一个线程安全的队列来存储请求和对应的回复。</li><li><strong>生产者线程</strong>：负责发送 SCPI 命令并将请求信息（如请求 ID）放入队列。</li><li><strong>消费者线程</strong>：负责从队列中取出请求信息，等待并接收对应的回复。</li></ol><p>以下是一个简化的代码示例，展示如何使用 C++的线程和队列来实现这一模式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::queue&lt;std::pair&lt;<span class="type">int</span>, std::string&gt;&gt; request_queue;</span><br><span class="line">std::mutex queue_mutex;</span><br><span class="line">std::condition_variable queue_cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Producer</span><span class="params">(<span class="type">int</span> request_id, <span class="type">const</span> std::string&amp; command)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line">        request_queue.<span class="built_in">push</span>(&#123;request_id, command&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    queue_cv.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line">        queue_cv.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> !request_queue.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> request = request_queue.<span class="built_in">front</span>();</span><br><span class="line">        request_queue.<span class="built_in">pop</span>();</span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> request_id = request.first;</span><br><span class="line">        std::string command = request.second;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟发送命令并接收回复</span></span><br><span class="line">        std::string reply = <span class="string">&quot;Reply for &quot;</span> + command; <span class="comment">// 假设这是接收到的回复</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理回复</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Request ID: &quot;</span> &lt;&lt; request_id &lt;&lt; <span class="string">&quot;, Reply: &quot;</span> &lt;&lt; reply &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumer_thread</span><span class="params">(Consumer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟发送请求</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">Producer</span>(i, <span class="string">&quot;SCPI Command &quot;</span> + std::<span class="built_in">to_string</span>(i));</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    consumer_thread.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul><li><strong>生产者线程</strong>：<code>Producer</code>函数模拟发送 SCPI 命令，并将请求 ID 和命令放入队列。</li><li><strong>消费者线程</strong>：<code>Consumer</code>函数从队列中取出请求，模拟接收回复，并输出结果。</li><li><strong>线程同步</strong>：使用<code>std::mutex</code>和<code>std::condition_variable</code>来确保线程安全和同步。</li></ul><p>在实际应用中，你需要根据具体的 SCPI 命令和回复机制来调整代码，确保请求和回复能够正确匹配。可能还需要处理超时、错误等情况。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;要实现 SCPI</summary>
        
      
    
    
    
    <category term="设计模式" scheme="https://hmmmmmya.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>065-cpp-sleep</title>
    <link href="https://hmmmmmya.github.io/2024/12/12/065-cpp-sleep/"/>
    <id>https://hmmmmmya.github.io/2024/12/12/065-cpp-sleep/</id>
    <published>2024-12-12T08:41:36.000Z</published>
    <updated>2024-12-12T08:42:16.183Z</updated>
    
    <content type="html"><![CDATA[<h3 id="C-休眠函数"><a href="#C-休眠函数" class="headerlink" title="C++ 休眠函数"></a>C++ 休眠函数</h3><p>让我用中文解释这两种休眠方式的区别：</p><ol><li><code>std::this_thread::sleep_for</code></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>)); <span class="comment">// C++11 方式</span></span><br></pre></td></tr></table></figure><ul><li>这是 C++11 引入的现代休眠方法</li><li>跨平台兼容性好</li><li>可以使用不同的时间单位（毫秒、微秒、秒等）</li><li>提供类型安全</li><li>可以与其他 C++时间相关的功能无缝配合</li><li>精度依赖于操作系统实现</li></ul><ol start="2"><li><code>usleep</code></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">usleep</span>(<span class="number">100000</span>); <span class="comment">// 参数单位是微秒</span></span><br></pre></td></tr></table></figure><ul><li>POSIX 系统的传统 C 函数</li><li>只在 UNIX&#x2F;Linux 系统上可用</li><li>只接受微秒作为参数单位</li><li>参数类型是无符号整数</li><li>在某些系统上已经被废弃</li><li>可能会被信号中断</li></ul><p>建议：</p><ol><li>在现代 C++代码中，推荐使用<code>std::this_thread::sleep_for</code></li><li>如果是只针对 UNIX&#x2F;Linux 的老代码，<code>usleep</code>也是可以接受的</li><li>如果需要高精度定时，两者都不够理想，应该考虑使用专门的实时编程方案</li></ol><p>示例对比：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 现代C++方式，休眠100毫秒</span></span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统方式，休眠100毫秒</span></span><br><span class="line"><span class="built_in">usleep</span>(<span class="number">100</span> * <span class="number">1000</span>);  <span class="comment">// 需要自己转换单位</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h3 id=&quot;C-休眠函数&quot;&gt;&lt;a href=&quot;#C-休眠函数&quot; class=&quot;headerlink&quot; title=&quot;C++ 休眠函数&quot;&gt;&lt;/a&gt;C++</summary>
        
      
    
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>064-数据结构</title>
    <link href="https://hmmmmmya.github.io/2024/12/04/064-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://hmmmmmya.github.io/2024/12/04/064-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2024-12-04T01:36:39.000Z</published>
    <updated>2024-12-04T04:28:49.263Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常见概念"><a href="#常见概念" class="headerlink" title="常见概念"></a>常见概念</h2><h3 id="随机访问"><a href="#随机访问" class="headerlink" title="随机访问"></a>随机访问</h3><p>随机访问（Random Access）是指在数据结构中，可以在常数时间内（O(1)）直接访问任意一个元素，而不需要从头开始遍历数据结构。数组（Array）是支持随机访问的典型数据结构，因为可以通过<strong>索引</strong>(数据地址+偏移量)直接访问任意位置的元素。</p><p>在支持随机访问的数据结构中，元素的存储位置是连续的，这使得通过计算偏移量来直接定位元素成为可能。相比之下，链表（Linked List）不支持随机访问，因为访问某个元素需要从头开始逐个遍历，时间复杂度为 O(n)。</p><p>随机访问的优势在于其高效性，特别是在需要频繁访问或修改特定位置的元素时。然而，这种高效性通常是以牺牲插入和删除操作的效率为代价的，因为在数组中插入或删除元素可能需要移动大量数据。</p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="哈希表就是键值对吗"><a href="#哈希表就是键值对吗" class="headerlink" title="哈希表就是键值对吗"></a>哈希表就是键值对吗</h3><p>哈希表（Hash Table）确实是基于键值对（key-value pair）的一种数据结构。它通过一个哈希函数将键映射到一个数组中的位置，以便快速查找对应的值。以下是哈希表的一些关键特性：</p><ol><li><p><strong>键值对存储</strong>：哈希表中的每个元素都是一个键值对。键用于标识数据，值是与该键相关联的数据。</p></li><li><p><strong>快速查找</strong>：通过哈希函数，哈希表可以在平均情况下以常数时间复杂度（O(1)）进行查找、插入和删除操作。</p></li><li><p><strong>哈希冲突</strong>：由于不同的键可能映射到相同的哈希值，哈希表需要处理冲突。常见的冲突解决方法包括链地址法（使用链表存储冲突的元素）和开放地址法（在数组中寻找下一个空闲位置）。</p></li><li><p><strong>动态调整</strong>：为了保持高效性，哈希表通常会在负载因子（已存储元素数量与数组大小的比值）超过某个阈值时进行扩展和重哈希。</p></li></ol><p>因此，哈希表不仅仅是键值对的简单集合，它还包含了用于高效存储和检索的机制。</p><h3 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h3><p>哈希冲突（Hash Collision）是指在哈希表中，不同的键通过哈希函数映射到相同的哈希值或数组位置的情况。由于哈希表的核心是通过哈希函数将键映射到数组中的位置，因此冲突是不可避免的。处理哈希冲突的方法主要有以下几种：</p><ol><li><p><strong>链地址法（Separate Chaining）</strong>：</p><ul><li>在每个数组位置存储一个链表（或其他数据结构），所有映射到同一位置的元素都存储在这个链表中。</li><li>当发生冲突时，将新元素添加到链表中。</li><li>查找时，需要遍历链表来查找目标元素。</li></ul></li><li><p><strong>开放地址法（Open Addressing）</strong>：</p><ul><li>当发生冲突时，寻找数组中的下一个空闲位置来存储元素。</li><li>常见的开放地址法策略包括线性探测（Linear Probing）、二次探测（Quadratic Probing）和双重哈希（Double Hashing）。</li></ul></li><li><p><strong>再哈希（Rehashing）</strong>：</p><ul><li>当哈希表的负载因子超过某个阈值时，创建一个更大的哈希表，并将所有元素重新哈希到新的表中(扩容)。</li><li>这可以减少冲突的发生频率。</li></ul></li></ol><h4 id="扩容哈希表"><a href="#扩容哈希表" class="headerlink" title="扩容哈希表"></a>扩容哈希表</h4><p>负载因子定义为哈希表中元素数量除以桶数量，反映了哈希冲突的严重程度，常用作触发哈希表扩容的条件。</p><p>简单粗暴，但是效率低，因为哈希表扩容需要进行大量的数据搬运与哈希值计算。</p><p>改良哈希表数据结构，使得哈希表可以在出现哈希冲突时正常工作。</p><ul><li>仅在必要时，即当哈希冲突比较严重时，才执行扩容操作。</li><li>哈希表的结构改良方法主要包括“链式地址”和“开放寻址”。</li></ul><h4 id="链式地址的局限性"><a href="#链式地址的局限性" class="headerlink" title="链式地址的局限性"></a>链式地址的局限性</h4><ul><li>占用空间增大：链表包含节点指针，它相比数组更加耗费内存空间。</li><li>查询效率降低：因为需要线性遍历链表来查找对应元素。</li></ul><p>值得注意的是，当链表很长时，查询效率 O(n) 很差。此时可以将链表转换为“AVL 树”或“红黑树”，从而将查询操作的时间复杂度优化至 O(logn)。</p><h4 id="开放寻址的局限性"><a href="#开放寻址的局限性" class="headerlink" title="开放寻址的局限性"></a>开放寻址的局限性</h4><ul><li>线性探测容易产生“聚集现象”。数组中连续被占用的位置越长，这些连续位置发生哈希冲突的可能性越大，从而进一步促使该位置的聚堆生长，形成恶性循环，最终导致增删查改操作效率劣化。</li><li>负载因子不能太大，否则会降低查询效率。</li><li>删除元素比较麻烦，不能直接删除，需要惰性删除(lazy delete)。这是因为删除元素会在数组内产生一个空桶 None ，而当查询元素时，线性探测到该空桶就会返回，因此在该空桶之下的元素都无法再被访问到，程序可能误判这些元素不存在。<ul><li>惰性删除: 不直接从哈希表中移除元素，而是利用一个常量 TOMBSTONE 来标记这个桶。在该机制下，None 和 TOMBSTONE 都代表空桶，都可以放置键值对。但不同的是，线性探测到 TOMBSTONE 时应该继续遍历，因为其之下可能还存在键值对。</li></ul></li></ul><p>请注意，开放寻址（线性探测、平方探测和多次哈希）哈希表都存在“不能直接删除元素”的问题。</p><h3 id="怎么理解哈希的输入空间通常远大于输出空间（数组长度）"><a href="#怎么理解哈希的输入空间通常远大于输出空间（数组长度）" class="headerlink" title="怎么理解哈希的输入空间通常远大于输出空间（数组长度）"></a>怎么理解哈希的输入空间通常远大于输出空间（数组长度）</h3><p>哈希函数的输入空间通常远大于输出空间的原因在于，哈希函数需要将一个非常大的输入集合（如所有可能的字符串或整数）映射到一个相对较小的输出集合（如哈希表的数组索引）。这种映射过程不可避免地会导致哈希冲突，因为多个不同的输入可能会被映射到相同的输出值。</p><h4 id="理解这一点的几个关键点"><a href="#理解这一点的几个关键点" class="headerlink" title="理解这一点的几个关键点"></a>理解这一点的几个关键点</h4><ol><li><p><strong>输入空间的广泛性</strong>：</p><ul><li>输入空间可以是非常大的集合。例如，所有可能的字符串组合、所有可能的整数等。这些集合的大小通常是无限的或非常大的。</li></ul></li><li><p><strong>输出空间的有限性</strong>：</p><ul><li>输出空间是哈希表的大小，即数组的长度。这个长度是有限的，因为计算机的内存是有限的，哈希表的大小通常是一个固定的数值。</li></ul></li><li><p><strong>映射的必要性</strong>：</p><ul><li>哈希函数的作用是将大输入空间映射到小输出空间，以便在有限的内存中高效地存储和检索数据。</li></ul></li><li><p><strong>冲突的不可避免性</strong>：</p><ul><li>由于输入空间远大于输出空间，必然会有不同的输入映射到相同的输出值，这就是哈希冲突。</li></ul></li></ol><h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><p>假设你有一个哈希表，其数组长度为 1000（输出空间），而你需要存储的可能输入是所有可能的 32 位整数（输入空间）。32 位整数的可能值有 2^32 个（约 43 亿），显然远大于 1000。因此，多个不同的整数可能会映射到同一个数组索引，导致冲突。</p><p>这种映射机制是哈希表设计中的一个基本挑战，处理冲突的方法（如链地址法和开放地址法）就是为了解决这个问题。</p><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>递: 向下<br>归: 向上</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆是一种特殊的树形数据结构，其中每个节点都满足特定的堆性质。堆通常用于实现优先队列（Priority Queue），因为它可以高效地支持插入和删除操作，同时保持元素的有序性。</p><p>堆有两种主要类型：</p><ul><li>最大堆（Max Heap）：在最大堆中，每个节点的值都大于或等于其子节点的值。</li><li>最小堆（Min Heap）：在最小堆中，每个节点的值都小于或等于其子节点的值。</li></ul><p>Q：数据结构的“堆”与内存管理的“堆”是同一个概念吗？</p><p>两者不是同一个概念，只是碰巧都叫“堆”。</p><p>数据结构的“堆”是基于数组实现的树形数据结构，而内存管理的“堆”是内存管理机制。</p><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;常见概念&quot;&gt;&lt;a href=&quot;#常见概念&quot; class=&quot;headerlink&quot; title=&quot;常见概念&quot;&gt;&lt;/a&gt;常见概念&lt;/h2&gt;&lt;h3 id=&quot;随机访问&quot;&gt;&lt;a href=&quot;#随机访问&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="数据结构与算法" scheme="https://hmmmmmya.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>063-模板</title>
    <link href="https://hmmmmmya.github.io/2024/12/03/063-%E6%A8%A1%E6%9D%BF/"/>
    <id>https://hmmmmmya.github.io/2024/12/03/063-%E6%A8%A1%E6%9D%BF/</id>
    <published>2024-12-03T07:45:01.000Z</published>
    <updated>2024-12-03T07:46:04.566Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模板参数会保留其传入类型的所有修饰符"><a href="#模板参数会保留其传入类型的所有修饰符" class="headerlink" title="模板参数会保留其传入类型的所有修饰符"></a>模板参数会保留其传入类型的所有修饰符</h2><p>在 C++中，模板参数会保留其传入类型的所有修饰符，包括<code>const</code>和引用（<code>&amp;</code>或<code>&amp;&amp;</code>）。这意味着如果你传递一个<code>const</code>类型或引用类型作为模板参数，模板会保留这些修饰符。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T param)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// param的类型会保留T的所有修饰符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">func</span>(a); <span class="comment">// T为const int</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">func</span>(b); <span class="comment">// T为int</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>&amp; c = b;</span><br><span class="line">    <span class="built_in">func</span>(c); <span class="comment">// T为int&amp;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; d = a;</span><br><span class="line">    <span class="built_in">func</span>(d); <span class="comment">// T为const int&amp;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>func</code>函数的模板参数<code>T</code>会保留传入参数的<code>const</code>和引用修饰符。因此，<code>T</code>的类型会根据传入的参数类型而有所不同。</p><p>如果你希望在模板中去掉这些修饰符，可以使用标准库中的类型萃取工具，如<code>std::remove_const</code>和<code>std::remove_reference</code>。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> PlainType = <span class="keyword">typename</span> std::remove_const&lt;<span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&gt;::type;</span><br><span class="line">    <span class="comment">// PlainType是去掉const和引用后的基本类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，你可以在模板中根据需要处理类型的修饰符。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;模板参数会保留其传入类型的所有修饰符&quot;&gt;&lt;a href=&quot;#模板参数会保留其传入类型的所有修饰符&quot; class=&quot;headerlink&quot; title=&quot;模板参数会保留其传入类型的所有修饰符&quot;&gt;&lt;/a&gt;模板参数会保留其传入类型的所有修饰符&lt;/h2&gt;&lt;p&gt;在</summary>
        
      
    
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>062-const</title>
    <link href="https://hmmmmmya.github.io/2024/12/03/062-const/"/>
    <id>https://hmmmmmya.github.io/2024/12/03/062-const/</id>
    <published>2024-12-03T06:45:08.000Z</published>
    <updated>2024-12-03T07:45:27.141Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本数据类型和字面值-直接传值-不要使用const"><a href="#基本数据类型和字面值-直接传值-不要使用const" class="headerlink" title="基本数据类型和字面值, 直接传值, 不要使用const&amp;"></a>基本数据类型和字面值, 直接传值, 不要使用<code>const&amp;</code></h2><p>在 C++中，<code>const&amp;</code>通常用于避免拷贝传递参数，尤其是对于较大的对象。然而，对于基本数据类型（如<code>int</code>、<code>float</code>等），传递它们的引用（包括<code>const&amp;</code>）通常没有太大意义，因为它们本身就很小，拷贝的开销很低。对于基本数据类型，这种做法是可以的，但并不是必要的。你可以直接传值而不是引用，尤其是当你传递的是字面值（如<code>0</code>和<code>1</code>）时。</p><p>即: 基本数据类型和字面值, 直接传值, 不要使用<code>const&amp;</code></p><h2 id="函数参数使用const"><a href="#函数参数使用const" class="headerlink" title="函数参数使用const"></a>函数参数使用<code>const</code></h2><p>在 C++中，使用<code>const</code>来修饰函数参数可以防止在函数内部修改这些参数的值。对于基本数据类型（如<code>int</code>、<code>float</code>等），使用<code>const</code>来修饰传值参数通常没有太大意义，因为传值本身就意味着在函数内部的修改不会影响到外部。</p><p>然而，如果你希望明确表达参数在函数内部不应被修改的意图，或者为了代码的一致性，你可以使用<code>const</code>来修饰传值参数。这样做不会影响性能或功能，但可以提高代码的可读性。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;基本数据类型和字面值-直接传值-不要使用const&quot;&gt;&lt;a href=&quot;#基本数据类型和字面值-直接传值-不要使用const&quot; class=&quot;headerlink&quot; title=&quot;基本数据类型和字面值, 直接传值,</summary>
        
      
    
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>061-右值引用</title>
    <link href="https://hmmmmmya.github.io/2024/12/02/061-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
    <id>https://hmmmmmya.github.io/2024/12/02/061-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</id>
    <published>2024-12-02T09:22:34.000Z</published>
    <updated>2025-01-16T03:28:59.804Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="左值与右值"><a href="#左值与右值" class="headerlink" title="左值与右值"></a>左值与右值</h2><p>C++ 中值有两个独立的属性：有地址的值(gvalue)和可以被移动的值(rvalue)</p><ol><li><p>有地址 + 不能移动 &#x3D; 左值(lvalue)</p></li><li><p>有地址 + 可以移动 &#x3D; 将亡值(xvalue), 包括: 右值引用类型的返回值，比如 <code>std::move(x)</code></p></li><li><p>没有地址 + 可以移动 &#x3D; 纯右值(prvalue), 包括:</p><ul><li>字面量，比如 <code>42</code></li><li>临时对象，比如 <code>1 + 2</code></li><li>this 指针</li></ul></li><li><p>没有地址 + 不能移动, 目前没有用到</p></li></ol><p>总之, 一个值是左值还是右值，取决于它的地址是否可以被获取。大多数时候只需要区分一个值是左值还是右值即可。</p><h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><p>右值引用是 C++11 引入的一种引用类型，用于表示对右值的引用。右值引用可以绑定到右值，但不能绑定到左值。右值引用通常用于实现移动语义和完美转发。</p><ul><li>右值引用只能绑定到右值上，比如 <code>int &amp;&amp;</code></li><li>左值引用只能绑定到左值上，比如 <code>int &amp;</code></li><li>const 的左值引用可以绑定到左值或右值上，比如 <code>const int &amp;</code></li></ul><h2 id="移动构造函数和移动赋值运算符"><a href="#移动构造函数和移动赋值运算符" class="headerlink" title="移动构造函数和移动赋值运算符"></a>移动构造函数和移动赋值运算符</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    string s&#123;&#125;;</span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt; pi&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Move constructor</span></span><br><span class="line">    <span class="built_in">Widget</span>(Widget &amp;&amp;w) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Move assignment operator</span></span><br><span class="line">    Widget &amp;<span class="keyword">operator</span>=(Widget &amp;&amp;w) = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>移动操作和异常安全</p><ul><li>移动操作一般不分配新资源，因此不会抛出异常</li><li>如果移动操作不抛异常，必须注明 noexcept</li></ul><h2 id="通用引用和引用折叠"><a href="#通用引用和引用折叠" class="headerlink" title="通用引用和引用折叠"></a>通用引用和引用折叠</h2><h3 id="通用引用"><a href="#通用引用" class="headerlink" title="通用引用"></a>通用引用</h3><p>通用引用是一种既可以绑定到左值，又可以绑定到右值的引用类型，其本质是一个模板参数化的右值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;  <span class="comment">// T&amp;&amp; 是通用引用</span></span><br><span class="line">    <span class="comment">// arg 既可以接受左值，也可以接受右值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h3><p>引用折叠规则:</p><ol><li><p>左值引用（&amp;）优先级高于右值引用（&amp;&amp;）。</p></li><li><p>以下是所有的折叠情况：</p><ul><li>T&amp; &amp; → T&amp;</li><li>T&amp; &amp;&amp; → T&amp;</li><li>T&amp;&amp; &amp; → T&amp;</li><li>T&amp;&amp; &amp;&amp; → T&amp;&amp;</li></ul></li></ol><h2 id="remove-reference"><a href="#remove-reference" class="headerlink" title="remove_reference"></a>remove_reference</h2><p>std::remove_reference 是 C++ 标准库中的一个类型特性（type trait），定义在头文件 <type_traits> 中。它的主要作用是移除类型中的引用部分（包括左值引用 &amp; 和右值引用 &amp;&amp;），返回原始类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">remove_reference</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">remove_reference</span>&lt;T&amp;&gt; &#123;</span><br><span class="line">    <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">remove_reference</span>&lt;T&amp;&amp;&gt; &#123;</span><br><span class="line">    <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>常用场景: 类型推导、模板元编程、完美转发等。</p><p>总结</p><ul><li>std::remove_reference 是一个编译期工具，通过模板特化对类型进行处理。</li><li>它不会在运行时产生临时变量，也不会涉及任何值类别的转换。</li><li>编译器只会根据类型推导规则替换类型，例如将 int&amp; 转换为 int，最终生成相应的代码。</li><li>不会去掉 const 和 volatile 修饰符</li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;左值与右值&quot;&gt;&lt;a href=&quot;#左值与右值&quot; class=&quot;headerlink&quot; title=&quot;左值与右值&quot;&gt;&lt;/a&gt;左值与右值&lt;/h2&gt;&lt;p&gt;C++</summary>
        
      
    
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>060-cpp成员函数</title>
    <link href="https://hmmmmmya.github.io/2024/12/02/060-cpp%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/"/>
    <id>https://hmmmmmya.github.io/2024/12/02/060-cpp%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</id>
    <published>2024-12-02T08:25:50.000Z</published>
    <updated>2024-12-03T07:45:43.158Z</updated>
    
    <content type="html"><![CDATA[<p>在 C++中，类的成员函数通常包括以下几种类型：</p><ol><li><p><strong>构造函数（Constructor）</strong>：</p><ul><li>用于初始化对象。构造函数的名称与类名相同，没有返回类型。</li><li>可以有多个构造函数（重载），以支持不同的初始化方式。</li></ul></li><li><p><strong>析构函数（Destructor）</strong>：</p><ul><li>用于清理对象。析构函数的名称是类名的前面加上波浪号（~），没有返回类型，也没有参数。</li><li>在对象生命周期结束时自动调用。</li></ul></li><li><p><strong>拷贝构造函数（Copy Constructor）</strong>：</p><ul><li>用于复制对象。通常用于对象的复制初始化。</li><li>形如：<code>ClassName(const ClassName &amp;other)</code></li></ul></li><li><p><strong>赋值运算符重载（Assignment Operator Overload）</strong>：</p><ul><li>用于对象的赋值操作。</li><li>形如：<code>ClassName&amp; operator=(const ClassName &amp;other)</code></li></ul></li><li><p><strong>移动构造函数（Move Constructor）</strong>：</p><ul><li>用于移动语义，提高性能。</li><li>形如：<code>ClassName(ClassName &amp;&amp;other)</code></li></ul></li><li><p><strong>移动赋值运算符重载（Move Assignment Operator Overload）</strong>：</p><ul><li>用于移动语义的赋值操作。</li><li>形如：<code>ClassName&amp; operator=(ClassName &amp;&amp;other)</code></li></ul></li><li><p><strong>访问器（Accessors）</strong>：</p><ul><li>用于获取对象的私有成员变量的值。</li><li>通常是<code>const</code>函数，不修改对象的状态。</li></ul></li><li><p><strong>修改器（Mutators）</strong>：</p><ul><li>用于设置对象的私有成员变量的值。</li><li>通常会对输入值进行验证。</li></ul></li><li><p><strong>静态成员函数（Static Member Functions）</strong>：</p><ul><li>不依赖于对象实例，可以通过类名直接调用。</li><li>不能访问非静态成员变量。</li></ul></li><li><p><strong>友元函数（Friend Functions）</strong>：</p><ul><li>不是类的成员，但可以访问类的私有和保护成员。</li><li>通过<code>friend</code>关键字声明。</li></ul></li><li><p><strong>虚函数（Virtual Functions）</strong>：</p><ul><li>用于实现多态行为。</li><li>在基类中声明为<code>virtual</code>，在派生类中可以重写。</li></ul></li><li><p><strong>常成员函数（Const Member Functions）</strong>：</p><ul><li>不修改对象的状态。</li><li>在函数声明后加上<code>const</code>关键字。</li></ul></li></ol><p>这些成员函数的具体实现和使用取决于类的设计需求和功能。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在</summary>
        
      
    
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>059-int赋值给char</title>
    <link href="https://hmmmmmya.github.io/2024/11/30/059-int%E8%B5%8B%E5%80%BC%E7%BB%99char/"/>
    <id>https://hmmmmmya.github.io/2024/11/30/059-int%E8%B5%8B%E5%80%BC%E7%BB%99char/</id>
    <published>2024-11-30T08:28:46.000Z</published>
    <updated>2025-01-06T03:06:12.384Z</updated>
    
    <content type="html"><![CDATA[<h3 id="int-直接赋值给-char-会怎么样"><a href="#int-直接赋值给-char-会怎么样" class="headerlink" title="int 直接赋值给 char 会怎么样"></a>int 直接赋值给 char 会怎么样</h3><p>在 C++中，将一个 <code>int</code> 类型的值直接赋值给一个 <code>char</code> 类型的变量时，可能会发生以下情况：</p><ol><li><p><strong>截断</strong>：<code>char</code> 类型通常是 1 字节（8 位），而 <code>int</code> 类型通常是 4 字节（32 位）或更多。因此，当 <code>int</code> 的值超出 <code>char</code> 的表示范围时，只有最低的 8 位会被保留，其余的位会被截断。这可能导致数据丢失或值的改变。</p></li><li><p><strong>符号扩展</strong>：如果 <code>char</code> 是有符号的（<code>signed char</code>），并且 <code>int</code> 的值超出了 <code>char</code> 的正数范围（通常是 -128 到 127），则可能会导致符号扩展问题，导致负值。</p></li><li><p><strong>未定义行为</strong>：如果 <code>int</code> 的值超出了 <code>char</code> 的表示范围，可能会导致未定义行为，具体表现取决于编译器和平台。</p></li></ol><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> largeValue = <span class="number">300</span>;</span><br><span class="line"><span class="type">char</span> smallValue = largeValue; <span class="comment">// smallValue 可能会变成 44，因为 300 的最低 8 位是 44</span></span><br></pre></td></tr></table></figure><p>为了避免这些问题，通常建议在赋值前进行显式的类型转换，并确保值在目标类型的范围内：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> largeValue = <span class="number">300</span>;</span><br><span class="line"><span class="type">char</span> smallValue = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(largeValue &amp; <span class="number">0xFF</span>); <span class="comment">// 只保留最低的 8 位</span></span><br></pre></td></tr></table></figure><p>这样可以确保程序的行为是可预测的。</p><p>总结: 从二进制角度来看, int 是 32 位, char 是 8 位, 不要直接将 int 赋值给 char, 要进行类型转换, <strong>只保留最低的 8 位</strong>.</p><h3 id="int-1-和-char-‘1’-的主要区别"><a href="#int-1-和-char-‘1’-的主要区别" class="headerlink" title="int(1) 和 char(‘1’) 的主要区别"></a>int(1) 和 char(‘1’) 的主要区别</h3><ol><li><strong>数值表示</strong>：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">1</span>;     <span class="comment">// 数值1，二进制为 00000001</span></span><br><span class="line"><span class="type">char</span> c = <span class="string">&#x27;1&#x27;</span>;    <span class="comment">// 字符&#x27;1&#x27;，ASCII码为49（二进制 00110001）</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>内存占用</strong>：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;int大小: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; <span class="string">&quot;字节&quot;</span> &lt;&lt; std::endl;    <span class="comment">// 通常是4字节</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;char大小: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span>) &lt;&lt; <span class="string">&quot;字节&quot;</span> &lt;&lt; std::endl;   <span class="comment">// 1字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>使用场景示例</strong>：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">1</span>;      <span class="comment">// 用于数学计算</span></span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;1&#x27;</span>;     <span class="comment">// 用于字符表示</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数学运算</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;num + 1 = &quot;</span> &lt;&lt; num + <span class="number">1</span> &lt;&lt; std::endl;        <span class="comment">// 输出：2</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c + 1 = &quot;</span> &lt;&lt; c + <span class="number">1</span> &lt;&lt; std::endl;           <span class="comment">// 输出：50 (ASCII 49 + 1)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符输出</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;num as char: &quot;</span> &lt;&lt; (<span class="type">char</span>)num &lt;&lt; std::endl;   <span class="comment">// 输出：SOH (不可打印字符)</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c as char: &quot;</span> &lt;&lt; c &lt;&lt; std::endl;            <span class="comment">// 输出：1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ASCII值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c的ASCII值: &quot;</span> &lt;&lt; (<span class="type">int</span>)c &lt;&lt; std::endl;      <span class="comment">// 输出：49</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要区别总结：</p><ol><li><p><strong>本质区别</strong>：</p><ul><li><code>int(1)</code> 是数值 1, 二进制为 00000000 00000000 00000000 00000001</li><li><code>char(&#39;1&#39;)</code> 是字符’1’的 ASCII 码值 49, 二进制为 00110001</li><li><code>char(1)</code> 是二进制 00000001</li></ul></li><li><p><strong>用途区别</strong>：</p><ul><li><code>int</code> 主要用于数值计算</li><li><code>char</code> 主要用于字符表示</li></ul></li><li><p><strong>存储区别</strong>：</p><ul><li><code>int</code> 通常占 4 字节</li><li><code>char</code> 占 1 字节</li></ul></li><li><p><strong>表示范围</strong>：</p><ul><li><code>int</code> 通常范围是 -2147483648 到 2147483647</li><li><code>char</code> 范围是 -128 到 127（unsigned char 是 0 到 255）</li></ul></li><li><p><strong>转换注意事项</strong>：</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="type">char</span> c = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换示例</span></span><br><span class="line"><span class="type">int</span> num_from_char = c - <span class="string">&#x27;0&#x27;</span>;    <span class="comment">// 字符转数字：49 - 48 = 1</span></span><br><span class="line"><span class="type">char</span> char_from_int = num + <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 数字转字符：1 + 48 = &#x27;1&#x27;</span></span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;字符&#x27;1&#x27;转换为数字: &quot;</span> &lt;&lt; num_from_char &lt;&lt; std::endl;  <span class="comment">// 输出：1</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;数字1转换为字符: &quot;</span> &lt;&lt; char_from_int &lt;&lt; std::endl;    <span class="comment">// 输出：1</span></span><br></pre></td></tr></table></figure><p>这些区别在处理数值计算和字符串操作时特别重要，尤其是在：</p><ul><li>数字字符串转换为实际数值</li><li>格式化输出</li><li>文件操作</li><li>用户输入处理</li></ul><p>等场景中需要特别注意。</p><h3 id="static-cast-和-static-cast-largeValue-0xFF"><a href="#static-cast-和-static-cast-largeValue-0xFF" class="headerlink" title="static_cast 和 static_cast(largeValue &amp; 0xFF)"></a>static_cast<char> 和 static_cast<char>(largeValue &amp; 0xFF)</h3><ol><li><strong>简单的 static_cast<char></strong>:</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> largeValue = <span class="number">300</span>;</span><br><span class="line"><span class="type">char</span> c1 = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(largeValue);  <span class="comment">// 可能导致未定义行为</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>使用位掩码的 static_cast<char>(largeValue &amp; 0xFF)</strong>:</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> largeValue = <span class="number">300</span>;</span><br><span class="line"><span class="type">char</span> c2 = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(largeValue &amp; <span class="number">0xFF</span>);  <span class="comment">// 安全地截取最后8位</span></span><br></pre></td></tr></table></figure><p>主要区别：</p><ol><li><strong>数值范围处理</strong>：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> largeValue = <span class="number">300</span>;  <span class="comment">// 二进制：0000 0001 0010 1100</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法1：直接转换</span></span><br><span class="line">    <span class="type">char</span> c1 = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(largeValue);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;直接转换结果: &quot;</span> &lt;&lt; (<span class="type">int</span>)c1 &lt;&lt; std::endl;  <span class="comment">// 结果不确定</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法2：使用位掩码</span></span><br><span class="line">    <span class="type">char</span> c2 = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(largeValue &amp; <span class="number">0xFF</span>);  <span class="comment">// 只保留最后8位：0010 1100</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;位掩码转换结果: &quot;</span> &lt;&lt; (<span class="type">int</span>)c2 &lt;&lt; std::endl;  <span class="comment">// 输出：44</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>安全性比较</strong>：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">demonstrateCasting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 超出char范围的值</span></span><br><span class="line">    <span class="type">int</span> values[] = &#123;<span class="number">128</span>, <span class="number">255</span>, <span class="number">256</span>, <span class="number">300</span>, <span class="number">-129</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> val : values) &#123;</span><br><span class="line">        <span class="comment">// 直接转换 - 可能导致未定义行为</span></span><br><span class="line">        <span class="type">char</span> direct = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用位掩码 - 安全地截取最后8位</span></span><br><span class="line">        <span class="type">char</span> masked = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(val &amp; <span class="number">0xFF</span>);</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;原值: &quot;</span> &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;直接转换: &quot;</span> &lt;&lt; (<span class="type">int</span>)direct &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;位掩码转换: &quot;</span> &lt;&lt; (<span class="type">int</span>)masked &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;-------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要区别总结：</p><ol><li><p><strong>安全性</strong>：</p><ul><li><code>static_cast&lt;char&gt;</code> 在值超出 char 范围时可能导致未定义行为</li><li><code>static_cast&lt;char&gt;(value &amp; 0xFF)</code> 总是安全地截取最后 8 位</li></ul></li><li><p><strong>值范围</strong>：</p><ul><li><code>static_cast&lt;char&gt;</code> 不保证结果在 char 的有效范围内</li><li><code>static_cast&lt;char&gt;(value &amp; 0xFF)</code> 保证结果在 0-255 之间</li></ul></li><li><p><strong>使用场景</strong>：</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">example</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 适合使用直接转换的场景</span></span><br><span class="line">    <span class="type">int</span> smallValue = <span class="number">65</span>;</span><br><span class="line">    <span class="type">char</span> c1 = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(smallValue);  <span class="comment">// 转换&#x27;A&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 适合使用位掩码的场景</span></span><br><span class="line">    <span class="type">int</span> networkByte = <span class="number">0x1234</span>;</span><br><span class="line">    <span class="type">char</span> lowByte = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(networkByte &amp; <span class="number">0xFF</span>);  <span class="comment">// 获取最低字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>位操作说明</strong>：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0xFF的作用演示</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">explainBitMask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">300</span>;  <span class="comment">// 二进制：0000 0001 0010 1100</span></span><br><span class="line">    <span class="type">int</span> masked = value &amp; <span class="number">0xFF</span>;  <span class="comment">// 0xFF = 0000 0000 1111 1111</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结果只保留最后8位：0010 1100 (44在十进制中)</span></span><br><span class="line">    <span class="type">char</span> result = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(masked);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;原始值: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;掩码后: &quot;</span> &lt;&lt; (<span class="type">int</span>)result &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建议：</p><ul><li>当确定输入值在 char 范围内时，可以使用简单的<code>static_cast&lt;char&gt;</code></li><li>处理可能超出范围的值时，应使用<code>static_cast&lt;char&gt;(value &amp; 0xFF)</code></li><li>在处理网络字节序或二进制数据时，位掩码方式特别有用</li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h3 id=&quot;int-直接赋值给-char-会怎么样&quot;&gt;&lt;a href=&quot;#int-直接赋值给-char-会怎么样&quot; class=&quot;headerlink&quot; title=&quot;int 直接赋值给 char 会怎么样&quot;&gt;&lt;/a&gt;int 直接赋值给 char 会怎么样&lt;/h3&gt;&lt;p&gt;在</summary>
        
      
    
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>058-design-patterns-learning</title>
    <link href="https://hmmmmmya.github.io/2024/11/28/058-design-patterns-learning/"/>
    <id>https://hmmmmmya.github.io/2024/11/28/058-design-patterns-learning/</id>
    <published>2024-11-28T09:04:03.000Z</published>
    <updated>2024-11-29T01:58:16.112Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h3><ul><li><a href="https://refactoringguru.cn/design-patterns/cpp">refactoringguru 设计模式</a></li><li><a href="https://design-patterns.readthedocs.io/zh-cn/latest/index.html">图说设计模式</a></li><li><a href="https://www.geeksforgeeks.org/introduction-to-pattern-designing/">GeeksforGeeks 设计模式</a></li></ul><h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><ul><li><a href="https://www.bilibili.com/video/BV1Zd4y1t7HK/?vd_source=afd9bb086cf8c56bfa160a01bb00e8d8">设计模式-阿西拜编程</a></li></ul><h3 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h3><ul><li><a href="https://github.com/kamranahmedse/design-patterns-for-humans">design-patterns-for-humans</a></li><li><a href="https://github.com/JakubVojvoda/design-patterns-cpp?tab=readme-ov-file">design-patterns-cpp</a></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;设计模式&quot;&gt;&lt;a href=&quot;#设计模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式&quot;&gt;&lt;/a&gt;设计模式&lt;/h2&gt;&lt;h3 id=&quot;网站&quot;&gt;&lt;a href=&quot;#网站&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="learning" scheme="https://hmmmmmya.github.io/categories/learning/"/>
    
    
  </entry>
  
  <entry>
    <title>057-nlohmann_json库的使用</title>
    <link href="https://hmmmmmya.github.io/2024/11/22/057-nlohmann-json%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://hmmmmmya.github.io/2024/11/22/057-nlohmann-json%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2024-11-22T07:54:26.000Z</published>
    <updated>2024-12-11T03:28:36.964Z</updated>
    
    <content type="html"><![CDATA[<h2 id="json-hpp-库下载及安装"><a href="#json-hpp-库下载及安装" class="headerlink" title="json.hpp 库下载及安装"></a>json.hpp 库下载及安装</h2><p>nlohmann json 的开源项目地址：</p><p><a href="https://github.com/nlohmann/json#serialization%E2%80%93deserialization">https://github.com/nlohmann/json#serialization–deserialization</a></p><p>对于我们项目中要使用 nlohmann json 工具，只需要引入 json.hpp 这一个文件，其中包含所有接口函数，正如其文档中所述 json.hpp 文件在 single_include&#x2F;nlohmann 目录下，我们只需要下载该文件即可：</p><p>git clone <a href="https://github.com/nlohmann/json/blob/develop/single_include/nlohmann/json.hpp">https://github.com/nlohmann/json/blob/develop/single_include/nlohmann/json.hpp</a></p><p>注意：不是 include&#x2F;nlohmann&#x2F;json.hpp，而是 single_include&#x2F;nlohmann&#x2F;json.hpp，前者要包含整个文件夹，后者只需要包含 json.hpp 文件。</p><h2 id="用-json-赋值"><a href="#用-json-赋值" class="headerlink" title="用 json 赋值"></a>用 json 赋值</h2><p>在使用 nlohmann JSON 库时，如果 JSON 中存储的类型与要赋值的变量类型一致，通常不需要显式地使用 <code>get&lt;&gt;()</code> 进行类型转换。<code>at()</code> 方法会返回一个 JSON 值对象，该对象可以直接赋值给与其类型兼容的变量。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;nlohmann/json.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    nlohmann::json j;</span><br><span class="line">    j[<span class="string">&quot;pi&quot;</span>] = <span class="number">3.14159</span>;</span><br><span class="line">    j[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;GPT-4&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接赋值</span></span><br><span class="line">    <span class="type">float</span> pi = j.<span class="built_in">at</span>(<span class="string">&quot;pi&quot;</span>);</span><br><span class="line">    std::string name = j.<span class="built_in">at</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;pi: &quot;</span> &lt;&lt; pi &lt;&lt; <span class="string">&quot;, name: &quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>j.at(&quot;pi&quot;)</code> 返回一个 JSON 值对象，该对象可以直接赋值给 <code>float</code> 类型的变量 <code>pi</code>，因为 JSON 中的值是一个浮点数。同样，<code>j.at(&quot;name&quot;)</code> 返回一个字符串，可以直接赋值给 <code>std::string</code> 类型的变量 <code>name</code>。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><p><strong>类型匹配</strong>：确保 JSON 中的值类型与变量类型匹配，否则会抛出异常。例如，如果 JSON 中的值是整数而你试图将其赋值给浮点数，可能会导致类型不匹配错误。</p></li><li><p><strong>异常处理</strong>：使用 <code>at()</code> 方法时，如果键不存在，会抛出 <code>std::out_of_range</code> 异常。因此，确保键存在或使用异常处理机制。</p></li><li><p><strong>类型安全</strong>：虽然可以直接赋值，但在某些情况下，显式使用 <code>get&lt;&gt;()</code> 可以提高代码的可读性和类型安全性，特别是在处理复杂数据结构时。</p></li><li><p><strong>char 类型</strong>：<strong>nlohmann&#x2F;json 库本身并没有直接支持 char 类型</strong>，所以需要转换，赋值给 json 时需要转换为 string 或者 int。</p></li></ol>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;json-hpp-库下载及安装&quot;&gt;&lt;a href=&quot;#json-hpp-库下载及安装&quot; class=&quot;headerlink&quot; title=&quot;json.hpp 库下载及安装&quot;&gt;&lt;/a&gt;json.hpp 库下载及安装&lt;/h2&gt;&lt;p&gt;nlohmann json</summary>
        
      
    
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/categories/c/"/>
    
    
  </entry>
  
</feed>
