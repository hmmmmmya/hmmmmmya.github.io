<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hymns</title>
  
  
  <link href="https://hmmmmmya.github.io/atom.xml" rel="self"/>
  
  <link href="https://hmmmmmya.github.io/"/>
  <updated>2024-12-28T07:51:05.065Z</updated>
  <id>https://hmmmmmya.github.io/</id>
  
  <author>
    <name>Hymns</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>067-read/write和recv/send的区别</title>
    <link href="https://hmmmmmya.github.io/2024/12/28/067-read-write%E5%92%8Crecv-send%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://hmmmmmya.github.io/2024/12/28/067-read-write%E5%92%8Crecv-send%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2024-12-28T07:50:47.000Z</published>
    <updated>2024-12-28T07:51:05.065Z</updated>
    
    <content type="html"><![CDATA[<p><code>read()</code>&#x2F;<code>write()</code> 和 <code>recv()</code>&#x2F;<code>send()</code> 是用于数据传输的系统调用，但它们有一些区别：</p><ol><li><p><strong>通用性</strong>：</p><ul><li><code>read()</code> 和 <code>write()</code> 是通用的 I&#x2F;O 操作函数，可以用于文件、管道、套接字等各种文件描述符。</li><li><code>recv()</code> 和 <code>send()</code> 专门用于套接字操作，提供了一些额外的功能。</li></ul></li><li><p><strong>功能性</strong>：</p><ul><li><code>recv()</code> 和 <code>send()</code> 可以指定额外的标志（flags），如 <code>MSG_DONTWAIT</code>、<code>MSG_PEEK</code> 等，这些标志可以改变函数的行为。</li><li><code>read()</code> 和 <code>write()</code> 没有这些额外的标志。</li></ul></li><li><p><strong>参数</strong>：</p><ul><li><code>recv()</code> 和 <code>send()</code> 的参数中包含一个 <code>flags</code> 参数，用于指定操作的行为。</li><li><code>read()</code> 和 <code>write()</code> 没有 <code>flags</code> 参数。</li></ul></li><li><p><strong>使用场景</strong>：</p><ul><li>在网络编程中，通常使用 <code>recv()</code> 和 <code>send()</code>，因为它们提供了更灵活的控制。</li><li>对于文件 I&#x2F;O，通常使用 <code>read()</code> 和 <code>write()</code>。</li></ul></li></ol><p>总结来说，<code>recv()</code> 和 <code>send()</code> 是为网络编程设计的，提供了更多的控制选项，而 <code>read()</code> 和 <code>write()</code> 是更通用的 I&#x2F;O 操作函数。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;&lt;code&gt;read()&lt;/code&gt;&amp;#x2F;&lt;code&gt;write()&lt;/code&gt; 和 &lt;code&gt;recv()&lt;/code&gt;&amp;#x2F;&lt;code&gt;send()&lt;/code&gt;</summary>
        
      
    
    
    
    <category term="网络" scheme="https://hmmmmmya.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>066-生产者消费者模型</title>
    <link href="https://hmmmmmya.github.io/2024/12/13/066-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/"/>
    <id>https://hmmmmmya.github.io/2024/12/13/066-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/</id>
    <published>2024-12-13T07:47:25.000Z</published>
    <updated>2024-12-13T07:47:44.123Z</updated>
    
    <content type="html"><![CDATA[<p>要实现 SCPI 回复与请求的匹配，可以考虑使用生产者-消费者模式或线程间同步机制。以下是一个简化的实现思路：</p><ol><li><strong>使用队列</strong>：可以使用一个线程安全的队列来存储请求和对应的回复。</li><li><strong>生产者线程</strong>：负责发送 SCPI 命令并将请求信息（如请求 ID）放入队列。</li><li><strong>消费者线程</strong>：负责从队列中取出请求信息，等待并接收对应的回复。</li></ol><p>以下是一个简化的代码示例，展示如何使用 C++的线程和队列来实现这一模式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::queue&lt;std::pair&lt;<span class="type">int</span>, std::string&gt;&gt; request_queue;</span><br><span class="line">std::mutex queue_mutex;</span><br><span class="line">std::condition_variable queue_cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Producer</span><span class="params">(<span class="type">int</span> request_id, <span class="type">const</span> std::string&amp; command)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line">        request_queue.<span class="built_in">push</span>(&#123;request_id, command&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    queue_cv.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line">        queue_cv.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> !request_queue.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> request = request_queue.<span class="built_in">front</span>();</span><br><span class="line">        request_queue.<span class="built_in">pop</span>();</span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> request_id = request.first;</span><br><span class="line">        std::string command = request.second;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟发送命令并接收回复</span></span><br><span class="line">        std::string reply = <span class="string">&quot;Reply for &quot;</span> + command; <span class="comment">// 假设这是接收到的回复</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理回复</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Request ID: &quot;</span> &lt;&lt; request_id &lt;&lt; <span class="string">&quot;, Reply: &quot;</span> &lt;&lt; reply &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumer_thread</span><span class="params">(Consumer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟发送请求</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">Producer</span>(i, <span class="string">&quot;SCPI Command &quot;</span> + std::<span class="built_in">to_string</span>(i));</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    consumer_thread.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul><li><strong>生产者线程</strong>：<code>Producer</code>函数模拟发送 SCPI 命令，并将请求 ID 和命令放入队列。</li><li><strong>消费者线程</strong>：<code>Consumer</code>函数从队列中取出请求，模拟接收回复，并输出结果。</li><li><strong>线程同步</strong>：使用<code>std::mutex</code>和<code>std::condition_variable</code>来确保线程安全和同步。</li></ul><p>在实际应用中，你需要根据具体的 SCPI 命令和回复机制来调整代码，确保请求和回复能够正确匹配。可能还需要处理超时、错误等情况。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;要实现 SCPI</summary>
        
      
    
    
    
    <category term="设计模式" scheme="https://hmmmmmya.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>065-cpp-sleep</title>
    <link href="https://hmmmmmya.github.io/2024/12/12/065-cpp-sleep/"/>
    <id>https://hmmmmmya.github.io/2024/12/12/065-cpp-sleep/</id>
    <published>2024-12-12T08:41:36.000Z</published>
    <updated>2024-12-12T08:42:16.183Z</updated>
    
    <content type="html"><![CDATA[<h3 id="C-休眠函数"><a href="#C-休眠函数" class="headerlink" title="C++ 休眠函数"></a>C++ 休眠函数</h3><p>让我用中文解释这两种休眠方式的区别：</p><ol><li><code>std::this_thread::sleep_for</code></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>)); <span class="comment">// C++11 方式</span></span><br></pre></td></tr></table></figure><ul><li>这是 C++11 引入的现代休眠方法</li><li>跨平台兼容性好</li><li>可以使用不同的时间单位（毫秒、微秒、秒等）</li><li>提供类型安全</li><li>可以与其他 C++时间相关的功能无缝配合</li><li>精度依赖于操作系统实现</li></ul><ol start="2"><li><code>usleep</code></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">usleep</span>(<span class="number">100000</span>); <span class="comment">// 参数单位是微秒</span></span><br></pre></td></tr></table></figure><ul><li>POSIX 系统的传统 C 函数</li><li>只在 UNIX&#x2F;Linux 系统上可用</li><li>只接受微秒作为参数单位</li><li>参数类型是无符号整数</li><li>在某些系统上已经被废弃</li><li>可能会被信号中断</li></ul><p>建议：</p><ol><li>在现代 C++代码中，推荐使用<code>std::this_thread::sleep_for</code></li><li>如果是只针对 UNIX&#x2F;Linux 的老代码，<code>usleep</code>也是可以接受的</li><li>如果需要高精度定时，两者都不够理想，应该考虑使用专门的实时编程方案</li></ol><p>示例对比：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 现代C++方式，休眠100毫秒</span></span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统方式，休眠100毫秒</span></span><br><span class="line"><span class="built_in">usleep</span>(<span class="number">100</span> * <span class="number">1000</span>);  <span class="comment">// 需要自己转换单位</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h3 id=&quot;C-休眠函数&quot;&gt;&lt;a href=&quot;#C-休眠函数&quot; class=&quot;headerlink&quot; title=&quot;C++ 休眠函数&quot;&gt;&lt;/a&gt;C++</summary>
        
      
    
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>064-数据结构</title>
    <link href="https://hmmmmmya.github.io/2024/12/04/064-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://hmmmmmya.github.io/2024/12/04/064-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2024-12-04T01:36:39.000Z</published>
    <updated>2024-12-04T04:28:49.263Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常见概念"><a href="#常见概念" class="headerlink" title="常见概念"></a>常见概念</h2><h3 id="随机访问"><a href="#随机访问" class="headerlink" title="随机访问"></a>随机访问</h3><p>随机访问（Random Access）是指在数据结构中，可以在常数时间内（O(1)）直接访问任意一个元素，而不需要从头开始遍历数据结构。数组（Array）是支持随机访问的典型数据结构，因为可以通过<strong>索引</strong>(数据地址+偏移量)直接访问任意位置的元素。</p><p>在支持随机访问的数据结构中，元素的存储位置是连续的，这使得通过计算偏移量来直接定位元素成为可能。相比之下，链表（Linked List）不支持随机访问，因为访问某个元素需要从头开始逐个遍历，时间复杂度为 O(n)。</p><p>随机访问的优势在于其高效性，特别是在需要频繁访问或修改特定位置的元素时。然而，这种高效性通常是以牺牲插入和删除操作的效率为代价的，因为在数组中插入或删除元素可能需要移动大量数据。</p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="哈希表就是键值对吗"><a href="#哈希表就是键值对吗" class="headerlink" title="哈希表就是键值对吗"></a>哈希表就是键值对吗</h3><p>哈希表（Hash Table）确实是基于键值对（key-value pair）的一种数据结构。它通过一个哈希函数将键映射到一个数组中的位置，以便快速查找对应的值。以下是哈希表的一些关键特性：</p><ol><li><p><strong>键值对存储</strong>：哈希表中的每个元素都是一个键值对。键用于标识数据，值是与该键相关联的数据。</p></li><li><p><strong>快速查找</strong>：通过哈希函数，哈希表可以在平均情况下以常数时间复杂度（O(1)）进行查找、插入和删除操作。</p></li><li><p><strong>哈希冲突</strong>：由于不同的键可能映射到相同的哈希值，哈希表需要处理冲突。常见的冲突解决方法包括链地址法（使用链表存储冲突的元素）和开放地址法（在数组中寻找下一个空闲位置）。</p></li><li><p><strong>动态调整</strong>：为了保持高效性，哈希表通常会在负载因子（已存储元素数量与数组大小的比值）超过某个阈值时进行扩展和重哈希。</p></li></ol><p>因此，哈希表不仅仅是键值对的简单集合，它还包含了用于高效存储和检索的机制。</p><h3 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h3><p>哈希冲突（Hash Collision）是指在哈希表中，不同的键通过哈希函数映射到相同的哈希值或数组位置的情况。由于哈希表的核心是通过哈希函数将键映射到数组中的位置，因此冲突是不可避免的。处理哈希冲突的方法主要有以下几种：</p><ol><li><p><strong>链地址法（Separate Chaining）</strong>：</p><ul><li>在每个数组位置存储一个链表（或其他数据结构），所有映射到同一位置的元素都存储在这个链表中。</li><li>当发生冲突时，将新元素添加到链表中。</li><li>查找时，需要遍历链表来查找目标元素。</li></ul></li><li><p><strong>开放地址法（Open Addressing）</strong>：</p><ul><li>当发生冲突时，寻找数组中的下一个空闲位置来存储元素。</li><li>常见的开放地址法策略包括线性探测（Linear Probing）、二次探测（Quadratic Probing）和双重哈希（Double Hashing）。</li></ul></li><li><p><strong>再哈希（Rehashing）</strong>：</p><ul><li>当哈希表的负载因子超过某个阈值时，创建一个更大的哈希表，并将所有元素重新哈希到新的表中(扩容)。</li><li>这可以减少冲突的发生频率。</li></ul></li></ol><h4 id="扩容哈希表"><a href="#扩容哈希表" class="headerlink" title="扩容哈希表"></a>扩容哈希表</h4><p>负载因子定义为哈希表中元素数量除以桶数量，反映了哈希冲突的严重程度，常用作触发哈希表扩容的条件。</p><p>简单粗暴，但是效率低，因为哈希表扩容需要进行大量的数据搬运与哈希值计算。</p><p>改良哈希表数据结构，使得哈希表可以在出现哈希冲突时正常工作。</p><ul><li>仅在必要时，即当哈希冲突比较严重时，才执行扩容操作。</li><li>哈希表的结构改良方法主要包括“链式地址”和“开放寻址”。</li></ul><h4 id="链式地址的局限性"><a href="#链式地址的局限性" class="headerlink" title="链式地址的局限性"></a>链式地址的局限性</h4><ul><li>占用空间增大：链表包含节点指针，它相比数组更加耗费内存空间。</li><li>查询效率降低：因为需要线性遍历链表来查找对应元素。</li></ul><p>值得注意的是，当链表很长时，查询效率 O(n) 很差。此时可以将链表转换为“AVL 树”或“红黑树”，从而将查询操作的时间复杂度优化至 O(logn)。</p><h4 id="开放寻址的局限性"><a href="#开放寻址的局限性" class="headerlink" title="开放寻址的局限性"></a>开放寻址的局限性</h4><ul><li>线性探测容易产生“聚集现象”。数组中连续被占用的位置越长，这些连续位置发生哈希冲突的可能性越大，从而进一步促使该位置的聚堆生长，形成恶性循环，最终导致增删查改操作效率劣化。</li><li>负载因子不能太大，否则会降低查询效率。</li><li>删除元素比较麻烦，不能直接删除，需要惰性删除(lazy delete)。这是因为删除元素会在数组内产生一个空桶 None ，而当查询元素时，线性探测到该空桶就会返回，因此在该空桶之下的元素都无法再被访问到，程序可能误判这些元素不存在。<ul><li>惰性删除: 不直接从哈希表中移除元素，而是利用一个常量 TOMBSTONE 来标记这个桶。在该机制下，None 和 TOMBSTONE 都代表空桶，都可以放置键值对。但不同的是，线性探测到 TOMBSTONE 时应该继续遍历，因为其之下可能还存在键值对。</li></ul></li></ul><p>请注意，开放寻址（线性探测、平方探测和多次哈希）哈希表都存在“不能直接删除元素”的问题。</p><h3 id="怎么理解哈希的输入空间通常远大于输出空间（数组长度）"><a href="#怎么理解哈希的输入空间通常远大于输出空间（数组长度）" class="headerlink" title="怎么理解哈希的输入空间通常远大于输出空间（数组长度）"></a>怎么理解哈希的输入空间通常远大于输出空间（数组长度）</h3><p>哈希函数的输入空间通常远大于输出空间的原因在于，哈希函数需要将一个非常大的输入集合（如所有可能的字符串或整数）映射到一个相对较小的输出集合（如哈希表的数组索引）。这种映射过程不可避免地会导致哈希冲突，因为多个不同的输入可能会被映射到相同的输出值。</p><h4 id="理解这一点的几个关键点"><a href="#理解这一点的几个关键点" class="headerlink" title="理解这一点的几个关键点"></a>理解这一点的几个关键点</h4><ol><li><p><strong>输入空间的广泛性</strong>：</p><ul><li>输入空间可以是非常大的集合。例如，所有可能的字符串组合、所有可能的整数等。这些集合的大小通常是无限的或非常大的。</li></ul></li><li><p><strong>输出空间的有限性</strong>：</p><ul><li>输出空间是哈希表的大小，即数组的长度。这个长度是有限的，因为计算机的内存是有限的，哈希表的大小通常是一个固定的数值。</li></ul></li><li><p><strong>映射的必要性</strong>：</p><ul><li>哈希函数的作用是将大输入空间映射到小输出空间，以便在有限的内存中高效地存储和检索数据。</li></ul></li><li><p><strong>冲突的不可避免性</strong>：</p><ul><li>由于输入空间远大于输出空间，必然会有不同的输入映射到相同的输出值，这就是哈希冲突。</li></ul></li></ol><h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><p>假设你有一个哈希表，其数组长度为 1000（输出空间），而你需要存储的可能输入是所有可能的 32 位整数（输入空间）。32 位整数的可能值有 2^32 个（约 43 亿），显然远大于 1000。因此，多个不同的整数可能会映射到同一个数组索引，导致冲突。</p><p>这种映射机制是哈希表设计中的一个基本挑战，处理冲突的方法（如链地址法和开放地址法）就是为了解决这个问题。</p><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>递: 向下<br>归: 向上</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆是一种特殊的树形数据结构，其中每个节点都满足特定的堆性质。堆通常用于实现优先队列（Priority Queue），因为它可以高效地支持插入和删除操作，同时保持元素的有序性。</p><p>堆有两种主要类型：</p><ul><li>最大堆（Max Heap）：在最大堆中，每个节点的值都大于或等于其子节点的值。</li><li>最小堆（Min Heap）：在最小堆中，每个节点的值都小于或等于其子节点的值。</li></ul><p>Q：数据结构的“堆”与内存管理的“堆”是同一个概念吗？</p><p>两者不是同一个概念，只是碰巧都叫“堆”。</p><p>数据结构的“堆”是基于数组实现的树形数据结构，而内存管理的“堆”是内存管理机制。</p><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;常见概念&quot;&gt;&lt;a href=&quot;#常见概念&quot; class=&quot;headerlink&quot; title=&quot;常见概念&quot;&gt;&lt;/a&gt;常见概念&lt;/h2&gt;&lt;h3 id=&quot;随机访问&quot;&gt;&lt;a href=&quot;#随机访问&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="数据结构与算法" scheme="https://hmmmmmya.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>063-模板</title>
    <link href="https://hmmmmmya.github.io/2024/12/03/063-%E6%A8%A1%E6%9D%BF/"/>
    <id>https://hmmmmmya.github.io/2024/12/03/063-%E6%A8%A1%E6%9D%BF/</id>
    <published>2024-12-03T07:45:01.000Z</published>
    <updated>2024-12-03T07:46:04.566Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模板参数会保留其传入类型的所有修饰符"><a href="#模板参数会保留其传入类型的所有修饰符" class="headerlink" title="模板参数会保留其传入类型的所有修饰符"></a>模板参数会保留其传入类型的所有修饰符</h2><p>在 C++中，模板参数会保留其传入类型的所有修饰符，包括<code>const</code>和引用（<code>&amp;</code>或<code>&amp;&amp;</code>）。这意味着如果你传递一个<code>const</code>类型或引用类型作为模板参数，模板会保留这些修饰符。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T param)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// param的类型会保留T的所有修饰符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">func</span>(a); <span class="comment">// T为const int</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">func</span>(b); <span class="comment">// T为int</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>&amp; c = b;</span><br><span class="line">    <span class="built_in">func</span>(c); <span class="comment">// T为int&amp;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; d = a;</span><br><span class="line">    <span class="built_in">func</span>(d); <span class="comment">// T为const int&amp;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>func</code>函数的模板参数<code>T</code>会保留传入参数的<code>const</code>和引用修饰符。因此，<code>T</code>的类型会根据传入的参数类型而有所不同。</p><p>如果你希望在模板中去掉这些修饰符，可以使用标准库中的类型萃取工具，如<code>std::remove_const</code>和<code>std::remove_reference</code>。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> PlainType = <span class="keyword">typename</span> std::remove_const&lt;<span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&gt;::type;</span><br><span class="line">    <span class="comment">// PlainType是去掉const和引用后的基本类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，你可以在模板中根据需要处理类型的修饰符。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;模板参数会保留其传入类型的所有修饰符&quot;&gt;&lt;a href=&quot;#模板参数会保留其传入类型的所有修饰符&quot; class=&quot;headerlink&quot; title=&quot;模板参数会保留其传入类型的所有修饰符&quot;&gt;&lt;/a&gt;模板参数会保留其传入类型的所有修饰符&lt;/h2&gt;&lt;p&gt;在</summary>
        
      
    
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>062-const</title>
    <link href="https://hmmmmmya.github.io/2024/12/03/062-const/"/>
    <id>https://hmmmmmya.github.io/2024/12/03/062-const/</id>
    <published>2024-12-03T06:45:08.000Z</published>
    <updated>2024-12-03T07:45:27.141Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本数据类型和字面值-直接传值-不要使用const"><a href="#基本数据类型和字面值-直接传值-不要使用const" class="headerlink" title="基本数据类型和字面值, 直接传值, 不要使用const&amp;"></a>基本数据类型和字面值, 直接传值, 不要使用<code>const&amp;</code></h2><p>在 C++中，<code>const&amp;</code>通常用于避免拷贝传递参数，尤其是对于较大的对象。然而，对于基本数据类型（如<code>int</code>、<code>float</code>等），传递它们的引用（包括<code>const&amp;</code>）通常没有太大意义，因为它们本身就很小，拷贝的开销很低。对于基本数据类型，这种做法是可以的，但并不是必要的。你可以直接传值而不是引用，尤其是当你传递的是字面值（如<code>0</code>和<code>1</code>）时。</p><p>即: 基本数据类型和字面值, 直接传值, 不要使用<code>const&amp;</code></p><h2 id="函数参数使用const"><a href="#函数参数使用const" class="headerlink" title="函数参数使用const"></a>函数参数使用<code>const</code></h2><p>在 C++中，使用<code>const</code>来修饰函数参数可以防止在函数内部修改这些参数的值。对于基本数据类型（如<code>int</code>、<code>float</code>等），使用<code>const</code>来修饰传值参数通常没有太大意义，因为传值本身就意味着在函数内部的修改不会影响到外部。</p><p>然而，如果你希望明确表达参数在函数内部不应被修改的意图，或者为了代码的一致性，你可以使用<code>const</code>来修饰传值参数。这样做不会影响性能或功能，但可以提高代码的可读性。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;基本数据类型和字面值-直接传值-不要使用const&quot;&gt;&lt;a href=&quot;#基本数据类型和字面值-直接传值-不要使用const&quot; class=&quot;headerlink&quot; title=&quot;基本数据类型和字面值, 直接传值,</summary>
        
      
    
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>061-右值引用</title>
    <link href="https://hmmmmmya.github.io/2024/12/02/061-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
    <id>https://hmmmmmya.github.io/2024/12/02/061-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</id>
    <published>2024-12-02T09:22:34.000Z</published>
    <updated>2024-12-11T03:28:46.117Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><p>右值引用只能绑定到临时对象</p><ul><li>所引用的对象将要被销毁</li><li>该对象没有其他用户</li></ul><p>意味着, 使用右值引用的代码可以自由地接管所引用的对象的资源</p><p>变量是左值, 离开作用域才会销毁, 所以不能将一个右值引用直接绑定到一个变量, 即使这个变量是右值引用类型</p><h2 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h2><p>可以销毁一个 <code>std::move</code> 后的源对象, 也可以赋予新值, 但不能使用一个 <code>std::move</code> 后的对象的值</p><p><code>std::move</code> 是一个标准库函数模板。它的目的是显式地将一个左值转换为右值引用，以便可以将其转移到另一个对象中，而不是进行复制。以下是逐步解析代码的细节：</p><h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type &amp;&amp;<span class="title">move</span><span class="params">(T &amp;&amp;param)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> ReturnType = <span class="keyword">typename</span> remove_reference&lt;T&gt;::type &amp;&amp;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;ReturnType&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-模板参数-T"><a href="#1-模板参数-T" class="headerlink" title="1. 模板参数 T"></a>1. <strong>模板参数 <code>T</code></strong></h4><ul><li><code>T</code> 是一个万能引用类型（也称为转发引用，Forwarding Reference）。它可以绑定到左值或右值。</li><li>在使用时，编译器会根据传入的参数推导出 <code>T</code> 的类型。</li></ul><h4 id="2-remove-reference-type"><a href="#2-remove-reference-type" class="headerlink" title="2. remove_reference&lt;T&gt;::type"></a>2. <strong><code>remove_reference&lt;T&gt;::type</code></strong></h4><ul><li><code>std::remove_reference</code> 是一个类型特征工具，用于移除 <code>T</code> 类型中的引用修饰符（左值引用<code>&amp;</code>或右值引用<code>&amp;&amp;</code>）。<ul><li>如果 <code>T</code> 是 <code>int&amp;</code>，则 <code>remove_reference&lt;T&gt;::type</code> 是 <code>int</code>。</li><li>如果 <code>T</code> 是 <code>int&amp;&amp;</code>，则 <code>remove_reference&lt;T&gt;::type</code> 也是 <code>int</code>。</li><li>如果 <code>T</code> 是 <code>int</code>，则 <code>remove_reference&lt;T&gt;::type</code> 还是 <code>int</code>。</li></ul></li></ul><h4 id="3-返回类型-ReturnType"><a href="#3-返回类型-ReturnType" class="headerlink" title="3. 返回类型 ReturnType"></a>3. <strong>返回类型 <code>ReturnType</code></strong></h4><ul><li><code>ReturnType</code> 定义为 <code>remove_reference&lt;T&gt;::type &amp;&amp;</code>，它是一个右值引用类型。<ul><li>例如，如果 <code>T</code> 是 <code>int&amp;</code>，则 <code>ReturnType</code> 是 <code>int&amp;&amp;</code>。</li><li>如果 <code>T</code> 是 <code>int</code>，则 <code>ReturnType</code> 是 <code>int&amp;&amp;</code>。</li><li>如果 <code>T</code> 是 <code>int&amp;&amp;</code>，则 <code>ReturnType</code> 仍是 <code>int&amp;&amp;</code>。</li></ul></li></ul><h4 id="4-static-cast-param"><a href="#4-static-cast-param" class="headerlink" title="4. static_cast&lt;ReturnType&gt;(param)"></a>4. <strong><code>static_cast&lt;ReturnType&gt;(param)</code></strong></h4><ul><li><code>static_cast</code> 将 <code>param</code> 转换为右值引用类型（即 <code>ReturnType</code>）。</li><li>这是实现右值语义的关键，使得调用 <code>std::move</code> 后，可以显式地告知编译器 “此对象可以被移动”，而不是执行复制操作。</li></ul><hr><h3 id="理解-std-move-的目的"><a href="#理解-std-move-的目的" class="headerlink" title="理解 std::move 的目的"></a>理解 <code>std::move</code> 的目的</h3><ol><li><p><strong>传递右值语义：</strong></p><ul><li>左值通常用于赋值或复制，而右值（包括临时对象和 <code>std::move</code> 转换后的对象）可以直接参与移动操作。</li><li><code>std::move</code> 是一个语义标记，它并不会真正地移动数据，而是明确表示这个对象可以被移动。</li></ul></li><li><p><strong>触发移动构造&#x2F;移动赋值：</strong></p><ul><li>当对象被 <code>std::move</code> 转换后，编译器会优先选择移动构造函数或移动赋值运算符（如果它们可用）。</li></ul></li></ol><hr><h3 id="一个实际例子"><a href="#一个实际例子" class="headerlink" title="一个实际例子"></a>一个实际例子</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">    std::string newStr = std::<span class="built_in">move</span>(str);  <span class="comment">// 移动操作</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;  <span class="comment">// 可能为空或未定义（实现依赖）</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;newStr: &quot;</span> &lt;&lt; newStr &lt;&lt; std::endl;  <span class="comment">// &quot;Hello, world!&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ol><li><code>std::move(str)</code> 将 <code>str</code> 显式转换为右值引用。</li><li>这使得构造 <code>newStr</code> 时使用的是 <code>std::string</code> 的移动构造函数，而不是复制构造函数。</li><li>移动构造函数通常只会转移底层资源的所有权，而不是复制内容，因此效率更高。</li></ol><hr><h3 id="为什么-std-move-的实现显得有些复杂？"><a href="#为什么-std-move-的实现显得有些复杂？" class="headerlink" title="为什么 std::move 的实现显得有些复杂？"></a>为什么 <code>std::move</code> 的实现显得有些复杂？</h3><ol><li><p><strong>类型安全：</strong></p><ul><li><code>std::move</code> 需要处理所有可能的类型（包括左值引用、右值引用、非引用类型）。</li><li>使用模板和 <code>remove_reference</code> 可以保证它适用于广泛的场景。</li></ul></li><li><p><strong>避免额外的拷贝：</strong></p><ul><li>使用 <code>static_cast</code> 确保转换是高效的，并避免额外的临时对象创建。</li></ul></li><li><p><strong>明确右值语义：</strong></p><ul><li>编译器无法通过常规代码自动推断出某些左值可以被移动。通过 <code>std::move</code> 显式告知编译器可以安全地应用右值语义。</li></ul></li></ol><hr><h2 id="无论是左值还是右值-经过-std-move-转化后-都变成右值吗"><a href="#无论是左值还是右值-经过-std-move-转化后-都变成右值吗" class="headerlink" title="无论是左值还是右值, 经过 std::move 转化后, 都变成右值吗"></a>无论是左值还是右值, 经过 std::move 转化后, 都变成右值吗</h2><p>是的，经过 <code>std::move</code> 转换后，无论输入的是左值还是右值，结果都会变成<strong>右值引用</strong>（准确地说是 <code>T&amp;&amp;</code> 类型，其中 <code>T</code> 是去掉引用后的类型）。</p><p>不过，需要特别注意的是，<code>std::move</code> 不会改变对象本身的值类别，它只是返回一个右值引用。这意味着：</p><ol><li><strong>对象本身仍然是左值：</strong><br>即使通过 <code>std::move</code> 转换，对象本身仍然存在，仍然可以通过左值访问它。</li><li><strong>调用 <code>std::move</code> 的结果是右值引用：</strong><br>这是一种“显式标记”，告诉编译器该对象的资源可以安全地被转移。</li></ol><hr><h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><h4 id="转换的效果"><a href="#转换的效果" class="headerlink" title="转换的效果"></a>转换的效果</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;         <span class="comment">// x 是左值</span></span><br><span class="line">    <span class="type">int</span>&amp;&amp; y = std::<span class="built_in">move</span>(x);  <span class="comment">// std::move(x) 将 x 转换为右值引用</span></span><br><span class="line"></span><br><span class="line">    y = <span class="number">20</span>;             <span class="comment">// 可以通过 y 修改 x 的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;  <span class="comment">// 输出 20，x 本身没有消失</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x: 20</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><ul><li><code>x</code> 是左值。</li><li><code>std::move(x)</code> 返回的是一个右值引用 <code>int&amp;&amp;</code>，但它仍然指向 <code>x</code> 的内存。</li><li><code>x</code> 的值可以通过 <code>y</code> 被修改，但编译器会认为 <code>y</code> 是右值引用，可能触发移动语义。</li></ul><hr><h3 id="理解-“右值引用”和“右值”"><a href="#理解-“右值引用”和“右值”" class="headerlink" title="理解 “右值引用”和“右值”"></a>理解 “右值引用”和“右值”</h3><h4 id="右值引用不是右值"><a href="#右值引用不是右值" class="headerlink" title="右值引用不是右值"></a>右值引用不是右值</h4><ul><li><strong>右值引用</strong>（<code>T&amp;&amp;</code>）是一个可以绑定到右值的引用类型，但它本身是一个左值（因为它有名字）。</li><li><strong>右值</strong> 是不具名的值，例如 <code>10</code>、临时对象或通过 <code>std::move</code> 返回的表达式。</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp;&amp; val)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;process(int&amp;&amp;): &quot;</span> &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line">    <span class="built_in">process</span>(std::<span class="built_in">move</span>(x));  <span class="comment">// std::move(x) 是右值</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>&amp;&amp; y = std::<span class="built_in">move</span>(x);  <span class="comment">// y 是右值引用，但 y 本身是左值</span></span><br><span class="line">    <span class="comment">// process(y);           // 编译错误，因为 y 是左值</span></span><br><span class="line">    <span class="built_in">process</span>(std::<span class="built_in">move</span>(y));   <span class="comment">// 需要再次 std::move 转换为右值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">process(int&amp;&amp;): 42</span><br><span class="line">process(int&amp;&amp;): 42</span><br></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p><strong><code>std::move</code> 的作用：</strong></p><ul><li>它把传入的对象转换为右值引用，告诉编译器可以对其执行移动操作。</li><li>它不会改变对象本身的值类别或状态。</li></ul></li><li><p><strong>左值经过 <code>std::move</code> 转换：</strong></p><ul><li>变为右值引用。</li></ul></li><li><p><strong>右值经过 <code>std::move</code> 转换：</strong></p><ul><li>仍然是右值引用，但语法上统一为右值处理。</li></ul></li><li><p><strong><code>std::move</code> 不会销毁或重置对象：</strong></p><ul><li>对象在经过 <code>std::move</code> 后仍然存在，可以继续访问和使用（尽管其资源可能已被转移）。</li></ul></li></ol><p>注意: 在移动构造函数和移动赋值运算符这些类实现代码之外的地方, 只有确信需要进行移动操作且移动操作是安全的, 才使用 <code>std::move</code> 显式地移动对象</p><h2 id="基本类型和类类型的移动操作"><a href="#基本类型和类类型的移动操作" class="headerlink" title="基本类型和类类型的移动操作"></a>基本类型和类类型的移动操作</h2><p>这两个例子看似相似，但它们在底层行为上有根本的区别，原因在于对象类型及其资源管理方式的不同。</p><hr><h3 id="第一例：基本类型-int"><a href="#第一例：基本类型-int" class="headerlink" title="第一例：基本类型 int"></a>第一例：基本类型 <code>int</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;         <span class="comment">// x 是左值</span></span><br><span class="line">    <span class="type">int</span>&amp;&amp; y = std::<span class="built_in">move</span>(x);  <span class="comment">// std::move(x) 将 x 转换为右值引用</span></span><br><span class="line"></span><br><span class="line">    y = <span class="number">20</span>;             <span class="comment">// 可以通过 y 修改 x 的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;  <span class="comment">// 输出 20，x 本身没有消失</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><ol><li><p><strong><code>std::move</code> 转换的作用：</strong></p><ul><li><code>std::move(x)</code> 将 <code>x</code> 标记为右值引用，但不会对 <code>x</code> 本身的值或状态造成任何改变。</li><li><code>int&amp;&amp; y</code> 是一个右值引用，但它仍然直接绑定到 <code>x</code>，共享同一块内存。</li></ul></li><li><p><strong>操作效果：</strong></p><ul><li>修改 <code>y</code> 的值实际上就是修改 <code>x</code>，因为 <code>y</code> 绑定到 <code>x</code> 的内存。</li><li>因此，输出 <code>x</code> 时，其值已经更新为 <code>20</code>。</li></ul></li><li><p><strong>为什么行为正常：</strong></p><ul><li>对于基本类型（如 <code>int</code>），<code>std::move</code> 仅改变类型语义，而不涉及实际的数据移动。</li><li><code>int</code> 是轻量的 POD（Plain Old Data），无需复杂的资源管理。</li></ul></li></ol><hr><h3 id="第二例：类类型-std-string"><a href="#第二例：类类型-std-string" class="headerlink" title="第二例：类类型 std::string"></a>第二例：类类型 <code>std::string</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">    std::string newStr = std::<span class="built_in">move</span>(str);  <span class="comment">// 移动操作</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;  <span class="comment">// 可能为空或未定义（实现依赖）</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;newStr: &quot;</span> &lt;&lt; newStr &lt;&lt; std::endl;  <span class="comment">// &quot;Hello, world!&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><ol><li><p><strong><code>std::move</code> 的作用：</strong></p><ul><li>对于类类型（如 <code>std::string</code>），<code>std::move</code> 同样只是标记为右值引用。</li><li>但是，类类型的赋值操作会优先调用<strong>移动构造函数</strong>或<strong>移动赋值运算符</strong>（如果可用）。</li></ul></li><li><p><strong>移动操作的效果：</strong></p><ul><li><code>std::move(str)</code> 会触发 <code>std::string</code> 的移动构造函数。</li><li>在移动过程中，<code>newStr</code> 接管了 <code>str</code> 的底层资源（如堆上的字符串缓冲区）。</li><li>移动完成后，<code>str</code> 的资源被转移，其状态通常会被置为“空”或“无效”（例如，其缓冲区指针可能为 <code>nullptr</code>，长度为 0）。</li></ul></li><li><p><strong>为什么 <code>str</code> 状态不稳定：</strong></p><ul><li>c++ 标准没有强制规定移动后对象的具体状态，只要求它可以被安全地析构。</li><li>因此，移动后的 <code>str</code> 可能变为空字符串、未定义状态，或保持部分有效性，具体取决于标准库的实现。</li></ul></li></ol><hr><h3 id="两者的关键区别"><a href="#两者的关键区别" class="headerlink" title="两者的关键区别"></a>两者的关键区别</h3><table><thead><tr><th>特性</th><th>第一例（<code>int</code>）</th><th>第二例（<code>std::string</code>）</th></tr></thead><tbody><tr><td>类型</td><td>基本类型（POD）</td><td>类类型（具有资源管理）</td></tr><tr><td><code>std::move</code>作用</td><td>仅改变类型语义，不转移资源</td><td>转移底层资源所有权</td></tr><tr><td>是否触发移动操作</td><td>否</td><td>是，调用移动构造函数</td></tr><tr><td>移动后原对象状态</td><td>完全不变</td><td>可能为空或实现依赖</td></tr><tr><td>是否需要资源管理</td><td>否</td><td>是，底层资源可能在堆上</td></tr></tbody></table><hr><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li><p><strong>对于基本类型：</strong></p><ul><li><code>std::move</code> 不涉及资源移动，仅改变语义。</li><li>原变量的状态完全保持。</li></ul></li><li><p><strong>对于类类型：</strong></p><ul><li><code>std::move</code> 通常触发移动操作，将资源转移到新对象。</li><li>原对象可能被置为“资源空”的状态，具体行为依赖于类的实现。</li></ul></li></ul><p>了解这些区别有助于正确使用 <code>std::move</code> 和理解其作用范围。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;右值引用&quot;&gt;&lt;a href=&quot;#右值引用&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>060-cpp成员函数</title>
    <link href="https://hmmmmmya.github.io/2024/12/02/060-cpp%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/"/>
    <id>https://hmmmmmya.github.io/2024/12/02/060-cpp%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</id>
    <published>2024-12-02T08:25:50.000Z</published>
    <updated>2024-12-03T07:45:43.158Z</updated>
    
    <content type="html"><![CDATA[<p>在 C++中，类的成员函数通常包括以下几种类型：</p><ol><li><p><strong>构造函数（Constructor）</strong>：</p><ul><li>用于初始化对象。构造函数的名称与类名相同，没有返回类型。</li><li>可以有多个构造函数（重载），以支持不同的初始化方式。</li></ul></li><li><p><strong>析构函数（Destructor）</strong>：</p><ul><li>用于清理对象。析构函数的名称是类名的前面加上波浪号（~），没有返回类型，也没有参数。</li><li>在对象生命周期结束时自动调用。</li></ul></li><li><p><strong>拷贝构造函数（Copy Constructor）</strong>：</p><ul><li>用于复制对象。通常用于对象的复制初始化。</li><li>形如：<code>ClassName(const ClassName &amp;other)</code></li></ul></li><li><p><strong>赋值运算符重载（Assignment Operator Overload）</strong>：</p><ul><li>用于对象的赋值操作。</li><li>形如：<code>ClassName&amp; operator=(const ClassName &amp;other)</code></li></ul></li><li><p><strong>移动构造函数（Move Constructor）</strong>：</p><ul><li>用于移动语义，提高性能。</li><li>形如：<code>ClassName(ClassName &amp;&amp;other)</code></li></ul></li><li><p><strong>移动赋值运算符重载（Move Assignment Operator Overload）</strong>：</p><ul><li>用于移动语义的赋值操作。</li><li>形如：<code>ClassName&amp; operator=(ClassName &amp;&amp;other)</code></li></ul></li><li><p><strong>访问器（Accessors）</strong>：</p><ul><li>用于获取对象的私有成员变量的值。</li><li>通常是<code>const</code>函数，不修改对象的状态。</li></ul></li><li><p><strong>修改器（Mutators）</strong>：</p><ul><li>用于设置对象的私有成员变量的值。</li><li>通常会对输入值进行验证。</li></ul></li><li><p><strong>静态成员函数（Static Member Functions）</strong>：</p><ul><li>不依赖于对象实例，可以通过类名直接调用。</li><li>不能访问非静态成员变量。</li></ul></li><li><p><strong>友元函数（Friend Functions）</strong>：</p><ul><li>不是类的成员，但可以访问类的私有和保护成员。</li><li>通过<code>friend</code>关键字声明。</li></ul></li><li><p><strong>虚函数（Virtual Functions）</strong>：</p><ul><li>用于实现多态行为。</li><li>在基类中声明为<code>virtual</code>，在派生类中可以重写。</li></ul></li><li><p><strong>常成员函数（Const Member Functions）</strong>：</p><ul><li>不修改对象的状态。</li><li>在函数声明后加上<code>const</code>关键字。</li></ul></li></ol><p>这些成员函数的具体实现和使用取决于类的设计需求和功能。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在</summary>
        
      
    
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>059-int赋值给char</title>
    <link href="https://hmmmmmya.github.io/2024/11/30/059-int%E8%B5%8B%E5%80%BC%E7%BB%99char/"/>
    <id>https://hmmmmmya.github.io/2024/11/30/059-int%E8%B5%8B%E5%80%BC%E7%BB%99char/</id>
    <published>2024-11-30T08:28:46.000Z</published>
    <updated>2025-01-06T03:06:12.384Z</updated>
    
    <content type="html"><![CDATA[<h3 id="int-直接赋值给-char-会怎么样"><a href="#int-直接赋值给-char-会怎么样" class="headerlink" title="int 直接赋值给 char 会怎么样"></a>int 直接赋值给 char 会怎么样</h3><p>在 C++中，将一个 <code>int</code> 类型的值直接赋值给一个 <code>char</code> 类型的变量时，可能会发生以下情况：</p><ol><li><p><strong>截断</strong>：<code>char</code> 类型通常是 1 字节（8 位），而 <code>int</code> 类型通常是 4 字节（32 位）或更多。因此，当 <code>int</code> 的值超出 <code>char</code> 的表示范围时，只有最低的 8 位会被保留，其余的位会被截断。这可能导致数据丢失或值的改变。</p></li><li><p><strong>符号扩展</strong>：如果 <code>char</code> 是有符号的（<code>signed char</code>），并且 <code>int</code> 的值超出了 <code>char</code> 的正数范围（通常是 -128 到 127），则可能会导致符号扩展问题，导致负值。</p></li><li><p><strong>未定义行为</strong>：如果 <code>int</code> 的值超出了 <code>char</code> 的表示范围，可能会导致未定义行为，具体表现取决于编译器和平台。</p></li></ol><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> largeValue = <span class="number">300</span>;</span><br><span class="line"><span class="type">char</span> smallValue = largeValue; <span class="comment">// smallValue 可能会变成 44，因为 300 的最低 8 位是 44</span></span><br></pre></td></tr></table></figure><p>为了避免这些问题，通常建议在赋值前进行显式的类型转换，并确保值在目标类型的范围内：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> largeValue = <span class="number">300</span>;</span><br><span class="line"><span class="type">char</span> smallValue = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(largeValue &amp; <span class="number">0xFF</span>); <span class="comment">// 只保留最低的 8 位</span></span><br></pre></td></tr></table></figure><p>这样可以确保程序的行为是可预测的。</p><p>总结: 从二进制角度来看, int 是 32 位, char 是 8 位, 不要直接将 int 赋值给 char, 要进行类型转换, <strong>只保留最低的 8 位</strong>.</p><h3 id="int-1-和-char-‘1’-的主要区别"><a href="#int-1-和-char-‘1’-的主要区别" class="headerlink" title="int(1) 和 char(‘1’) 的主要区别"></a>int(1) 和 char(‘1’) 的主要区别</h3><ol><li><strong>数值表示</strong>：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">1</span>;     <span class="comment">// 数值1，二进制为 00000001</span></span><br><span class="line"><span class="type">char</span> c = <span class="string">&#x27;1&#x27;</span>;    <span class="comment">// 字符&#x27;1&#x27;，ASCII码为49（二进制 00110001）</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>内存占用</strong>：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;int大小: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; <span class="string">&quot;字节&quot;</span> &lt;&lt; std::endl;    <span class="comment">// 通常是4字节</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;char大小: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span>) &lt;&lt; <span class="string">&quot;字节&quot;</span> &lt;&lt; std::endl;   <span class="comment">// 1字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>使用场景示例</strong>：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">1</span>;      <span class="comment">// 用于数学计算</span></span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;1&#x27;</span>;     <span class="comment">// 用于字符表示</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数学运算</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;num + 1 = &quot;</span> &lt;&lt; num + <span class="number">1</span> &lt;&lt; std::endl;        <span class="comment">// 输出：2</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c + 1 = &quot;</span> &lt;&lt; c + <span class="number">1</span> &lt;&lt; std::endl;           <span class="comment">// 输出：50 (ASCII 49 + 1)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符输出</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;num as char: &quot;</span> &lt;&lt; (<span class="type">char</span>)num &lt;&lt; std::endl;   <span class="comment">// 输出：SOH (不可打印字符)</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c as char: &quot;</span> &lt;&lt; c &lt;&lt; std::endl;            <span class="comment">// 输出：1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ASCII值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c的ASCII值: &quot;</span> &lt;&lt; (<span class="type">int</span>)c &lt;&lt; std::endl;      <span class="comment">// 输出：49</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要区别总结：</p><ol><li><p><strong>本质区别</strong>：</p><ul><li><code>int(1)</code> 是数值 1, 二进制为 00000000 00000000 00000000 00000001</li><li><code>char(&#39;1&#39;)</code> 是字符’1’的 ASCII 码值 49, 二进制为 00110001</li><li><code>char(1)</code> 是二进制 00000001</li></ul></li><li><p><strong>用途区别</strong>：</p><ul><li><code>int</code> 主要用于数值计算</li><li><code>char</code> 主要用于字符表示</li></ul></li><li><p><strong>存储区别</strong>：</p><ul><li><code>int</code> 通常占 4 字节</li><li><code>char</code> 占 1 字节</li></ul></li><li><p><strong>表示范围</strong>：</p><ul><li><code>int</code> 通常范围是 -2147483648 到 2147483647</li><li><code>char</code> 范围是 -128 到 127（unsigned char 是 0 到 255）</li></ul></li><li><p><strong>转换注意事项</strong>：</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="type">char</span> c = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换示例</span></span><br><span class="line"><span class="type">int</span> num_from_char = c - <span class="string">&#x27;0&#x27;</span>;    <span class="comment">// 字符转数字：49 - 48 = 1</span></span><br><span class="line"><span class="type">char</span> char_from_int = num + <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 数字转字符：1 + 48 = &#x27;1&#x27;</span></span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;字符&#x27;1&#x27;转换为数字: &quot;</span> &lt;&lt; num_from_char &lt;&lt; std::endl;  <span class="comment">// 输出：1</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;数字1转换为字符: &quot;</span> &lt;&lt; char_from_int &lt;&lt; std::endl;    <span class="comment">// 输出：1</span></span><br></pre></td></tr></table></figure><p>这些区别在处理数值计算和字符串操作时特别重要，尤其是在：</p><ul><li>数字字符串转换为实际数值</li><li>格式化输出</li><li>文件操作</li><li>用户输入处理</li></ul><p>等场景中需要特别注意。</p><h3 id="static-cast-和-static-cast-largeValue-0xFF"><a href="#static-cast-和-static-cast-largeValue-0xFF" class="headerlink" title="static_cast 和 static_cast(largeValue &amp; 0xFF)"></a>static_cast<char> 和 static_cast<char>(largeValue &amp; 0xFF)</h3><ol><li><strong>简单的 static_cast<char></strong>:</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> largeValue = <span class="number">300</span>;</span><br><span class="line"><span class="type">char</span> c1 = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(largeValue);  <span class="comment">// 可能导致未定义行为</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>使用位掩码的 static_cast<char>(largeValue &amp; 0xFF)</strong>:</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> largeValue = <span class="number">300</span>;</span><br><span class="line"><span class="type">char</span> c2 = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(largeValue &amp; <span class="number">0xFF</span>);  <span class="comment">// 安全地截取最后8位</span></span><br></pre></td></tr></table></figure><p>主要区别：</p><ol><li><strong>数值范围处理</strong>：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> largeValue = <span class="number">300</span>;  <span class="comment">// 二进制：0000 0001 0010 1100</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法1：直接转换</span></span><br><span class="line">    <span class="type">char</span> c1 = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(largeValue);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;直接转换结果: &quot;</span> &lt;&lt; (<span class="type">int</span>)c1 &lt;&lt; std::endl;  <span class="comment">// 结果不确定</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法2：使用位掩码</span></span><br><span class="line">    <span class="type">char</span> c2 = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(largeValue &amp; <span class="number">0xFF</span>);  <span class="comment">// 只保留最后8位：0010 1100</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;位掩码转换结果: &quot;</span> &lt;&lt; (<span class="type">int</span>)c2 &lt;&lt; std::endl;  <span class="comment">// 输出：44</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>安全性比较</strong>：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">demonstrateCasting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 超出char范围的值</span></span><br><span class="line">    <span class="type">int</span> values[] = &#123;<span class="number">128</span>, <span class="number">255</span>, <span class="number">256</span>, <span class="number">300</span>, <span class="number">-129</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> val : values) &#123;</span><br><span class="line">        <span class="comment">// 直接转换 - 可能导致未定义行为</span></span><br><span class="line">        <span class="type">char</span> direct = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用位掩码 - 安全地截取最后8位</span></span><br><span class="line">        <span class="type">char</span> masked = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(val &amp; <span class="number">0xFF</span>);</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;原值: &quot;</span> &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;直接转换: &quot;</span> &lt;&lt; (<span class="type">int</span>)direct &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;位掩码转换: &quot;</span> &lt;&lt; (<span class="type">int</span>)masked &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;-------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要区别总结：</p><ol><li><p><strong>安全性</strong>：</p><ul><li><code>static_cast&lt;char&gt;</code> 在值超出 char 范围时可能导致未定义行为</li><li><code>static_cast&lt;char&gt;(value &amp; 0xFF)</code> 总是安全地截取最后 8 位</li></ul></li><li><p><strong>值范围</strong>：</p><ul><li><code>static_cast&lt;char&gt;</code> 不保证结果在 char 的有效范围内</li><li><code>static_cast&lt;char&gt;(value &amp; 0xFF)</code> 保证结果在 0-255 之间</li></ul></li><li><p><strong>使用场景</strong>：</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">example</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 适合使用直接转换的场景</span></span><br><span class="line">    <span class="type">int</span> smallValue = <span class="number">65</span>;</span><br><span class="line">    <span class="type">char</span> c1 = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(smallValue);  <span class="comment">// 转换&#x27;A&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 适合使用位掩码的场景</span></span><br><span class="line">    <span class="type">int</span> networkByte = <span class="number">0x1234</span>;</span><br><span class="line">    <span class="type">char</span> lowByte = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(networkByte &amp; <span class="number">0xFF</span>);  <span class="comment">// 获取最低字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>位操作说明</strong>：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0xFF的作用演示</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">explainBitMask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">300</span>;  <span class="comment">// 二进制：0000 0001 0010 1100</span></span><br><span class="line">    <span class="type">int</span> masked = value &amp; <span class="number">0xFF</span>;  <span class="comment">// 0xFF = 0000 0000 1111 1111</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结果只保留最后8位：0010 1100 (44在十进制中)</span></span><br><span class="line">    <span class="type">char</span> result = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(masked);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;原始值: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;掩码后: &quot;</span> &lt;&lt; (<span class="type">int</span>)result &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建议：</p><ul><li>当确定输入值在 char 范围内时，可以使用简单的<code>static_cast&lt;char&gt;</code></li><li>处理可能超出范围的值时，应使用<code>static_cast&lt;char&gt;(value &amp; 0xFF)</code></li><li>在处理网络字节序或二进制数据时，位掩码方式特别有用</li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h3 id=&quot;int-直接赋值给-char-会怎么样&quot;&gt;&lt;a href=&quot;#int-直接赋值给-char-会怎么样&quot; class=&quot;headerlink&quot; title=&quot;int 直接赋值给 char 会怎么样&quot;&gt;&lt;/a&gt;int 直接赋值给 char 会怎么样&lt;/h3&gt;&lt;p&gt;在</summary>
        
      
    
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>058-design-patterns-learning</title>
    <link href="https://hmmmmmya.github.io/2024/11/28/058-design-patterns-learning/"/>
    <id>https://hmmmmmya.github.io/2024/11/28/058-design-patterns-learning/</id>
    <published>2024-11-28T09:04:03.000Z</published>
    <updated>2024-11-29T01:58:16.112Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h3><ul><li><a href="https://refactoringguru.cn/design-patterns/cpp">refactoringguru 设计模式</a></li><li><a href="https://design-patterns.readthedocs.io/zh-cn/latest/index.html">图说设计模式</a></li><li><a href="https://www.geeksforgeeks.org/introduction-to-pattern-designing/">GeeksforGeeks 设计模式</a></li></ul><h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><ul><li><a href="https://www.bilibili.com/video/BV1Zd4y1t7HK/?vd_source=afd9bb086cf8c56bfa160a01bb00e8d8">设计模式-阿西拜编程</a></li></ul><h3 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h3><ul><li><a href="https://github.com/kamranahmedse/design-patterns-for-humans">design-patterns-for-humans</a></li><li><a href="https://github.com/JakubVojvoda/design-patterns-cpp?tab=readme-ov-file">design-patterns-cpp</a></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;设计模式&quot;&gt;&lt;a href=&quot;#设计模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式&quot;&gt;&lt;/a&gt;设计模式&lt;/h2&gt;&lt;h3 id=&quot;网站&quot;&gt;&lt;a href=&quot;#网站&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="learning" scheme="https://hmmmmmya.github.io/categories/learning/"/>
    
    
  </entry>
  
  <entry>
    <title>057-nlohmann_json库的使用</title>
    <link href="https://hmmmmmya.github.io/2024/11/22/057-nlohmann-json%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://hmmmmmya.github.io/2024/11/22/057-nlohmann-json%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2024-11-22T07:54:26.000Z</published>
    <updated>2024-12-11T03:28:36.964Z</updated>
    
    <content type="html"><![CDATA[<h2 id="json-hpp-库下载及安装"><a href="#json-hpp-库下载及安装" class="headerlink" title="json.hpp 库下载及安装"></a>json.hpp 库下载及安装</h2><p>nlohmann json 的开源项目地址：</p><p><a href="https://github.com/nlohmann/json#serialization%E2%80%93deserialization">https://github.com/nlohmann/json#serialization–deserialization</a></p><p>对于我们项目中要使用 nlohmann json 工具，只需要引入 json.hpp 这一个文件，其中包含所有接口函数，正如其文档中所述 json.hpp 文件在 single_include&#x2F;nlohmann 目录下，我们只需要下载该文件即可：</p><p>git clone <a href="https://github.com/nlohmann/json/blob/develop/single_include/nlohmann/json.hpp">https://github.com/nlohmann/json/blob/develop/single_include/nlohmann/json.hpp</a></p><p>注意：不是 include&#x2F;nlohmann&#x2F;json.hpp，而是 single_include&#x2F;nlohmann&#x2F;json.hpp，前者要包含整个文件夹，后者只需要包含 json.hpp 文件。</p><h2 id="用-json-赋值"><a href="#用-json-赋值" class="headerlink" title="用 json 赋值"></a>用 json 赋值</h2><p>在使用 nlohmann JSON 库时，如果 JSON 中存储的类型与要赋值的变量类型一致，通常不需要显式地使用 <code>get&lt;&gt;()</code> 进行类型转换。<code>at()</code> 方法会返回一个 JSON 值对象，该对象可以直接赋值给与其类型兼容的变量。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;nlohmann/json.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    nlohmann::json j;</span><br><span class="line">    j[<span class="string">&quot;pi&quot;</span>] = <span class="number">3.14159</span>;</span><br><span class="line">    j[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;GPT-4&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接赋值</span></span><br><span class="line">    <span class="type">float</span> pi = j.<span class="built_in">at</span>(<span class="string">&quot;pi&quot;</span>);</span><br><span class="line">    std::string name = j.<span class="built_in">at</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;pi: &quot;</span> &lt;&lt; pi &lt;&lt; <span class="string">&quot;, name: &quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>j.at(&quot;pi&quot;)</code> 返回一个 JSON 值对象，该对象可以直接赋值给 <code>float</code> 类型的变量 <code>pi</code>，因为 JSON 中的值是一个浮点数。同样，<code>j.at(&quot;name&quot;)</code> 返回一个字符串，可以直接赋值给 <code>std::string</code> 类型的变量 <code>name</code>。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><p><strong>类型匹配</strong>：确保 JSON 中的值类型与变量类型匹配，否则会抛出异常。例如，如果 JSON 中的值是整数而你试图将其赋值给浮点数，可能会导致类型不匹配错误。</p></li><li><p><strong>异常处理</strong>：使用 <code>at()</code> 方法时，如果键不存在，会抛出 <code>std::out_of_range</code> 异常。因此，确保键存在或使用异常处理机制。</p></li><li><p><strong>类型安全</strong>：虽然可以直接赋值，但在某些情况下，显式使用 <code>get&lt;&gt;()</code> 可以提高代码的可读性和类型安全性，特别是在处理复杂数据结构时。</p></li><li><p><strong>char 类型</strong>：<strong>nlohmann&#x2F;json 库本身并没有直接支持 char 类型</strong>，所以需要转换，赋值给 json 时需要转换为 string 或者 int。</p></li></ol>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;json-hpp-库下载及安装&quot;&gt;&lt;a href=&quot;#json-hpp-库下载及安装&quot; class=&quot;headerlink&quot; title=&quot;json.hpp 库下载及安装&quot;&gt;&lt;/a&gt;json.hpp 库下载及安装&lt;/h2&gt;&lt;p&gt;nlohmann json</summary>
        
      
    
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>056-ifndef LINUX</title>
    <link href="https://hmmmmmya.github.io/2024/11/21/056-ifndef-LINUX/"/>
    <id>https://hmmmmmya.github.io/2024/11/21/056-ifndef-LINUX/</id>
    <published>2024-11-21T09:53:59.000Z</published>
    <updated>2024-11-21T09:54:07.003Z</updated>
    
    
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>055-windwos下用Studio编译缺少jsoncpp库怎么办</title>
    <link href="https://hmmmmmya.github.io/2024/11/21/055-windwos%E4%B8%8B%E7%94%A8Studio%E7%BC%96%E8%AF%91%E7%BC%BA%E5%B0%91jsoncpp%E5%BA%93%E6%80%8E%E4%B9%88%E5%8A%9E/"/>
    <id>https://hmmmmmya.github.io/2024/11/21/055-windwos%E4%B8%8B%E7%94%A8Studio%E7%BC%96%E8%AF%91%E7%BC%BA%E5%B0%91jsoncpp%E5%BA%93%E6%80%8E%E4%B9%88%E5%8A%9E/</id>
    <published>2024-11-21T09:49:54.000Z</published>
    <updated>2024-11-21T09:50:34.627Z</updated>
    
    <content type="html"><![CDATA[<p>在 Windows 下使用 Microsoft Visual Studio 时，如果没有<code>jsoncpp</code>库，你可以通过以下几种方式来解决这个问题：</p><ol><li><p><strong>使用 vcpkg 安装 jsoncpp 库</strong>：</p><ul><li><p>首先，确保你已经安装并设置好<code>vcpkg</code>。如果没有，请参考<a href="https://github.com/microsoft/vcpkg">vcpkg 的官方文档</a>进行安装。</p></li><li><p>打开命令提示符，导航到<code>vcpkg</code>的安装目录，然后运行以下命令来安装<code>jsoncpp</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg install jsoncpp</span><br></pre></td></tr></table></figure></li><li><p>安装完成后，将<code>vcpkg</code>集成到 Visual Studio 中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg integrate install</span><br></pre></td></tr></table></figure></li><li><p>在你的项目中，确保在项目属性中包含<code>vcpkg</code>的头文件和库路径。</p></li></ul></li><li><p><strong>手动下载和编译 jsoncpp 库</strong>：</p><ul><li>访问<a href="https://github.com/open-source-parsers/jsoncpp">jsoncpp 的 GitHub 页面</a>下载源码。</li><li>使用 CMake 生成 Visual Studio 项目文件，然后在 Visual Studio 中打开并编译。</li><li>将生成的库文件和头文件添加到你的项目中。</li></ul></li><li><p><strong>使用 NuGet 包管理器</strong>：</p><ul><li>在 Visual Studio 中，右键点击你的项目，选择“管理 NuGet 包”。</li><li>搜索<code>jsoncpp</code>并安装。</li></ul></li><li><p><strong>替代库</strong>：</p><ul><li>如果<code>jsoncpp</code>不适合你的需求，可以考虑使用其他 JSON 库，比如<code>nlohmann/json</code>，它也可以通过<code>vcpkg</code>或<code>NuGet</code>安装。</li></ul></li></ol><p>通过以上方法，你应该能够在 Visual Studio 中使用<code>jsoncpp</code>库。希望这些建议对你有帮助！如果有其他问题，请随时问我。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;在 Windows 下使用 Microsoft Visual Studio 时，如果没有&lt;code&gt;jsoncpp&lt;/code&gt;库，你可以通过以下几种方式来解决这个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;使用 vcpkg 安装 jsoncpp</summary>
        
      
    
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>054-Microsoft Visual Studio 怎么编译c++项目, 项目中包含了.sln文件</title>
    <link href="https://hmmmmmya.github.io/2024/11/21/054-Microsoft-Visual-Studio-%E6%80%8E%E4%B9%88%E7%BC%96%E8%AF%91cpp-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%8C%85%E5%90%AB%E4%BA%86-sln%E6%96%87%E4%BB%B6/"/>
    <id>https://hmmmmmya.github.io/2024/11/21/054-Microsoft-Visual-Studio-%E6%80%8E%E4%B9%88%E7%BC%96%E8%AF%91cpp-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%8C%85%E5%90%AB%E4%BA%86-sln%E6%96%87%E4%BB%B6/</id>
    <published>2024-11-21T08:46:34.000Z</published>
    <updated>2024-11-21T08:56:28.721Z</updated>
    
    <content type="html"><![CDATA[<p>在 Microsoft Visual Studio 中编译包含 <code>.sln</code> 文件的 C++ 项目通常需要以下步骤：</p><span id="more"></span><h2 id="Microsoft-Visual-Studio-编译-c-项目"><a href="#Microsoft-Visual-Studio-编译-c-项目" class="headerlink" title="Microsoft Visual Studio 编译 c++ 项目"></a>Microsoft Visual Studio 编译 c++ 项目</h2><h3 id="步骤-1-打开解决方案"><a href="#步骤-1-打开解决方案" class="headerlink" title="步骤 1: 打开解决方案"></a><strong>步骤 1: 打开解决方案</strong></h3><ol><li>启动 Microsoft Visual Studio。</li><li>点击 <strong>“文件” -&gt; “打开” -&gt; “项目&#x2F;解决方案”</strong>。</li><li>浏览到包含 <code>.sln</code> 文件的目录，选择该文件，然后点击 <strong>“打开”</strong>。</li></ol><hr><h3 id="步骤-2-设置构建配置"><a href="#步骤-2-设置构建配置" class="headerlink" title="步骤 2: 设置构建配置"></a><strong>步骤 2: 设置构建配置</strong></h3><ol><li>在 Visual Studio 窗口的工具栏中找到 <strong>“解决方案配置”</strong> 下拉菜单（通常在右上角），选择合适的配置：<ul><li><strong>Debug</strong>：用于调试，包含调试信息，优化级别较低。</li><li><strong>Release</strong>：用于发布，优化级别较高，无调试信息。</li></ul></li><li>根据需要，选择 <strong>“平台”</strong>（如 x86 或 x64）。</li></ol><hr><h3 id="步骤-3-检查项目设置"><a href="#步骤-3-检查项目设置" class="headerlink" title="步骤 3: 检查项目设置"></a><strong>步骤 3: 检查项目设置</strong></h3><ol><li>在解决方案资源管理器（<strong>Solution Explorer</strong>）中右键单击项目名称，选择 <strong>“属性”</strong>。</li><li>在弹出的 <strong>“属性页”</strong> 中检查关键配置：<ul><li><strong>常规</strong>:<ul><li>确保 <strong>输出目录</strong> 和 <strong>中间目录</strong> 是合适的。</li></ul></li><li><strong>C&#x2F;C++</strong>:<ul><li>确保包含路径（Include Directories）正确。</li><li>根据需要设置警告等级、优化选项等。</li></ul></li><li><strong>链接器</strong>:<ul><li>确保库路径（Library Directories）正确。</li><li>确保引用的库文件（Additional Dependencies）正确。</li></ul></li></ul></li></ol><hr><h3 id="步骤-4-编译项目"><a href="#步骤-4-编译项目" class="headerlink" title="步骤 4: 编译项目"></a><strong>步骤 4: 编译项目</strong></h3><ol><li>在工具栏中点击 <strong>“生成” -&gt; “生成解决方案”</strong> 或按下快捷键 <code>Ctrl+Shift+B</code>。</li><li>Visual Studio 会开始编译项目，编译日志将显示在下方的 <strong>“输出”</strong> 窗口中。</li><li>如果没有错误，生成的可执行文件通常会保存在项目的 <code>Debug</code> 或 <code>Release</code> 文件夹中。</li></ol><hr><h3 id="步骤-5-运行项目"><a href="#步骤-5-运行项目" class="headerlink" title="步骤 5: 运行项目"></a><strong>步骤 5: 运行项目</strong></h3><ol><li>点击工具栏中的绿色箭头（<strong>“本地 Windows 调试器”</strong>），或者按下 <code>F5</code> 运行项目。</li><li>如果只想运行而不调试，可以按下 <code>Ctrl+F5</code>。</li></ol><hr><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a><strong>常见问题</strong></h3><ul><li><strong>缺少库文件</strong>：<ul><li>确保在项目属性中的 <strong>链接器 -&gt; 输入 -&gt; 附加依赖项</strong> 中添加了所有必要的库文件。</li></ul></li><li><strong>头文件找不到</strong>：<ul><li>确保在 <strong>C&#x2F;C++ -&gt; 常规 -&gt; 附加包含目录</strong> 中添加了所有必要的头文件路径。</li></ul></li><li><strong>编译错误</strong>：<ul><li>查看 <strong>“错误列表”</strong> 窗口中的错误信息，逐一修复。</li></ul></li></ul><p>按照以上步骤操作后，您应该能够成功编译和运行包含 <code>.sln</code> 文件的 C++ 项目。</p><h2 id="怎么看-Visual-Studio-中是否有某个头文件"><a href="#怎么看-Visual-Studio-中是否有某个头文件" class="headerlink" title="怎么看 Visual Studio 中是否有某个头文件"></a>怎么看 Visual Studio 中是否有某个头文件</h2><p>在 Microsoft Visual Studio 中检查某个头文件是否存在，可以通过以下几种方法：</p><hr><h3 id="方法-1-使用-IntelliSense"><a href="#方法-1-使用-IntelliSense" class="headerlink" title="方法 1: 使用 IntelliSense"></a><strong>方法 1: 使用 IntelliSense</strong></h3><ol><li>打开需要检查的 <code>.cpp</code> 或 <code>.h</code> 文件。</li><li>在代码中键入：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;your_header_file.h&quot;</span></span></span><br></pre></td></tr></table></figure></li><li>如果 IntelliSense 提示报错，例如 <strong>“Cannot open source file”</strong> 或波浪线，说明头文件未被找到或路径有问题。</li><li>如果没有错误提示，按住 <code>Ctrl</code> 并点击该头文件名称，Visual Studio 会尝试跳转到文件所在位置。</li></ol><hr><h3 id="方法-2-使用“转到文件”功能"><a href="#方法-2-使用“转到文件”功能" class="headerlink" title="方法 2: 使用“转到文件”功能"></a><strong>方法 2: 使用“转到文件”功能</strong></h3><ol><li>按下 <code>Ctrl+T</code> 或 <code>Ctrl+逗号</code> 打开“转到”窗口。</li><li>在弹出的输入框中，输入头文件的名称（例如 <code>your_header_file.h</code>）。</li><li>如果头文件存在并且在项目路径或已包含的目录中，Visual Studio 会列出相关文件。</li></ol><hr><h3 id="方法-3-检查包含路径"><a href="#方法-3-检查包含路径" class="headerlink" title="方法 3: 检查包含路径"></a><strong>方法 3: 检查包含路径</strong></h3><ol><li>在 <strong>解决方案资源管理器</strong> 中右键点击项目名称，选择 <strong>“属性”</strong>。</li><li>在 <strong>属性页</strong> 中导航到 <strong>C&#x2F;C++ -&gt; 常规 -&gt; 附加包含目录</strong>。</li><li>检查包含路径中是否包含目标头文件所在的目录。<ul><li>如果没有，将包含头文件的目录添加进去，格式如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(SolutionDir)include</span><br></pre></td></tr></table></figure></li><li>确保路径正确且文件确实在其中。</li></ul></li></ol><hr><h3 id="方法-4-全局文件搜索"><a href="#方法-4-全局文件搜索" class="headerlink" title="方法 4: 全局文件搜索"></a><strong>方法 4: 全局文件搜索</strong></h3><ol><li>按下 <code>Ctrl+Shift+F</code> 打开“查找文件”窗口。</li><li>在 <strong>“文件内容”</strong> 输入框中，输入头文件的名称（例如 <code>your_header_file.h</code>）。</li><li>设置查找范围为项目目录或整个解决方案。</li><li>点击 <strong>“查找全部”</strong>，如果文件存在，则会列出结果。</li></ol><hr><h3 id="方法-5-手动检查文件路径"><a href="#方法-5-手动检查文件路径" class="headerlink" title="方法 5: 手动检查文件路径"></a><strong>方法 5: 手动检查文件路径</strong></h3><ol><li>检查您的项目目录或代码仓库中是否存在目标头文件。</li><li>如果使用第三方库，检查库的 <code>include</code> 文件夹是否包含该头文件。</li><li>确保 <code>附加包含目录</code> 已正确配置。</li></ol><hr><h3 id="补充-确保头文件生效的注意事项"><a href="#补充-确保头文件生效的注意事项" class="headerlink" title="补充: 确保头文件生效的注意事项"></a><strong>补充: 确保头文件生效的注意事项</strong></h3><ul><li><strong>自定义头文件</strong>：确保头文件已添加到项目中。如果头文件未包含在解决方案中，右键项目 -&gt; 添加 -&gt; 现有项，将头文件加入到项目。</li><li><strong>第三方头文件</strong>：检查是否安装了相关的第三方库，并确保其路径正确。</li></ul><p>通过以上方法，您可以快速确认目标头文件是否在 Visual Studio 的项目中以及它的路径是否被正确配置。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 Microsoft Visual Studio 中编译包含 &lt;code&gt;.sln&lt;/code&gt; 文件的 C++ 项目通常需要以下步骤：&lt;/p&gt;</summary>
    
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/categories/c/"/>
    
    
  </entry>
  
  <entry>
    <title>053-localhost和127.0.0.1的关系</title>
    <link href="https://hmmmmmya.github.io/2024/11/20/053-localhost%E5%92%8C127-0-0-1%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <id>https://hmmmmmya.github.io/2024/11/20/053-localhost%E5%92%8C127-0-0-1%E7%9A%84%E5%85%B3%E7%B3%BB/</id>
    <published>2024-11-20T07:50:24.000Z</published>
    <updated>2024-11-20T08:17:34.085Z</updated>
    
    <content type="html"><![CDATA[<p><code>localhost</code> 和 <code>127.0.0.1</code> 都是指向本地主机的地址，但它们在使用上有一些细微的区别：</p><h3 id="1-127-0-0-1"><a href="#1-127-0-0-1" class="headerlink" title="1. 127.0.0.1"></a>1. <code>127.0.0.1</code></h3><ul><li><strong>IPv4 地址</strong>：<code>127.0.0.1</code> 是一个标准的 IPv4 地址，专门用于指向本地计算机。</li><li><strong>环回地址</strong>：它是一个环回地址，意味着任何发送到这个地址的数据包都会被返回到本地计算机。</li><li><strong>网络接口</strong>：通常与名为<code>lo</code>或<code>lo0</code>的网络接口绑定。</li></ul><h3 id="2-localhost"><a href="#2-localhost" class="headerlink" title="2. localhost"></a>2. <code>localhost</code></h3><ul><li><strong>主机名</strong>：<code>localhost</code> 是一个主机名，通常在系统的<code>/etc/hosts</code>文件中被解析为<code>127.0.0.1</code>。</li><li><strong>域名解析</strong>：在大多数系统中，<code>localhost</code> 被解析为<code>127.0.0.1</code>，但它也可以被配置为解析为其他地址（如 IPv6 的<code>::1</code>）。</li><li><strong>可配置性</strong>：用户可以在<code>/etc/hosts</code>文件中更改<code>localhost</code>的解析地址。</li></ul><h3 id="3-关系与区别"><a href="#3-关系与区别" class="headerlink" title="3. 关系与区别"></a>3. 关系与区别</h3><ul><li><strong>默认解析</strong>：在大多数情况下，<code>localhost</code> 默认解析为<code>127.0.0.1</code>，但它是通过域名解析系统（如<code>/etc/hosts</code>文件）实现的。</li><li><strong>IPv6 支持</strong>：<code>localhost</code> 也可以解析为 IPv6 地址<code>::1</code>，而<code>127.0.0.1</code>仅限于 IPv4。</li><li><strong>使用场景</strong>：在编程和网络配置中，使用<code>localhost</code>可以使代码更具可移植性，因为它不依赖于特定的 IP 地址。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>在大多数 Linux 系统中，<code>/etc/hosts</code>文件中会有如下配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1   localhost</span><br><span class="line">::1         localhost</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 localhost</span><br><span class="line">127.0.1.1 wt400</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">The following lines are desirable <span class="keyword">for</span> IPv6 capable hosts</span></span><br><span class="line">::1     ip6-localhost ip6-loopback</span><br><span class="line">fe00::0 ip6-localnet</span><br><span class="line">ff00::0 ip6-mcastprefix</span><br><span class="line">ff02::1 ip6-allnodes</span><br><span class="line">ff02::2 ip6-allrouters</span><br></pre></td></tr></table></figure><p>这意味着无论是 IPv4 还是 IPv6，<code>localhost</code>都会指向本地计算机。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong><code>127.0.0.1</code></strong> 是一个固定的 IPv4 地址，用于指向本地计算机。</li><li><strong><code>localhost</code></strong> 是一个主机名，通常解析为<code>127.0.0.1</code>，但可以配置为其他地址。</li><li>在大多数情况下，它们可以互换使用，但<code>localhost</code>提供了更大的灵活性和可移植性。</li><li>在终端中，ping <code>localhost</code> 和 <code>127.0.0.1</code> 的效果是一样的。都不经过网卡。</li></ul><h3 id="为什么-ping-127-0-0-1-不经过网卡？"><a href="#为什么-ping-127-0-0-1-不经过网卡？" class="headerlink" title="为什么 ping 127.0.0.1 不经过网卡？"></a>为什么 <code>ping 127.0.0.1</code> 不经过网卡？</h3><p><code>ping 127.0.0.1</code> 并不是测试网卡的连接，而是测试本机的网络协议栈（loopback interface）。它通过回环地址测试网络协议栈是否正常工作。具体来说：</p><ol><li><p><strong>127.0.0.1 的作用</strong></p><ul><li>它是回环地址，代表本机，无论网络接口的状态如何，都不会发送数据到外部网络设备。</li><li>即使你的网卡未连接到任何网络，<code>ping 127.0.0.1</code> 也会返回响应，因为它不依赖物理网卡。</li></ul></li><li><p><strong>测试范围</strong></p><ul><li>如果 <code>ping 127.0.0.1</code> 成功，说明操作系统的 TCP&#x2F;IP 协议栈正常工作。</li><li>如果失败，可能是 TCP&#x2F;IP 协议栈或相关配置出了问题，但与物理网卡无直接关系。</li></ul></li><li><p><strong>测试网卡的方法</strong></p><ul><li>使用 <code>ping</code> 测试网卡的 IP 地址（如 <code>ping 192.168.1.x</code>），确保网卡与局域网设备通信正常。</li><li>检查网卡硬件状态，可通过命令如 <code>ipconfig</code> (Windows) 或 <code>ifconfig</code> (Linux) 查看网卡是否被正确识别。</li><li>使用 <code>ethtool</code>（Linux）或设备管理器（Windows）进一步诊断。</li></ul></li></ol><p>简单来说，<code>ping 127.0.0.1</code> 仅能确认协议栈的正常性，不能完全验证网卡的工作状态。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;&lt;code&gt;localhost&lt;/code&gt; 和 &lt;code&gt;127.0.0.1&lt;/code&gt; 都是指向本地主机的地址，但它们在使用上有一些细微的区别：&lt;/p&gt;
&lt;h3 id=&quot;1-127-0-0-1&quot;&gt;&lt;a href=&quot;#1-127-0-0-1&quot;</summary>
        
      
    
    
    
    <category term="计算机网络" scheme="https://hmmmmmya.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>052-进程间通信</title>
    <link href="https://hmmmmmya.github.io/2024/11/19/052-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <id>https://hmmmmmya.github.io/2024/11/19/052-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</id>
    <published>2024-11-19T09:52:38.000Z</published>
    <updated>2024-11-20T08:38:57.907Z</updated>
    
    <content type="html"><![CDATA[<p>进程间通信(Inter-Process Communication, IPC)</p><span id="more"></span><h2 id="进程间通信有哪些方式"><a href="#进程间通信有哪些方式" class="headerlink" title="进程间通信有哪些方式"></a>进程间通信有哪些方式</h2><ul><li>共享内存</li><li>管道</li><li>消息队列</li><li>信号量</li><li>套接字</li></ul><p>进程间通信（IPC）的连接可以通过多种机制建立，每种机制都有其特定的用途和实现方式。以下是几种常见的 IPC 机制及其连接建立方式：</p><h3 id="1-管道（Pipe）"><a href="#1-管道（Pipe）" class="headerlink" title="1. 管道（Pipe）"></a>1. 管道（Pipe）</h3><ul><li><p><strong>匿名管道</strong></p><ul><li>只能在父子进程之间使用</li><li>通过<code>pipe()</code>系统调用创建</li><li>创建后返回两个文件描述符：一个用于读，一个用于写</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">if</span> (pipe(pipefd) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>命名管道（FIFO）</strong></p><ul><li>可以在无亲缘关系的进程间使用</li><li>通过<code>mkfifo()</code>创建一个特殊文件</li><li>进程通过打开这个文件进行读写</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfifo(<span class="string">&quot;/tmp/myfifo&quot;</span>, <span class="number">0666</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-消息队列"><a href="#2-消息队列" class="headerlink" title="2. 消息队列"></a>2. 消息队列</h3><ul><li><p>通过<code>msgget()</code>创建或获取一个消息队列标识符</p></li><li><p>使用<code>msgsnd()</code>和<code>msgrcv()</code>进行消息发送和接收</p></li><li><p>使用<code>msgctl()</code>进行消息队列控制，如删除消息队列或修改消息队列的权限</p></li><li><p>消息队列是基于消息的，消息队列是保存在内核中的链表，消息队列中每个消息都有一个类型和优先级</p></li><li><p>支持多进程并发访问</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">key_t</span> key = ftok(<span class="string">&quot;progfile&quot;</span>, <span class="number">65</span>);</span><br><span class="line"><span class="type">int</span> msgid = msgget(key, <span class="number">0666</span> | IPC_CREAT);</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-共享内存"><a href="#3-共享内存" class="headerlink" title="3. 共享内存"></a>3. 共享内存</h3><ul><li><p>使用共享内存的很重要原因是性能，内核为需要通信的进程分配了一块内存，进程可以直接访问这块内存，不需要内核介入</p></li><li><p>当进程不再希望共享内存时，通过<code>shmdt()</code>将共享内存段从进程的地址空间分离，取消共享内存段与进程的地址空间的映射，只影响当前进程，其他正在使用共享内存的进程不受影响</p></li><li><p>通过<code>shmget()</code>创建或获取一个共享内存段</p></li><li><p>使用<code>shmat()</code>将共享内存段附加到进程的地址空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">key_t</span> key = ftok(<span class="string">&quot;shmfile&quot;</span>, <span class="number">65</span>);</span><br><span class="line"><span class="type">int</span> shmid = shmget(key, <span class="number">1024</span>, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line"><span class="type">char</span> *str = (<span class="type">char</span>*) shmat(shmid, (<span class="type">void</span>*)<span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-信号量"><a href="#4-信号量" class="headerlink" title="4. 信号量"></a>4. 信号量</h3><ul><li><p>信号量是用于进程间同步的机制</p></li><li><p>信号量的主要操作是两个原语：<code>P</code>操作和<code>V</code>操作，计数器值只能在 0 和 1 之间变化</p><ul><li><code>P</code>操作：计数器减一，如果计数器为 0，无法减一，则阻塞，直至计数器大于 0，减一成功</li><li><code>V</code>操作：计数器加一，如果计数器超过 1，则无法加一，忽略本次操作</li></ul></li><li><p>通过<code>semget()</code>创建或获取一个信号量集</p></li><li><p>使用<code>semop()</code>进行信号量操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">key_t</span> key = ftok(<span class="string">&quot;semfile&quot;</span>, <span class="number">65</span>);</span><br><span class="line"><span class="type">int</span> semid = semget(key, <span class="number">1</span>, <span class="number">0666</span> | IPC_CREAT);</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-套接字（Sockets）"><a href="#5-套接字（Sockets）" class="headerlink" title="5. 套接字（Sockets）"></a>5. 套接字（Sockets）</h3><ul><li><p><strong>本地套接字（UNIX 域套接字）</strong></p><ul><li>通过<code>socket()</code>创建</li><li>使用<code>bind()</code>、<code>listen()</code>、<code>accept()</code>建立连接</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sockfd = socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span></span><br><span class="line">addr.sun_family = AF_UNIX;</span><br><span class="line"><span class="built_in">strcpy</span>(addr.sun_path, <span class="string">&quot;/tmp/mysocket&quot;</span>);</span><br><span class="line">bind(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">listen(sockfd, <span class="number">5</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>网络套接字</strong></p><ul><li>用于不同主机间的通信</li><li>通过<code>socket()</code>创建</li><li>使用<code>connect()</code>、<code>bind()</code>、<code>listen()</code>、<code>accept()</code>建立连接</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">addr.sin_family = AF_INET;</span><br><span class="line">addr.sin_port = htons(<span class="number">8080</span>);</span><br><span class="line">addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">bind(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">listen(sockfd, <span class="number">5</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="6-信号"><a href="#6-信号" class="headerlink" title="6. 信号"></a>6. 信号</h3><ul><li><p>通过<code>kill()</code>发送信号</p></li><li><p>进程通过<code>signal()</code>或<code>sigaction()</code>设置信号处理函数</p></li><li><p>Linux 常规信号有 32 个，信号值范围为 1-31，信号值为 0 的信号通常用于进程间同步；POSIX 引入了 32 个信号（实时信号），信号值范围为 32-64</p></li><li><p>使用信号，一个进程可以随时通知另一个进程某个事件的发生，并且接收者不需要阻塞等待该事件，内核会帮助其切换到对应的处理函数中响应信号事件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">signal(SIGUSR1, handler_function);</span><br><span class="line">kill(pid, SIGUSR1);</span><br></pre></td></tr></table></figure></li></ul><h4 id="信号表"><a href="#信号表" class="headerlink" title="信号表"></a>信号表</h4><p>在终端，可通过<code>kill -l</code>查看所有的 signal 信号。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">:~$ kill -l</span><br><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP</span><br><span class="line"> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</span><br><span class="line">11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</span><br><span class="line">16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP</span><br><span class="line">21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR</span><br><span class="line">31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1  64) SIGRTMAX</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20241120143758.png" alt="宏内核进程间通信机制对比"></p><h2 id="请给出一个管道的设计-使其支持双向通信"><a href="#请给出一个管道的设计-使其支持双向通信" class="headerlink" title="请给出一个管道的设计,使其支持双向通信"></a>请给出一个管道的设计,使其支持双向通信</h2><p>实现双向通信的管道可以通过创建两个单向管道来完成，一个用于从 A 到 B 的通信，另一个用于从 B 到 A 的通信。以下是实现双向管道通信的设计方案：</p><hr><h3 id="1-管道结构设计"><a href="#1-管道结构设计" class="headerlink" title="1. 管道结构设计"></a>1. <strong>管道结构设计</strong></h3><ul><li><strong>管道 A-&gt;B</strong>: 一个单向管道，负责从进程 A 向进程 B 发送数据。</li><li><strong>管道 B-&gt;A</strong>: 另一个单向管道，负责从进程 B 向进程 A 发送数据。</li></ul><hr><h3 id="2-关键步骤"><a href="#2-关键步骤" class="headerlink" title="2. 关键步骤"></a>2. <strong>关键步骤</strong></h3><p>假设使用 C 语言和 POSIX 标准管道 (<code>pipe</code>)：</p><h4 id="1-创建管道"><a href="#1-创建管道" class="headerlink" title="(1) 创建管道"></a><strong>(1) 创建管道</strong></h4><p>每个管道由一对文件描述符表示：<code>fd[0]</code> 用于读，<code>fd[1]</code> 用于写。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pipeAB[<span class="number">2</span>]; <span class="comment">// A-&gt;B</span></span><br><span class="line"><span class="type">int</span> pipeBA[<span class="number">2</span>]; <span class="comment">// B-&gt;A</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建两个单向管道</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">pipe</span>(pipeAB) == <span class="number">-1</span> || <span class="built_in">pipe</span>(pipeBA) == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-在父子进程间通信"><a href="#2-在父子进程间通信" class="headerlink" title="(2) 在父子进程间通信"></a><strong>(2) 在父子进程间通信</strong></h4><ul><li><strong>父进程 A</strong>: 关闭 <code>pipeAB[0]</code> 和 <code>pipeBA[1]</code>，仅用于写入到 <code>pipeAB</code> 和读取 <code>pipeBA</code>。</li><li><strong>子进程 B</strong>: 关闭 <code>pipeAB[1]</code> 和 <code>pipeBA[0]</code>，仅用于读取 <code>pipeAB</code> 和写入到 <code>pipeBA</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 子进程B</span></span><br><span class="line">    <span class="built_in">close</span>(pipeAB[<span class="number">1</span>]); <span class="comment">// 关闭写端</span></span><br><span class="line">    <span class="built_in">close</span>(pipeBA[<span class="number">0</span>]); <span class="comment">// 关闭读端</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">256</span>];</span><br><span class="line">    <span class="comment">// 从 A-&gt;B 读取数据</span></span><br><span class="line">    <span class="built_in">read</span>(pipeAB[<span class="number">0</span>], buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;B received: %s\n&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向 B-&gt;A 写入数据</span></span><br><span class="line">    <span class="built_in">write</span>(pipeBA[<span class="number">1</span>], <span class="string">&quot;Hello A&quot;</span>, <span class="number">7</span>);</span><br><span class="line">    <span class="built_in">close</span>(pipeAB[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">close</span>(pipeBA[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 父进程A</span></span><br><span class="line">    <span class="built_in">close</span>(pipeAB[<span class="number">0</span>]); <span class="comment">// 关闭读端</span></span><br><span class="line">    <span class="built_in">close</span>(pipeBA[<span class="number">1</span>]); <span class="comment">// 关闭写端</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向 A-&gt;B 写入数据</span></span><br><span class="line">    <span class="built_in">write</span>(pipeAB[<span class="number">1</span>], <span class="string">&quot;Hello B&quot;</span>, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">256</span>];</span><br><span class="line">    <span class="comment">// 从 B-&gt;A 读取数据</span></span><br><span class="line">    <span class="built_in">read</span>(pipeBA[<span class="number">0</span>], buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;A received: %s\n&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(pipeAB[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">close</span>(pipeBA[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-使用-select-或-poll-支持异步通信"><a href="#3-使用-select-或-poll-支持异步通信" class="headerlink" title="3. 使用 select 或 poll 支持异步通信"></a>3. <strong>使用 <code>select</code> 或 <code>poll</code> 支持异步通信</strong></h3><p>为了避免阻塞，可使用 <code>select</code> 或 <code>poll</code> 对管道的读写操作进行多路复用，检查管道是否有数据可读。</p><hr><h3 id="4-其他方案"><a href="#4-其他方案" class="headerlink" title="4. 其他方案"></a>4. <strong>其他方案</strong></h3><p>除了 POSIX 管道，还可以使用以下方法实现双向通信：</p><ol><li><strong>Socket</strong>: 使用 <code>socketpair</code> 创建全双工通信。</li><li><strong>消息队列</strong>: 使用 System V 或 POSIX 消息队列。</li><li><strong>共享内存</strong>: 配合信号量实现双向通信。</li><li><strong>FIFO（命名管道）</strong>: 通过创建两个命名管道实现双向通信。</li></ol><p>选择哪种方式取决于具体的应用场景和需求。如果是本地进程间通信，<code>pipe</code> 和 <code>socketpair</code> 是推荐的简单方案。</p><h3 id="选择合适的-IPC-机制"><a href="#选择合适的-IPC-机制" class="headerlink" title="选择合适的 IPC 机制"></a>选择合适的 IPC 机制</h3><ul><li><strong>管道</strong>适合简单的父子进程通信</li><li><strong>消息队列</strong>适合需要消息排序和优先级的场景</li><li><strong>共享内存</strong>适合需要高效大数据量传输的场景</li><li><strong>信号量</strong>常用于进程间同步</li><li><strong>套接字</strong>适合网络通信或复杂的本地通信</li></ul><p>每种 IPC 机制都有其特定的应用场景和优缺点，选择时应根据具体需求和系统环境进行权衡。</p><h2 id="在进程间通信过程中-数据和控制流分别是如何传输和转移的"><a href="#在进程间通信过程中-数据和控制流分别是如何传输和转移的" class="headerlink" title="在进程间通信过程中, 数据和控制流分别是如何传输和转移的"></a>在进程间通信过程中, 数据和控制流分别是如何传输和转移的</h2><p>一种常见的通信数据的抽象是消息。消息一般包含消息头和消息体。消息头中包含消息类型、消息长度、消息优先级等控制信息，消息体中包含实际需要传输的数据。</p><h2 id="进程间通信的连接是如何建立的"><a href="#进程间通信的连接是如何建立的" class="headerlink" title="进程间通信的连接是如何建立的"></a>进程间通信的连接是如何建立的</h2><p>通信过程一般指通信的进程间具体的通信发起、回复、结束的过程。</p><p>发送者将要传输的数据内容拷贝到发送者消息上，然后一次设置头部的状态（设置为“准备就绪”等）。</p><p>接收者不停地轮询发送者消息的状态信息，当发现消息头部的状态变为“准备就绪”时，就表示发送者发送了一个消息。</p><p>发送者一发送完消息，就开始轮询接收者消息的状态信息，当发现接收者消息头部的状态变为“准备就绪”时，就表示接收者接收到了一个消息。</p><p>接收者在读取发送者的消息后，处理请求，并在接受者消息上准备返回结果。</p><p>发送者不停地轮询接收者消息的状态信息，当发现接收者消息头部的状态变为“返回结果”时，就表示接收者处理完了消息，并准备返回结果。</p><p>发送者读取接收者消息中的返回结果，并从消息中删除返回结果。</p><h3 id="直接通信和间接通信"><a href="#直接通信和间接通信" class="headerlink" title="直接通信和间接通信"></a>直接通信和间接通信</h3><p>直接通信：发送者和接收者都知道彼此的标识符。比如进程号。</p><p>间接通信：发送者和接收者不知道彼此的标识符，需要一个中间实体（如消息队列、共享内存、管道等）来传递消息。</p><h2 id="什么是超时机制-为什么需要超时机制"><a href="#什么是超时机制-为什么需要超时机制" class="headerlink" title="什么是超时机制, 为什么需要超时机制"></a>什么是超时机制, 为什么需要超时机制</h2><p>超时机制是进程间通信中的一种机制，用于处理通信过程中可能出现的延迟或失败情况。允许发送者&#x2F;接收者设置一个超时时间，如果在这个时间内没有收到回复，则认为通信失败。由操作系统内核结束此次 IPC 调用，返回一个超时的错误。</p><h2 id="一个进程如何找到另一个进程提供的服务"><a href="#一个进程如何找到另一个进程提供的服务" class="headerlink" title="一个进程如何找到另一个进程提供的服务"></a>一个进程如何找到另一个进程提供的服务</h2><p>一个进程找到另一个进程提供的服务，可以通过以下几种常见的通信机制实现，具体选择取决于操作系统环境和应用场景：</p><hr><h3 id="1-使用命名管道-FIFO"><a href="#1-使用命名管道-FIFO" class="headerlink" title="1. 使用命名管道 (FIFO)"></a><strong>1. 使用命名管道 (FIFO)</strong></h3><ul><li><strong>适用场景</strong>: 本地进程间通信，简单高效。</li><li><strong>实现步骤</strong>:<ol><li>服务端创建一个命名管道（FIFO）。</li><li>客户端打开该命名管道进行读写。</li><li>使用文件路径标识管道。</li></ol></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端</span></span><br><span class="line"><span class="built_in">mkfifo</span>(<span class="string">&quot;/tmp/myservice&quot;</span>, <span class="number">0666</span>); <span class="comment">// 创建命名管道</span></span><br><span class="line"><span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;/tmp/myservice&quot;</span>, O_RDONLY); <span class="comment">// 打开管道用于读取</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;/tmp/myservice&quot;</span>, O_WRONLY); <span class="comment">// 打开管道用于写入</span></span><br><span class="line"><span class="built_in">write</span>(fd, <span class="string">&quot;Hello Service&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;Hello Service&quot;</span>));</span><br></pre></td></tr></table></figure><hr><h3 id="2-使用套接字（Socket）"><a href="#2-使用套接字（Socket）" class="headerlink" title="2. 使用套接字（Socket）"></a><strong>2. 使用套接字（Socket）</strong></h3><ul><li><strong>适用场景</strong>: 本地或分布式场景，通过网络通信。</li><li><strong>实现步骤</strong>:<ol><li>服务端监听一个固定的地址和端口。</li><li>客户端通过地址和端口连接到服务端。</li></ol></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端</span></span><br><span class="line"><span class="type">int</span> server_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address = &#123; ... &#125;; <span class="comment">// 设置地址和端口</span></span><br><span class="line"><span class="built_in">bind</span>(server_fd, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="built_in">sizeof</span>(address));</span><br><span class="line"><span class="built_in">listen</span>(server_fd, <span class="number">3</span>);</span><br><span class="line"><span class="type">int</span> client_fd = <span class="built_in">accept</span>(server_fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>); <span class="comment">// 等待客户端连接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="type">int</span> client_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">connect</span>(client_fd, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="built_in">sizeof</span>(address));</span><br><span class="line"><span class="built_in">write</span>(client_fd, <span class="string">&quot;Hello Service&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;Hello Service&quot;</span>));</span><br></pre></td></tr></table></figure><hr><h3 id="3-使用共享内存"><a href="#3-使用共享内存" class="headerlink" title="3. 使用共享内存"></a><strong>3. 使用共享内存</strong></h3><ul><li><strong>适用场景</strong>: 本地进程间通信，数据量大且需要高效。</li><li><strong>实现步骤</strong>:<ol><li>服务端创建一个共享内存段并设置标识符。</li><li>客户端通过标识符访问共享内存。</li><li>使用信号量或互斥锁同步访问。</li></ol></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端</span></span><br><span class="line"><span class="type">int</span> shm_id = <span class="built_in">shmget</span>(<span class="number">1234</span>, <span class="number">1024</span>, IPC_CREAT | <span class="number">0666</span>); <span class="comment">// 创建共享内存</span></span><br><span class="line"><span class="type">char</span>* shm_ptr = (<span class="type">char</span>*)<span class="built_in">shmat</span>(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">// 映射到地址空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="type">int</span> shm_id = <span class="built_in">shmget</span>(<span class="number">1234</span>, <span class="number">1024</span>, <span class="number">0666</span>); <span class="comment">// 获取共享内存</span></span><br><span class="line"><span class="type">char</span>* shm_ptr = (<span class="type">char</span>*)<span class="built_in">shmat</span>(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">// 映射到地址空间</span></span><br></pre></td></tr></table></figure><hr><h3 id="4-使用系统总线-如-D-Bus-或-ZeroMQ"><a href="#4-使用系统总线-如-D-Bus-或-ZeroMQ" class="headerlink" title="4. 使用系统总线 (如 D-Bus 或 ZeroMQ)"></a><strong>4. 使用系统总线 (如 D-Bus 或 ZeroMQ)</strong></h3><ul><li><strong>适用场景</strong>: 复杂系统，支持服务发现和消息路由。</li><li><strong>实现步骤</strong>:<ol><li>服务端注册服务到消息总线。</li><li>客户端通过总线查找服务。</li></ol></li></ul><hr><h3 id="5-使用文件描述符或信号"><a href="#5-使用文件描述符或信号" class="headerlink" title="5. 使用文件描述符或信号"></a><strong>5. 使用文件描述符或信号</strong></h3><ul><li><strong>适用场景</strong>: 简单标识服务状态。</li><li><strong>实现方式</strong>:<ul><li>服务端创建特定文件（如 Unix 域套接字文件）。</li><li>客户端通过文件路径定位服务。</li></ul></li></ul><hr><h3 id="6-使用注册表或配置文件"><a href="#6-使用注册表或配置文件" class="headerlink" title="6. 使用注册表或配置文件"></a><strong>6. 使用注册表或配置文件</strong></h3><ul><li><strong>适用场景</strong>: 服务动态发布或客户端动态查找。</li><li><strong>实现方式</strong>:<ul><li>服务端将自身信息（如 PID、套接字地址）写入文件或注册表。</li><li>客户端读取该文件查找服务。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端</span></span><br><span class="line">FILE* f = <span class="built_in">fopen</span>(<span class="string">&quot;/tmp/service_info&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(f, <span class="string">&quot;127.0.0.1:8080\n&quot;</span>); <span class="comment">// 写入服务信息</span></span><br><span class="line"><span class="built_in">fclose</span>(f);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line">FILE* f = <span class="built_in">fopen</span>(<span class="string">&quot;/tmp/service_info&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="type">char</span> service_address[<span class="number">256</span>];</span><br><span class="line"><span class="built_in">fgets</span>(service_address, <span class="built_in">sizeof</span>(service_address), f);</span><br></pre></td></tr></table></figure><hr><h3 id="7-服务发现协议"><a href="#7-服务发现协议" class="headerlink" title="7. 服务发现协议"></a><strong>7. 服务发现协议</strong></h3><ul><li><strong>适用场景</strong>: 动态服务发现，分布式系统。</li><li><strong>实现方式</strong>:<ul><li>使用诸如 <code>mDNS</code>、<code>Consul</code> 等服务发现工具。</li><li>服务端注册到发现工具，客户端通过工具查找服务。</li></ul></li></ul><hr><h3 id="综合建议"><a href="#综合建议" class="headerlink" title="综合建议"></a><strong>综合建议</strong></h3><ul><li><strong>本地简单通信</strong>: 命名管道、共享内存。</li><li><strong>本地或远程灵活通信</strong>: Socket。</li><li><strong>动态服务发现</strong>: 服务总线或专用工具（如 Consul）。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;进程间通信(Inter-Process Communication, IPC)&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="https://hmmmmmya.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>051-使用cmake编译项目</title>
    <link href="https://hmmmmmya.github.io/2024/11/19/051-%E4%BD%BF%E7%94%A8cmake%E7%BC%96%E8%AF%91%E9%A1%B9%E7%9B%AE/"/>
    <id>https://hmmmmmya.github.io/2024/11/19/051-%E4%BD%BF%E7%94%A8cmake%E7%BC%96%E8%AF%91%E9%A1%B9%E7%9B%AE/</id>
    <published>2024-11-19T09:43:16.000Z</published>
    <updated>2024-11-19T09:44:01.767Z</updated>
    
    <content type="html"><![CDATA[<p>要编译一个已有 <code>CMakeLists.txt</code> 文件的 C++ 项目，你需要按照以下步骤进行操作：</p><span id="more"></span><h2 id="CMake-和-make"><a href="#CMake-和-make" class="headerlink" title="CMake 和 make"></a>CMake 和 make</h2><h3 id="1-确保安装了-CMake-和编译工具"><a href="#1-确保安装了-CMake-和编译工具" class="headerlink" title="1. 确保安装了 CMake 和编译工具"></a>1. <strong>确保安装了 CMake 和编译工具</strong></h3><p>首先，确保你的系统已经安装了 <code>CMake</code> 和适当的 C++ 编译工具。具体取决于你的操作系统，下面是一些常见的安装方式：</p><ul><li><strong>Windows</strong>：安装 <a href="https://cmake.org/download/">CMake</a> 和 <strong>Visual Studio</strong> 或 <strong>MinGW</strong>（如果你使用的是命令行编译器）。</li><li><strong>Linux&#x2F;Mac</strong>：可以通过包管理器安装 <code>CMake</code> 和 <code>g++</code> 编译器：<ul><li>Linux: <code>sudo apt-get install cmake g++</code></li><li>macOS: <code>brew install cmake</code>（如果使用 Homebrew）</li></ul></li></ul><h3 id="2-创建构建目录"><a href="#2-创建构建目录" class="headerlink" title="2. 创建构建目录"></a>2. <strong>创建构建目录</strong></h3><p>通常我们不直接在项目的根目录中进行构建，而是创建一个单独的构建目录，这样可以保持项目目录的整洁。</p><p>在项目的根目录下，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br></pre></td></tr></table></figure><h3 id="3-运行-CMake-配置项目"><a href="#3-运行-CMake-配置项目" class="headerlink" title="3. 运行 CMake 配置项目"></a>3. <strong>运行 CMake 配置项目</strong></h3><p>在构建目录中，使用 <code>cmake</code> 命令来配置项目。这会生成平台特定的构建文件（如 Makefile 或 Visual Studio 工程文件）。你可以指定源代码的目录（即 <code>CMakeLists.txt</code> 文件所在的目录）。</p><p>假设 <code>CMakeLists.txt</code> 文件在上级目录，你可以运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake ..</span><br></pre></td></tr></table></figure><p>这个命令会让 CMake 读取上级目录中的 <code>CMakeLists.txt</code> 文件，并生成相应的构建配置。如果没有问题，CMake 会自动检测到编译工具链并设置好相关构建配置。</p><p>如果你想指定编译器或者生成不同的构建文件格式（例如使用 Visual Studio 或者 Ninja），可以使用 <code>-G</code> 选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cmake .. -G <span class="string">&quot;Visual Studio 16 2019&quot;</span>  <span class="comment"># 如果你使用 Visual Studio 2019</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">cmake .. -G <span class="string">&quot;Ninja&quot;</span>  <span class="comment"># 如果你使用 Ninja 作为构建工具</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">cmake .. -G <span class="string">&quot;NMake Makefiles&quot;</span> <span class="comment"># 如果你使用 MinGW</span></span><br></pre></td></tr></table></figure><h3 id="4-编译项目"><a href="#4-编译项目" class="headerlink" title="4. 编译项目"></a>4. <strong>编译项目</strong></h3><p>一旦 CMake 配置完毕，接下来可以进行编译：</p><ul><li><p><strong>如果你使用的是 Makefile</strong>，可以运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure></li><li><p><strong>如果你使用的是 Visual Studio</strong>，你可以直接打开生成的 <code>.sln</code> 文件并通过 Visual Studio 编译，或者在命令行中使用 <code>MSBuild</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msbuild your_project.sln</span><br></pre></td></tr></table></figure></li><li><p><strong>如果你使用的是 Ninja</strong>，可以直接运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ninja</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-运行程序"><a href="#5-运行程序" class="headerlink" title="5. 运行程序"></a>5. <strong>运行程序</strong></h3><p>编译成功后，生成的可执行文件会放在构建目录中（具体位置取决于 <code>CMakeLists.txt</code> 配置）。你可以运行它：</p><ul><li><p>在 Linux&#x2F;macOS 中，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./your_executable</span><br></pre></td></tr></table></figure></li><li><p>在 Windows 中，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">your_executable.exe</span><br></pre></td></tr></table></figure></li></ul><h3 id="6-清理构建文件（可选）"><a href="#6-清理构建文件（可选）" class="headerlink" title="6. 清理构建文件（可选）"></a>6. <strong>清理构建文件（可选）</strong></h3><p>如果你想清理构建目录并重新构建，可以使用以下命令：</p><ul><li><p>使用 <strong>CMake</strong> 清理构建文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --build . --target clean</span><br></pre></td></tr></table></figure></li><li><p>或者直接删除构建目录中的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf *</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="总结步骤"><a href="#总结步骤" class="headerlink" title="总结步骤"></a>总结步骤</h3><ol><li>创建 <code>build</code> 目录：<code>mkdir build &amp;&amp; cd build</code></li><li>运行 <code>cmake ..</code> 配置项目。</li><li>使用 <code>make</code>、<code>ninja</code> 或者 Visual Studio 等工具进行编译。</li><li>执行生成的可执行文件。</li></ol><h2 id="配置编译器"><a href="#配置编译器" class="headerlink" title="配置编译器"></a>配置编译器</h2><p>直接使用 <code>cmake</code> 命令可能失败，因为 <code>cmake</code> 找不到默认的编译器，这时需要指定编译器。</p><p>可以在运行 CMake 时指定 MinGW 编译器。使用 <code>-D</code> 参数设置 <code>CMAKE_C_COMPILER</code> 和 <code>CMAKE_CXX_COMPILER</code> 变量。假设你的 MinGW 安装在默认位置，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake .. -G <span class="string">&quot;MinGW Makefiles&quot;</span> -D CMAKE_C_COMPILER=gcc -D CMAKE_CXX_COMPILER=g++</span><br></pre></td></tr></table></figure><p>如果需要指定 MinGW 的完整路径（推荐这样做以避免路径问题），可以这样写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake .. -G <span class="string">&quot;MinGW Makefiles&quot;</span> -D CMAKE_C_COMPILER=<span class="string">&quot;D:/mingw64/bin/gcc.exe&quot;</span> -D CMAKE_CXX_COMPILER=<span class="string">&quot;D:/mingw64/bin/g++.exe&quot;</span></span><br></pre></td></tr></table></figure><p>请根据你的 MinGW 实际安装路径调整上述路径。</p><p>你也可以通过设置环境变量 <code>CC</code> 和 <code>CXX</code> 来指定编译器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> CC=D:/mingw64/bin/gcc.exe</span><br><span class="line"><span class="built_in">set</span> CXX=D:/mingw64/bin/g++.exe</span><br><span class="line">cmake .. -G <span class="string">&quot;MinGW Makefiles&quot;</span></span><br></pre></td></tr></table></figure><p>如果你想让这个设置持久化，可以将编译器路径添加到你的 CMake 设置文件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;cmake.sourceDirectory&quot;: &quot;D:/Code/GitHub/hello-algo/codes/cpp&quot;,</span><br><span class="line">    &quot;cmake.cmakePath&quot;: &quot;D:/software/CMake/cmake-3.31.0-windows-x86_64/bin/cmake.exe&quot;,</span><br><span class="line">    &quot;cmake.configureSettings&quot;: &#123;</span><br><span class="line">        &quot;CMAKE_C_COMPILER&quot;: &quot;D:/mingw64/bin/gcc.exe&quot;,</span><br><span class="line">        &quot;CMAKE_CXX_COMPILER&quot;: &quot;D:/mingw64/bin/g++.exe&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;cmake.generator&quot;: &quot;MinGW Makefiles&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记得替换为你系统中 MinGW 的实际安装路径。</p><p>如果指定生成器失败，可以用 <code>cmake .. -G &quot;NMake Makefiles&quot;</code> 来指定生成器。</p><p>在项目根目录下运行 <code>cmake --list-generators</code> 可以查看所有可用的生成器。能看到默认的生成器。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;要编译一个已有 &lt;code&gt;CMakeLists.txt&lt;/code&gt; 文件的 C++ 项目，你需要按照以下步骤进行操作：&lt;/p&gt;</summary>
    
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/categories/c/"/>
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>050-线程与进程</title>
    <link href="https://hmmmmmya.github.io/2024/11/19/050-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/"/>
    <id>https://hmmmmmya.github.io/2024/11/19/050-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/</id>
    <published>2024-11-19T08:33:17.000Z</published>
    <updated>2024-11-19T08:47:22.694Z</updated>
    
    <content type="html"><![CDATA[<p>进程是操作系统对一个正在运行的程序的一种抽象。线程是进程中的一个执行单元。</p><span id="more"></span><h2 id="为什么不用类似于-fork-的方式创建线程"><a href="#为什么不用类似于-fork-的方式创建线程" class="headerlink" title="为什么不用类似于 fork 的方式创建线程"></a>为什么不用类似于 fork 的方式创建线程</h2><h3 id="fork-创建进程的特点"><a href="#fork-创建进程的特点" class="headerlink" title="fork 创建进程的特点"></a>fork 创建进程的特点</h3><ol><li><strong>资源复制</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> pid = fork();</span><br><span class="line"><span class="comment">// fork会复制：</span></span><br><span class="line"><span class="comment">// - 内存空间</span></span><br><span class="line"><span class="comment">// - 文件描述符</span></span><br><span class="line"><span class="comment">// - 程序计数器</span></span><br><span class="line"><span class="comment">// 等所有资源</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>开销大</strong><ul><li>需要复制整个进程地址空间</li><li>创建新的页表</li><li>复制文件描述符表</li></ul></li></ol><h3 id="线程的设计目的"><a href="#线程的设计目的" class="headerlink" title="线程的设计目的"></a>线程的设计目的</h3><ol><li><strong>轻量级任务切换</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_t</span> thread;</span><br><span class="line">pthread_create(&amp;thread, <span class="literal">NULL</span>, thread_func, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 线程共享：</span></span><br><span class="line"><span class="comment">// - 代码段</span></span><br><span class="line"><span class="comment">// - 堆空间</span></span><br><span class="line"><span class="comment">// - 文件描述符</span></span><br><span class="line"><span class="comment">// 仅独立：</span></span><br><span class="line"><span class="comment">// - 栈空间</span></span><br><span class="line"><span class="comment">// - 寄存器</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>资源共享优势</strong><ul><li>线程间通信成本低</li><li>上下文切换快</li><li>内存占用小</li></ul></li></ol><h3 id="如果用-fork-方式创建线程会带来的问题"><a href="#如果用-fork-方式创建线程会带来的问题" class="headerlink" title="如果用 fork 方式创建线程会带来的问题"></a>如果用 fork 方式创建线程会带来的问题</h3><ol><li><strong>性能问题</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">创建100个线程：</span><br><span class="line">- 当前方式：只需要分配100个栈空间</span><br><span class="line">- fork方式：需要复制100次整个进程空间</span><br></pre></td></tr></table></figure><ol start="2"><li><p><strong>资源浪费</strong></p><ul><li>大量重复的内存页</li><li>不必要的资源隔离</li><li>系统开销增加</li></ul></li><li><p><strong>通信困难</strong></p><ul><li>失去了共享内存的便利</li><li>需要使用 IPC 机制</li><li>效率降低</li></ul></li></ol><p>因此，线程的设计初衷就是要比进程更轻量级，如果用 fork 方式创建线程，就违背了这个设计初衷，失去了线程的主要优势。</p><h2 id="Linux-中-一个多线程进程使用-fork-生成了一个新进程-新进程中会存在几个线程-为什么要这么设计"><a href="#Linux-中-一个多线程进程使用-fork-生成了一个新进程-新进程中会存在几个线程-为什么要这么设计" class="headerlink" title="Linux 中,一个多线程进程使用 fork 生成了一个新进程, 新进程中会存在几个线程? 为什么要这么设计"></a>Linux 中,一个多线程进程使用 fork 生成了一个新进程, 新进程中会存在几个线程? 为什么要这么设计</h2><p>让我解释 Linux 中 fork 多线程进程的行为：</p><h3 id="基本行为"><a href="#基本行为" class="headerlink" title="基本行为"></a>基本行为</h3><ol><li><strong>只复制调用 fork 的线程</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主进程有3个线程</span></span><br><span class="line"><span class="type">pthread_t</span> thread1, thread2;</span><br><span class="line">pthread_create(&amp;thread1, <span class="literal">NULL</span>, func1, <span class="literal">NULL</span>);</span><br><span class="line">pthread_create(&amp;thread2, <span class="literal">NULL</span>, func2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> pid = fork();  <span class="comment">// 假设在thread1中调用</span></span><br><span class="line"><span class="comment">// 子进程只会包含thread1的副本</span></span><br></pre></td></tr></table></figure><h3 id="为什么这样设计"><a href="#为什么这样设计" class="headerlink" title="为什么这样设计"></a>为什么这样设计</h3><ol><li><strong>安全性考虑</strong><ul><li>如果复制所有线程，可能导致：</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程2正在进行文件写入</span></span><br><span class="line">write(fd, data, size);</span><br><span class="line"><span class="comment">// fork发生</span></span><br><span class="line"><span class="comment">// 子进程的线程2会从中间继续执行</span></span><br><span class="line"><span class="comment">// 导致文件数据重复或损坏</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>死锁风险</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mutex_lock(&amp;mutex);  <span class="comment">// 线程2持有锁</span></span><br><span class="line"><span class="comment">// fork发生</span></span><br><span class="line"><span class="comment">// 子进程中没有线程2，锁永远无法释放</span></span><br><span class="line"><span class="comment">// 导致死锁</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>实现复杂性</strong><ul><li>复制所有线程需要：<ul><li>重建线程间的同步关系</li><li>复制所有线程的上下文</li><li>处理线程池等复杂结构</li></ul></li></ul></li></ol><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ol><li><strong>fork 后立即 exec</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 子进程：立即执行新程序</span></span><br><span class="line">    execv(path, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>在主线程中 fork</strong><ul><li>避免在子线程中调用 fork</li><li>减少不确定性</li><li>更容易管理资源</li></ul></li></ol><p>这种设计既保证了安全性，又简化了实现，是一个合理的折中方案。</p><h2 id="编写至少两种使用-fork-的程序-使-fork-执行失败-并解释-fork-失败的原因"><a href="#编写至少两种使用-fork-的程序-使-fork-执行失败-并解释-fork-失败的原因" class="headerlink" title="编写至少两种使用 fork 的程序, 使 fork 执行失败, 并解释 fork 失败的原因"></a>编写至少两种使用 fork 的程序, 使 fork 执行失败, 并解释 fork 失败的原因</h2><p>让我展示两种让 fork 失败的程序：</p><h3 id="1-耗尽系统进程数限制"><a href="#1-耗尽系统进程数限制" class="headerlink" title="1. 耗尽系统进程数限制"></a>1. 耗尽系统进程数限制</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        pid_t pid = fork();</span><br><span class="line">        if (pid &lt; 0) &#123;</span><br><span class="line">            printf(&quot;Fork失败: %s\n&quot;, strerror(errno));</span><br><span class="line">            printf(&quot;成功创建进程数: %d\n&quot;, count);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">        if (pid == 0) &#123;</span><br><span class="line">            // 子进程睡眠不退出，占用进程表</span><br><span class="line">            sleep(100);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>失败原因：</strong></p><ul><li>系统有最大进程数限制（通过<code>ulimit -u</code>可查看）</li><li>当达到限制时，fork 会失败并返回 EAGAIN 错误</li></ul><h3 id="2-耗尽系统内存"><a href="#2-耗尽系统内存" class="headerlink" title="2. 耗尽系统内存"></a>2. 耗尽系统内存</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">#define ALLOC_SIZE (100*1024*1024) // 100MB</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 先占用大量内存</span><br><span class="line">    char* memory[1000];</span><br><span class="line">    int i = 0;</span><br><span class="line"></span><br><span class="line">    while(1) &#123;</span><br><span class="line">        memory[i] = malloc(ALLOC_SIZE);</span><br><span class="line">        if (memory[i] == NULL) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        // 写入内存确保实际分配</span><br><span class="line">        memset(memory[i], 1, ALLOC_SIZE);</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        pid_t pid = fork();</span><br><span class="line">        if (pid &lt; 0) &#123;</span><br><span class="line">            printf(&quot;Fork失败: %s\n&quot;, strerror(errno));</span><br><span class="line">            printf(&quot;已分配内存: %d MB\n&quot;, i * 100);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">        if (pid == 0) &#123;</span><br><span class="line">            sleep(100);  // 子进程保持运行</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>失败原因：</strong></p><ul><li>fork 需要复制父进程的地址空间</li><li>当系统内存不足时，无法为新进程分配内存</li><li>返回 ENOMEM 错误</li></ul><h3 id="其他可能导致-fork-失败的情况"><a href="#其他可能导致-fork-失败的情况" class="headerlink" title="其他可能导致 fork 失败的情况"></a>其他可能导致 fork 失败的情况</h3><ol><li><strong>资源限制</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置资源限制</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rlim</span>;</span></span><br><span class="line">rlim.rlim_cur = <span class="number">0</span>;</span><br><span class="line">rlim.rlim_max = <span class="number">0</span>;</span><br><span class="line">setrlimit(RLIMIT_NPROC, &amp;rlim);  <span class="comment">// 设置进程数限制为0</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>cgroup 限制</strong></li></ol><ul><li>在容器环境中设置严格的资源限制</li><li>限制进程数或内存使用</li></ul><p>使用这些程序时要注意：</p><ul><li>可能会影响系统稳定性</li><li>建议在测试环境运行</li><li>运行后需要及时清理资源</li></ul><h2 id="当子进程终止时，由于父进程可能正忙于自己的工作，没能及时调用-wait，因此子进程将变成僵尸进程。不过，由于操作系统记录了父进程与子进程之间的关系，在子进程退出时，它会发送-SIGCHLD-信号给父进程。请基于该机制实现程序，使得父进程能及时处理子进程的退出，尽可能避免子进程成为僵尸进程"><a href="#当子进程终止时，由于父进程可能正忙于自己的工作，没能及时调用-wait，因此子进程将变成僵尸进程。不过，由于操作系统记录了父进程与子进程之间的关系，在子进程退出时，它会发送-SIGCHLD-信号给父进程。请基于该机制实现程序，使得父进程能及时处理子进程的退出，尽可能避免子进程成为僵尸进程" class="headerlink" title="当子进程终止时，由于父进程可能正忙于自己的工作，没能及时调用 wait，因此子进程将变成僵尸进程。不过，由于操作系统记录了父进程与子进程之间的关系，在子进程退出时，它会发送 SIGCHLD 信号给父进程。请基于该机制实现程序，使得父进程能及时处理子进程的退出，尽可能避免子进程成为僵尸进程"></a>当子进程终止时，由于父进程可能正忙于自己的工作，没能及时调用 wait，因此子进程将变成僵尸进程。不过，由于操作系统记录了父进程与子进程之间的关系，在子进程退出时，它会发送 SIGCHLD 信号给父进程。请基于该机制实现程序，使得父进程能及时处理子进程的退出，尽可能避免子进程成为僵尸进程</h2><p>让我展示如何通过处理 SIGCHLD 信号来避免僵尸进程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line"></span><br><span class="line">// 信号处理函数</span><br><span class="line">void handle_sigchld(int sig) &#123;</span><br><span class="line">    int saved_errno = errno;  // 保存errno</span><br><span class="line">    pid_t pid;</span><br><span class="line"></span><br><span class="line">    // 循环调用waitpid，处理所有已终止的子进程</span><br><span class="line">    while ((pid = waitpid(-1, NULL, WNOHANG)) &gt; 0) &#123;</span><br><span class="line">        printf(&quot;子进程 %d 已被回收\n&quot;, pid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    errno = saved_errno;  // 恢复errno</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 设置SIGCHLD信号处理函数</span><br><span class="line">    struct sigaction sa;</span><br><span class="line">    sa.sa_handler = handle_sigchld;</span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sa.sa_flags = SA_RESTART | SA_NOCLDSTOP;  // 重启被中断的系统调用</span><br><span class="line"></span><br><span class="line">    if (sigaction(SIGCHLD, &amp;sa, NULL) == -1) &#123;</span><br><span class="line">        perror(&quot;sigaction&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 创建多个子进程</span><br><span class="line">    for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">        pid_t pid = fork();</span><br><span class="line"></span><br><span class="line">        if (pid &lt; 0) &#123;</span><br><span class="line">            perror(&quot;fork&quot;);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (pid == 0) &#123;  // 子进程</span><br><span class="line">            printf(&quot;子进程 %d 开始运行\n&quot;, getpid());</span><br><span class="line">            sleep(i + 1);  // 每个子进程睡眠不同时间</span><br><span class="line">            printf(&quot;子进程 %d 即将退出\n&quot;, getpid());</span><br><span class="line">            exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 父进程继续做其他工作</span><br><span class="line">    printf(&quot;父进程继续运行...\n&quot;);</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关键点解释"><a href="#关键点解释" class="headerlink" title="关键点解释"></a>关键点解释</h3><ol><li><strong>信号处理函数设计</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handle_sigchld</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// WNOHANG: 非阻塞等待</span></span><br><span class="line">        <span class="comment">// -1: 等待任何子进程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>信号处理器设置</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sa.sa_flags = SA_RESTART | SA_NOCLDSTOP;</span><br><span class="line"><span class="comment">// SA_RESTART: 重启被信号处理打断的系统调用</span></span><br><span class="line"><span class="comment">// SA_NOCLDSTOP: 只在子进程终止时发送信号，子进程暂停时不发送</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>保护 errno</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> saved_errno = errno;</span><br><span class="line"><span class="comment">// ... 信号处理 ...</span></span><br><span class="line">errno = saved_errno;</span><br></pre></td></tr></table></figure><h3 id="为什么这样设计-1"><a href="#为什么这样设计-1" class="headerlink" title="为什么这样设计"></a>为什么这样设计</h3><ol><li><p><strong>使用 while 循环处理 waitpid</strong></p><ul><li>多个子进程可能同时退出</li><li>一次信号可能对应多个子进程终止</li><li>确保处理所有已终止的子进程</li></ul></li><li><p><strong>使用 WNOHANG 标志</strong></p><ul><li>非阻塞调用</li><li>避免信号处理函数阻塞</li><li>提高程序响应性</li></ul></li><li><p><strong>保存和恢复 errno</strong></p><ul><li>信号处理可能改变 errno</li><li>避免干扰主程序的错误处理</li></ul></li></ol><h3 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h3><ol><li><strong>错误处理</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sigaction(SIGCHLD, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>在程序初始化时设置信号处理</strong><ul><li>尽早设置，避免遗漏子进程</li><li>确保所有 fork 之前都已设置好处理器</li></ul></li></ol><p>这种方式可以有效避免僵尸进程，同时不会影响父进程的正常工作。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;进程是操作系统对一个正在运行的程序的一种抽象。线程是进程中的一个执行单元。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="https://hmmmmmya.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>049-data-structure-and-algorithm-learning</title>
    <link href="https://hmmmmmya.github.io/2024/11/19/049-data-structure-and-algorithm-learning/"/>
    <id>https://hmmmmmya.github.io/2024/11/19/049-data-structure-and-algorithm-learning/</id>
    <published>2024-11-19T06:32:23.000Z</published>
    <updated>2024-11-29T01:58:37.669Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构与算法是计算机科学的基础，是解决实际问题的关键。</p><span id="more"></span><h3 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h3><ul><li>《大话数据结构》</li></ul><h3 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h3><ul><li><a href="https://www.hello-algo.com/">Hello 算法</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;数据结构与算法是计算机科学的基础，是解决实际问题的关键。&lt;/p&gt;</summary>
    
    
    
    <category term="learning" scheme="https://hmmmmmya.github.io/categories/learning/"/>
    
    
  </entry>
  
  <entry>
    <title>048-今天换页机制是否仍然有必要</title>
    <link href="https://hmmmmmya.github.io/2024/11/18/048-%E4%BB%8A%E5%A4%A9%E6%8D%A2%E9%A1%B5%E6%9C%BA%E5%88%B6%E6%98%AF%E5%90%A6%E4%BB%8D%E7%84%B6%E6%9C%89%E5%BF%85%E8%A6%81/"/>
    <id>https://hmmmmmya.github.io/2024/11/18/048-%E4%BB%8A%E5%A4%A9%E6%8D%A2%E9%A1%B5%E6%9C%BA%E5%88%B6%E6%98%AF%E5%90%A6%E4%BB%8D%E7%84%B6%E6%9C%89%E5%BF%85%E8%A6%81/</id>
    <published>2024-11-18T07:33:27.000Z</published>
    <updated>2024-11-18T08:24:29.263Z</updated>
    
    <content type="html"><![CDATA[<h2 id="在现代计算机内存容量和价格的变化下，是否还需要换页机制？"><a href="#在现代计算机内存容量和价格的变化下，是否还需要换页机制？" class="headerlink" title="在现代计算机内存容量和价格的变化下，是否还需要换页机制？"></a><strong>在现代计算机内存容量和价格的变化下，是否还需要换页机制？</strong></h2><span id="more"></span><p>回答：<br>换页机制依然非常重要，原因如下：</p><ol><li><p><strong>资源优化分配</strong><br>即使内存容量增大，但在多任务操作系统中，内存需求往往远大于物理内存。换页机制允许操作系统根据需要动态分配内存，保证资源分配更加灵活和高效。</p></li><li><p><strong>支持多进程运行</strong><br>换页机制通过虚拟内存的方式，为每个进程提供独立的地址空间，使得多个程序可以同时运行，而不必受物理内存大小的严格限制。</p></li><li><p><strong>减少程序约束</strong><br>换页机制使得开发者无需关注物理内存的实际大小，可以编写超出物理内存限制的大型程序，而不必担心内存不足的问题。</p></li><li><p><strong>成本与扩展性考虑</strong><br>虽然内存价格下降，但无限制地扩展物理内存并不现实。换页机制提供了一种高效的解决方案，可以用较小的物理内存结合磁盘空间，满足大规模应用的需求。</p></li><li><p><strong>提升系统稳定性</strong><br>在极端情况下（例如瞬时高内存需求），如果没有换页机制，系统可能会崩溃，而换页机制能通过磁盘作为后备存储，保障系统稳定运行。</p></li></ol><p>结论：<br>换页机制是现代操作系统的重要基础，即使物理内存容量增加且价格下降，其在资源管理和系统稳定性中的作用仍然不可或缺。</p><h2 id="假设物理内存足够大，虚拟内存是否有存在的必要？如果不使用虚拟内存抽象，恢复到只用物理内存寻址，会带来哪些改变？"><a href="#假设物理内存足够大，虚拟内存是否有存在的必要？如果不使用虚拟内存抽象，恢复到只用物理内存寻址，会带来哪些改变？" class="headerlink" title="假设物理内存足够大，虚拟内存是否有存在的必要？如果不使用虚拟内存抽象，恢复到只用物理内存寻址，会带来哪些改变？"></a>假设物理内存足够大，虚拟内存是否有存在的必要？如果不使用虚拟内存抽象，恢复到只用物理内存寻址，会带来哪些改变？</h2><p>即使物理内存足够大，虚拟内存仍然是必要的。让我解释一下原因：</p><h3 id="虚拟内存的重要作用"><a href="#虚拟内存的重要作用" class="headerlink" title="虚拟内存的重要作用"></a>虚拟内存的重要作用</h3><ol><li><p><strong>内存隔离与保护</strong></p><ul><li>每个进程都有自己的独立地址空间</li><li>防止进程间相互干扰</li><li>提供访问权限控制（读&#x2F;写&#x2F;执行）</li></ul></li><li><p><strong>地址空间统一</strong></p><ul><li>程序可以使用连续的地址空间</li><li>实际物理内存可以是不连续的</li><li>简化了程序的开发和加载</li></ul></li><li><p><strong>共享内存实现</strong></p><ul><li>多个进程可以映射同一块物理内存</li><li>便于进程间通信</li><li>节省内存（共享库）</li></ul></li></ol><h3 id="不使用虚拟内存的后果"><a href="#不使用虚拟内存的后果" class="headerlink" title="不使用虚拟内存的后果"></a>不使用虚拟内存的后果</h3><ol><li><strong>安全问题</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">进程A: 可以直接访问进程B的内存</span><br><span class="line">结果: 数据泄露、程序崩溃、系统不稳定</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>开发复杂性</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用虚拟内存</span></span><br><span class="line"><span class="type">char</span> *buffer = <span class="built_in">malloc</span>(<span class="number">1024</span>);  <span class="comment">// 简单分配连续空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不使用虚拟内存</span></span><br><span class="line"><span class="type">char</span> *buffer = find_physical_memory_gaps(<span class="number">1024</span>);  <span class="comment">// 需要处理物理内存碎片</span></span><br></pre></td></tr></table></figure><ol start="3"><li><p><strong>内存管理困难</strong></p><ul><li>内存碎片化严重</li><li>程序加载位置固定</li><li>动态库共享困难</li></ul></li><li><p><strong>多任务支持受限</strong></p><ul><li>进程切换复杂</li><li>内存布局冲突</li><li>难以实现进程隔离</li></ul></li></ol><p>因此，虚拟内存不仅仅是为了解决物理内存不足的问题，更是现代操作系统中实现安全性、隔离性和易用性的重要基础。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;在现代计算机内存容量和价格的变化下，是否还需要换页机制？&quot;&gt;&lt;a href=&quot;#在现代计算机内存容量和价格的变化下，是否还需要换页机制？&quot; class=&quot;headerlink&quot; title=&quot;在现代计算机内存容量和价格的变化下，是否还需要换页机制？&quot;&gt;&lt;/a&gt;&lt;strong&gt;在现代计算机内存容量和价格的变化下，是否还需要换页机制？&lt;/strong&gt;&lt;/h2&gt;</summary>
    
    
    
    <category term="操作系统" scheme="https://hmmmmmya.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
</feed>
