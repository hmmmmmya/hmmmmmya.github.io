<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hymns</title>
  
  
  <link href="https://hmmmmmya.github.io/atom.xml" rel="self"/>
  
  <link href="https://hmmmmmya.github.io/"/>
  <updated>2024-11-11T04:09:39.798Z</updated>
  <id>https://hmmmmmya.github.io/</id>
  
  <author>
    <name>Hymns</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>030_计算机网络应用层</title>
    <link href="https://hmmmmmya.github.io/2024/11/11/030-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <id>https://hmmmmmya.github.io/2024/11/11/030-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%B1%82/</id>
    <published>2024-11-11T04:06:25.000Z</published>
    <updated>2024-11-11T04:09:39.798Z</updated>
    
    <content type="html"><![CDATA[<p>应用层是 OSI 模型中的第七层，直接面向用户和应用程序。它主要负责提供网络服务的接口和实现数据交换。以下是应用层的主要功能：</p><span id="more"></span><h2 id="应用层的主要功能"><a href="#应用层的主要功能" class="headerlink" title="应用层的主要功能"></a>应用层的主要功能</h2><h3 id="1-提供网络服务接口"><a href="#1-提供网络服务接口" class="headerlink" title="1. 提供网络服务接口"></a>1. 提供网络服务接口</h3><p>应用层为各种应用程序提供网络服务接口，使得用户可以通过这些应用程序进行通信和数据交换。例如，Web 浏览器、电子邮件客户端和文件传输应用都通过应用层协议与网络进行交互。</p><h3 id="2-数据表示和转换"><a href="#2-数据表示和转换" class="headerlink" title="2. 数据表示和转换"></a>2. 数据表示和转换</h3><p>应用层负责数据的表示和转换，确保不同系统之间的数据可以正确理解和处理。这包括字符编码、数据格式转换和数据压缩等功能。例如，HTTP 协议在传输 HTML 文件时，需要将字符数据编码为网络传输格式。</p><h3 id="3-数据加密和安全性"><a href="#3-数据加密和安全性" class="headerlink" title="3. 数据加密和安全性"></a>3. 数据加密和安全性</h3><p>应用层提供数据加密和解密功能，确保数据在传输过程中的机密性和完整性。例如，HTTPS 协议通过 SSL&#x2F;TLS 加密数据，保护用户的敏感信息。</p><h3 id="4-资源共享和远程访问"><a href="#4-资源共享和远程访问" class="headerlink" title="4. 资源共享和远程访问"></a>4. 资源共享和远程访问</h3><p>应用层支持资源共享和远程访问功能，使得用户可以访问远程服务器的资源。例如，FTP 协议允许用户上传和下载远程服务器上的文件，Telnet 协议允许用户远程登录到另一台计算机。</p><h3 id="5-消息传递和电子邮件"><a href="#5-消息传递和电子邮件" class="headerlink" title="5. 消息传递和电子邮件"></a>5. 消息传递和电子邮件</h3><p>应用层支持消息传递和电子邮件服务，例如 SMTP、POP3 和 IMAP 协议，用于发送、接收和管理电子邮件。</p><h3 id="6-文件传输和访问"><a href="#6-文件传输和访问" class="headerlink" title="6. 文件传输和访问"></a>6. 文件传输和访问</h3><p>应用层提供文件传输和访问功能，使得用户可以在网络中传输和访问文件。常见的应用层协议包括 FTP 和 HTTP，用于文件上传、下载和网页访问。</p><h3 id="7-会话管理"><a href="#7-会话管理" class="headerlink" title="7. 会话管理"></a>7. 会话管理</h3><p>应用层管理通信会话的建立、维护和终止，确保通信的有效性和可靠性。例如，SIP 协议用于管理 VoIP（互联网语音）通信会话。</p><p>通过上述功能，应用层确保用户和应用程序能够方便地使用网络资源，实现高效的数据交换和通信。</p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><p>Socket 通信主要涉及传输层和应用层。具体来说：</p><ul><li><p>传输层：在传输层，Socket 与 TCP（传输控制协议）和 UDP（用户数据报协议）一起工作。TCP 提供可靠的、面向连接的通信，而 UDP 提供无连接的、不可靠的通信。Socket 用于建立和管理这些传输层连接。</p></li><li><p>应用层：应用层通过 Socket 接口与传输层进行交互，发送和接收数据。例如，HTTP、FTP、SMTP 等应用层协议都是通过 Socket 来进行数据传输的。</p></li></ul><p>Socket 可以看作是传输层与应用层之间的桥梁，使得应用程序能够方便地使用网络传输功能。</p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>DNS（域名系统）是应用层的协议。它的主要功能是将人类可读的域名（如 <code>www.example.com</code>）转换为计算机可读的 IP 地址（如 <code>192.0.2.1</code>）。这一转换过程被称为域名解析。</p><p>在 OSI 模型中，DNS 位于应用层，并通过 UDP 或 TCP 协议在传输层上传输数据。通常情况下，DNS 查询使用 UDP 端口 53 进行通信，但也可以在某些情况下使用 TCP 端口 53，例如当返回的数据包大小超过 UDP 协议的限制时。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;应用层是 OSI 模型中的第七层，直接面向用户和应用程序。它主要负责提供网络服务的接口和实现数据交换。以下是应用层的主要功能：&lt;/p&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="https://hmmmmmya.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://hmmmmmya.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>029_计算机网络网络层</title>
    <link href="https://hmmmmmya.github.io/2024/11/11/029_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <id>https://hmmmmmya.github.io/2024/11/11/029_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BD%91%E7%BB%9C%E5%B1%82/</id>
    <published>2024-11-11T03:53:23.000Z</published>
    <updated>2024-11-11T04:08:43.004Z</updated>
    
    <content type="html"><![CDATA[<p>网络层（Network Layer）在计算机网络中扮演着关键的角色，负责数据在网络中的传输路径选择和数据包的路由。以下是网络层的主要功能：</p><span id="more"></span><h2 id="网络层的主要功能"><a href="#网络层的主要功能" class="headerlink" title="网络层的主要功能"></a>网络层的主要功能</h2><h3 id="1-路由选择"><a href="#1-路由选择" class="headerlink" title="1. 路由选择"></a>1. 路由选择</h3><p>网络层负责确定数据包从源地址到目标地址的最佳路径。路由器（Routers）使用路由协议（如 OSPF、BGP）来动态更新和维护路由表，并根据网络拓扑的变化调整路径。</p><h3 id="2-数据包转发"><a href="#2-数据包转发" class="headerlink" title="2. 数据包转发"></a>2. 数据包转发</h3><p>网络层将数据包从一个网络节点转发到下一个节点，直到数据包到达目标地址。这个过程涉及查找路由表，并根据表中的信息确定数据包的下一跳地址。</p><h3 id="3-IP-地址编址"><a href="#3-IP-地址编址" class="headerlink" title="3. IP 地址编址"></a>3. IP 地址编址</h3><p>网络层使用 IP 地址来唯一标识网络中的每个设备。IP 地址分为 IPv4 和 IPv6 两种格式，网络层通过 IP 地址来确定数据包的源和目的地。</p><h3 id="4-分段与重组"><a href="#4-分段与重组" class="headerlink" title="4. 分段与重组"></a>4. 分段与重组</h3><p>网络层将较大的数据包分割成适合传输的较小片段（分段），并在到达目标后重新组装（重组）这些片段。这对于跨越不同网络的传输尤为重要，因为不同网络可能对数据包大小有不同的限制。</p><h3 id="5-差错处理与流量控制"><a href="#5-差错处理与流量控制" class="headerlink" title="5. 差错处理与流量控制"></a>5. 差错处理与流量控制</h3><p>虽然主要的差错检测和流量控制功能在传输层，但网络层也具备一定的错误检测机制。例如，IPv4 报头包含一个校验和字段，用于检查数据包头部的完整性。此外，ICMP 协议（如 Ping）用于报告网络层错误和提供诊断功能。</p><h3 id="6-拥塞控制"><a href="#6-拥塞控制" class="headerlink" title="6. 拥塞控制"></a>6. 拥塞控制</h3><p>网络层协议需要处理网络拥塞问题，确保数据包能够高效传输。例如，通过减少数据包的转发速率，或丢弃低优先级的数据包，来缓解网络拥塞。</p><h3 id="7-安全性"><a href="#7-安全性" class="headerlink" title="7. 安全性"></a>7. 安全性</h3><p>网络层的某些协议（如 IPSec）提供了数据加密和验证功能，确保数据在传输过程中不被窃取或篡改，提高数据传输的安全性。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>网络层的主要功能是管理数据包的传输和路由，确保数据能从源地址正确、安全地传递到目标地址。这些功能对于网络的正常运行和数据的有效传输至关重要。</p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="网络层协议"><a href="#网络层协议" class="headerlink" title="网络层协议"></a>网络层协议</h3><ul><li>IP 协议</li><li>ICMP 协议</li><li>ARP 协议</li><li>RARP 协议</li></ul><h3 id="网络模型各层的作用"><a href="#网络模型各层的作用" class="headerlink" title="网络模型各层的作用"></a>网络模型各层的作用</h3><p>应用层相当于用户，负责处理应用层的逻辑。</p><p>运输层相当于快递员，负责将数据从源地址传递到目标地址。</p><p>网络层相当于邮局，负责将数据从源地址传递到目标地址。</p><p>网络接口层相当于邮局分拣员，负责将数据分拣到不同的邮局。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;网络层（Network Layer）在计算机网络中扮演着关键的角色，负责数据在网络中的传输路径选择和数据包的路由。以下是网络层的主要功能：&lt;/p&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="https://hmmmmmya.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://hmmmmmya.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>028_计算机网络传输层</title>
    <link href="https://hmmmmmya.github.io/2024/11/11/028_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    <id>https://hmmmmmya.github.io/2024/11/11/028_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%B1%82/</id>
    <published>2024-11-11T03:30:45.000Z</published>
    <updated>2024-11-11T03:55:28.394Z</updated>
    
    <content type="html"><![CDATA[<p>在计算机网络中，传输层（Transport Layer）负责在网络端点之间传输数据。它是 OSI 模型中的第四层，提供了关键的功能，以确保数据在网络中能够有效、可靠地传输。以下是传输层的一些主要功能和作用：</p><span id="more"></span><h2 id="传输层的主要功能"><a href="#传输层的主要功能" class="headerlink" title="传输层的主要功能"></a>传输层的主要功能</h2><h3 id="1-数据分段和重组"><a href="#1-数据分段和重组" class="headerlink" title="1. 数据分段和重组"></a>1. <strong>数据分段和重组</strong></h3><p>传输层将应用层传递下来的数据分割成更小的段（segments），每个段包含必要的控制信息。接收方传输层会将这些段重组成原始的数据流。</p><h3 id="2-传输控制"><a href="#2-传输控制" class="headerlink" title="2. 传输控制"></a>2. <strong>传输控制</strong></h3><p>传输层确保数据可靠传输。常见协议如 TCP（传输控制协议）提供了数据包的确认（acknowledgment）、序号（sequence numbering）、超时重传（retransmission）、流控制（flow control）和拥塞控制（congestion control）等机制。</p><h3 id="3-端到端通信"><a href="#3-端到端通信" class="headerlink" title="3. 端到端通信"></a>3. <strong>端到端通信</strong></h3><p>传输层建立并管理端到端的通信连接。TCP 协议通过三次握手（three-way handshake）建立连接，确保通信双方准备就绪，而 UDP（用户数据报协议）则是不可靠的连接，通常用于实时应用如视频流和在线游戏。</p><h3 id="4-数据完整性"><a href="#4-数据完整性" class="headerlink" title="4. 数据完整性"></a>4. <strong>数据完整性</strong></h3><p>传输层通过校验和（checksum）等技术，确保数据在传输过程中没有被篡改或损坏。TCP 协议在接收数据时会计算并验证校验和，以检测传输中的错误。</p><h3 id="5-多路复用和解复用"><a href="#5-多路复用和解复用" class="headerlink" title="5. 多路复用和解复用"></a>5. <strong>多路复用和解复用</strong></h3><p>传输层允许多个应用程序同时使用网络连接，通过使用端口号（port numbers）来区分不同的应用流。多路复用（multiplexing）指的是将多个应用数据流合并到一个物理网络连接上，而解复用（demultiplexing）则是将收到的数据分配给正确的应用程序。</p><h3 id="6-流控制"><a href="#6-流控制" class="headerlink" title="6. 流控制"></a>6. <strong>流控制</strong></h3><p>传输层可以管理发送方和接收方的速率，避免网络拥塞和数据丢失。流控制机制确保发送方不会过快地发送数据，以至于接收方来不及处理。</p><h3 id="7-拥塞控制"><a href="#7-拥塞控制" class="headerlink" title="7. 拥塞控制"></a>7. <strong>拥塞控制</strong></h3><p>在 TCP 协议中，传输层负责监控网络的拥塞状态，并动态调整数据发送速率，以避免网络过载。常见的拥塞控制算法包括慢启动（slow start）、拥塞避免（congestion avoidance）等。</p><p>通过提供上述功能，传输层在确保数据可靠、有效传输方面发挥了关键作用。</p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><p>Socket 通信主要涉及传输层和应用层。具体来说：</p><ol><li><p><strong>传输层</strong>：在传输层，Socket 与 TCP（传输控制协议）和 UDP（用户数据报协议）一起工作。TCP 提供可靠的、面向连接的通信，而 UDP 提供无连接的、不可靠的通信。Socket 用于建立和管理这些传输层连接。</p></li><li><p><strong>应用层</strong>：应用层通过 Socket 接口与传输层进行交互，发送和接收数据。例如，HTTP、FTP、SMTP 等应用层协议都是通过 Socket 来进行数据传输的。</p></li></ol><p>Socket 可以看作是传输层与应用层之间的桥梁，使得应用程序能够方便地使用网络传输功能。</p><p>socket 是传输层提供给应用层的编程接口。</p><p>socket 是应用层与传输层之间的抽象，socket 不止是 TCP 才有，UDP 也有 socket。</p><p>socket 是基于文件描述符的，socket 是文件描述符的一种。</p><h3 id="传输层的信息要发送到哪里"><a href="#传输层的信息要发送到哪里" class="headerlink" title="传输层的信息要发送到哪里"></a>传输层的信息要发送到哪里</h3><p>传输层的信息会发送到传输层协议所指定的端口，这些端口是与应用层的特定服务或应用程序关联的。例如，当你在浏览器中访问一个网站时，HTTP 协议会在传输层使用 TCP 端口 80 或者 HTTPS 的 443 端口来发送和接收数据。</p><p>具体过程如下：</p><ol><li><p><strong>发送端</strong>：传输层将应用层的数据封装成数据段，并添加头部信息（例如源端口号和目标端口号）。然后，它将这些数据段传递给网络层。</p></li><li><p><strong>网络层</strong>：网络层会根据 IP 地址将数据包路由到目标计算机。</p></li><li><p><strong>接收端</strong>：在目标计算机上，网络层接收到数据包后，会将其传递给传输层。传输层根据数据包中的端口号，将数据转发给对应的应用程序。</p></li></ol><p>因此，传输层的信息最终会交给运行在指定端口上的应用程序或服务。</p><h3 id="使用传输层所需的信息"><a href="#使用传输层所需的信息" class="headerlink" title="使用传输层所需的信息"></a>使用传输层所需的信息</h3><p>要使用传输层进行通信，通常需要以下信息：</p><ol><li><strong>源端口号</strong>：发送方传输层使用的端口号，用于标识发送方的应用程序或服务。</li><li><strong>目标端口号</strong>：接收方传输层使用的端口号，用于标识接收方的应用程序或服务。例如，HTTP 使用端口 80，HTTPS 使用端口 443。</li><li><strong>源 IP 地址</strong>：发送方设备的 IP 地址，用于标识发送数据包的设备。</li><li><strong>目标 IP 地址</strong>：接收方设备的 IP 地址，用于标识接收数据包的设备。</li><li><strong>传输协议</strong>：例如 TCP 或 UDP，用于定义数据传输的方式。TCP 提供可靠的传输，而 UDP 则是无连接的、不保证可靠性的传输方式。</li><li><strong>序号和确认号</strong>（对于 TCP）：用于确保数据包按顺序到达并确认接收，防止数据丢失或重复。每个数据段都有一个序号，接收方确认收到的数据段时会返回一个确认号。</li><li><strong>控制信息</strong>：包括各种标志位（如 SYN、ACK、FIN 等），用于控制数据传输的状态和流程。例如，SYN 和 ACK 用于 TCP 连接的建立和确认。</li><li><strong>校验和</strong>：用于数据完整性校验，确保传输过程中数据未被篡改或损坏。</li><li><strong>窗口大小</strong>：流控制信息，指示接收方可接受的最大数据量，用于控制发送方的发送速率，防止网络拥塞。</li></ol><p>通过提供这些信息，传输层能够在发送方和接收方之间建立可靠的数据传输通道，确保数据能够正确、有效地到达目标。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在计算机网络中，传输层（Transport Layer）负责在网络端点之间传输数据。它是 OSI 模型中的第四层，提供了关键的功能，以确保数据在网络中能够有效、可靠地传输。以下是传输层的一些主要功能和作用：&lt;/p&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="https://hmmmmmya.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://hmmmmmya.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>027_GOF设计模式分类</title>
    <link href="https://hmmmmmya.github.io/2024/11/07/027_GOF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB/"/>
    <id>https://hmmmmmya.github.io/2024/11/07/027_GOF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB/</id>
    <published>2024-11-07T04:15:10.000Z</published>
    <updated>2024-11-07T04:23:15.514Z</updated>
    
    <content type="html"><![CDATA[<p>GOF 设计模式是经过总结、优化的代码设计经验，用于解决软件设计中的特定问题。设计模式通常分为三大类：<strong>创建型模式</strong>、<strong>结构型模式</strong>和<strong>行为型模式</strong>。以下是每个分类中的常见设计模式：</p><span id="more"></span><h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h3><p>这些模式处理对象的创建问题，并提供更灵活、可复用的创建机制。</p><ol><li><strong>单例模式（Singleton Pattern）</strong>: 确保一个类只有一个实例，并提供全局访问点。</li><li><strong>工厂方法模式（Factory Method Pattern）</strong>: 定义一个创建对象的接口，但由子类决定要实例化的类。</li><li><strong>抽象工厂模式（Abstract Factory Pattern）</strong>: 提供一个创建一系列相关或依赖对象的接口，而无需指定具体类。</li><li><strong>生成器模式（Builder Pattern）</strong>: 将对象的构建过程与表示分离，使得同样的构建过程可以创建不同的表示。</li><li><strong>原型模式（Prototype Pattern）</strong>: 通过复制现有对象来创建新对象，避免了对象的重复初始化。</li></ol><h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><p>这些模式关注类和对象的组合关系，解决系统的结构问题。</p><ol><li><strong>适配器模式（Adapter Pattern）</strong>: 使得原本由于接口不兼容而不能一起工作的类可以一起工作。</li><li><strong>桥接模式（Bridge Pattern）</strong>: 将抽象部分与它的实现部分分离，使它们都可以独立地变化。</li><li><strong>组合模式（Composite Pattern）</strong>: 将对象组合成树形结构以表示”部分-整体”的层次结构，使得客户端可以统一地处理单个对象和组合对象。</li><li><strong>装饰者模式（Decorator Pattern）</strong>: 动态地给对象增加额外的职责。</li><li><strong>外观模式（Facade Pattern）</strong>: 提供一个统一的接口，用来访问子系统中的一群接口。</li><li><strong>享元模式（Flyweight Pattern）</strong>: 运用共享技术来支持大量细粒度的对象。</li><li><strong>代理模式（Proxy Pattern）</strong>: 为其他对象提供一种代理，以控制对这个对象的访问。</li></ol><h3 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h3><p>这些模式关注对象之间的职责划分和相互协作。</p><ol><li><strong>策略模式（Strategy Pattern）</strong>: 定义一系列算法，将每一个算法封装起来，并且使它们可以互换。</li><li><strong>模板方法模式（Template Method Pattern）</strong>: 在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。</li><li><strong>观察者模式（Observer Pattern）</strong>: 定义对象之间的一种一对多的依赖关系。</li><li><strong>迭代器模式（Iterator Pattern）</strong>: 提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。</li><li><strong>职责链模式（Chain of Responsibility Pattern）</strong>: 为请求创建一个接收者对象的链。</li><li><strong>命令模式（Command Pattern）</strong>: 将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。</li><li><strong>备忘录模式（Memento Pattern）</strong>: 在不破坏封装性的前提下，捕获并外部化一个对象的内部状态。</li><li><strong>状态模式（State Pattern）</strong>: 允许对象在内部状态改变时改变它的行为。</li><li><strong>中介者模式（Mediator Pattern）</strong>: 用一个中介对象来封装一系列对象的交互。</li><li><strong>解释器模式（Interpreter Pattern）</strong>: 给定一种语言，定义它的文法表示，并定义一个解释器来处理这个文法。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;GOF 设计模式是经过总结、优化的代码设计经验，用于解决软件设计中的特定问题。设计模式通常分为三大类：&lt;strong&gt;创建型模式&lt;/strong&gt;、&lt;strong&gt;结构型模式&lt;/strong&gt;和&lt;strong&gt;行为型模式&lt;/strong&gt;。以下是每个分类中的常见设计模式：&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://hmmmmmya.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://hmmmmmya.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>026_gitignore</title>
    <link href="https://hmmmmmya.github.io/2024/11/04/026_gitignore/"/>
    <id>https://hmmmmmya.github.io/2024/11/04/026_gitignore/</id>
    <published>2024-11-04T10:05:52.000Z</published>
    <updated>2024-11-04T10:06:53.478Z</updated>
    
    <content type="html"><![CDATA[<p>Git 忽略文件的规则</p><span id="more"></span><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><code>.gitignore</code> 文件是用来告诉 Git 哪些文件或目录在版本控制中应该被忽略的。这对于排除编译生成的文件、临时文件、日志文件以及敏感数据等非常有用。下面是一些编写 <code>.gitignore</code> 文件的基本规则和示例：</p><ol><li><p><strong>文件名匹配规则</strong>：</p><ul><li><code>*</code>：匹配零个或多个字符。</li><li><code>?</code>：匹配任意一个字符。</li><li><code>[]</code>：匹配方括号内的任意一个字符。</li><li><code>!</code>：在模式前加上感叹号表示取反，即排除匹配的文件或目录。</li></ul></li><li><p><strong>注释</strong>：以 <code>#</code> 开头的行表示注释，Git 会忽略这些行。</p></li><li><p><strong>示例</strong>：</p><ul><li><p>忽略所有 <code>.a</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*.a</span><br></pre></td></tr></table></figure></li><li><p>但是跟踪 <code>lib.a</code>，即使在忽略 <code>.a</code> 文件的规则下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!lib.a</span><br></pre></td></tr></table></figure></li><li><p>忽略所有以 <code>.o</code> 结尾的文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*.o</span><br></pre></td></tr></table></figure></li><li><p>忽略所有以 <code>~</code> 结尾的临时文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*~</span><br></pre></td></tr></table></figure></li><li><p>忽略 <code>TODO</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TODO</span><br></pre></td></tr></table></figure></li><li><p>忽略 <code>build/</code> 目录下的所有文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build/</span><br></pre></td></tr></table></figure></li><li><p>忽略 <code>doc/notes.txt</code> 文件，但不包括 <code>doc/server/arch.txt</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doc/notes.txt</span><br></pre></td></tr></table></figure></li><li><p>忽略 <code>doc/</code> 目录下的 <code>.pdf</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doc/*.pdf</span><br></pre></td></tr></table></figure></li><li><p>忽略 <code>doc/</code> 目录下的所有 <code>.pdf</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="取消忽略后无效果"><a href="#取消忽略后无效果" class="headerlink" title="取消忽略后无效果"></a>取消忽略后无效果</h3><p>如果上述 <code>.gitignore</code> 规则没有达到预期效果，可以尝试更具体的忽略和取消忽略规则。在 <code>.gitignore</code> 文件中，顺序和具体路径可能会影响规则的应用。以下是调整后的版本，确保首先取消忽略特定的文件夹，然后忽略一般的文件夹：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 取消忽略以 hexo-theme- 开头的文件夹</span><br><span class="line">!node_modules/hexo-theme-*/</span><br><span class="line"></span><br><span class="line"># 忽略 node_modules 文件夹及其所有内容</span><br><span class="line">node_modules/</span><br><span class="line"></span><br><span class="line"># 忽略 node_modules 文件夹下的 hexo-theme-landscape 文件夹</span><br><span class="line">node_modules/hexo-theme-landscape/</span><br></pre></td></tr></table></figure><p>另外，请确保这些文件夹已经被 Git 跟踪（即它们之前没有被忽略）。如果这些文件夹之前已经被忽略，需要先将它们从缓存中移除，然后重新添加它们。可以按照以下步骤操作：</p><ol><li><p>从 Git 缓存中移除 <code>node_modules</code> 文件夹（但保留本地文件）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> -r --cached node_modules</span><br></pre></td></tr></table></figure></li><li><p>确认 <code>.gitignore</code> 文件中的规则。</p></li><li><p>重新添加 <code>node_modules</code> 文件夹：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add node_modules</span><br></pre></td></tr></table></figure></li><li><p>提交更改：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;Update .gitignore rules&quot;</span></span><br></pre></td></tr></table></figure></li></ol><p>通过这些步骤，Git 将正确应用 <code>.gitignore</code> 文件中的规则。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Git 忽略文件的规则&lt;/p&gt;</summary>
    
    
    
    <category term="git" scheme="https://hmmmmmya.github.io/categories/git/"/>
    
    
    <category term="git" scheme="https://hmmmmmya.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>025_PR和MR的区别</title>
    <link href="https://hmmmmmya.github.io/2024/11/04/025_PR%E5%92%8CMR%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://hmmmmmya.github.io/2024/11/04/025_PR%E5%92%8CMR%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2024-11-04T09:59:06.000Z</published>
    <updated>2024-11-04T10:00:45.416Z</updated>
    
    <content type="html"><![CDATA[<p>PR（Pull Request）和 MR（Merge Request）是代码版本控制系统中的两个概念，它们主要用于在多人协作开发项目时合并代码变更。这两个术语在功能上非常相似，但在不同的代码托管平台上有不同的称呼。</p><span id="more"></span><h2 id="PR（Pull-Request）"><a href="#PR（Pull-Request）" class="headerlink" title="PR（Pull Request）"></a>PR（Pull Request）</h2><ul><li><strong>定义</strong>: Pull Request 是 GitHub、Bitbucket、GitLab 等平台上用于代码合并的一种请求机制。当开发者在自己的分支上完成了一组代码更改后，他们可以创建一个 Pull Request 请求，将这些更改合并到主分支（例如 <code>main</code> 或 <code>master</code>）或者其他目标分支。</li><li><strong>使用场景</strong>:<ul><li>开发者完成功能或修复后，创建 PR 并向代码库的维护者或团队成员发出请求，要求对这些更改进行审查。</li><li>审查通过后，维护者可以批准并合并 PR，将这些更改合并到目标分支中。</li></ul></li><li><strong>平台</strong>: PR 这个术语主要用于 GitHub 和 Bitbucket 等平台。</li></ul><h2 id="MR（Merge-Request）"><a href="#MR（Merge-Request）" class="headerlink" title="MR（Merge Request）"></a>MR（Merge Request）</h2><ul><li><p><strong>定义</strong>: Merge Request 是 GitLab 上使用的术语，功能上与 Pull Request 类似。MR 用于向项目中的其他开发者或团队发出合并代码更改的请求。</p></li><li><p><strong>使用场景</strong>:</p><ul><li>在开发者完成某个功能或修复后，他们提交 MR 请求，将代码合并到主分支或其他目标分支。</li><li>代码库的维护者或团队成员审查 MR，并决定是否合并这些更改。</li></ul></li><li><p><strong>平台</strong>: MR 主要在 GitLab 上使用。</p></li></ul><h2 id="PR-和-MR-的区别"><a href="#PR-和-MR-的区别" class="headerlink" title="PR 和 MR 的区别"></a>PR 和 MR 的区别</h2><ul><li><strong>平台不同</strong>: PR 主要用于 GitHub 和 Bitbucket，MR 主要用于 GitLab。</li><li><strong>功能相同</strong>: 尽管名称不同，PR 和 MR 的核心功能都是相同的，即允许开发者在合并代码之前发起请求进行代码审查。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>无论是 PR 还是 MR，它们的主要目的是通过让代码库的维护者或团队成员审查代码，确保在代码合并到主分支之前能够发现并解决潜在的问题。这种机制有助于提高代码质量，减少引入的错误，同时也便于多人协作开发。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;PR（Pull Request）和 MR（Merge Request）是代码版本控制系统中的两个概念，它们主要用于在多人协作开发项目时合并代码变更。这两个术语在功能上非常相似，但在不同的代码托管平台上有不同的称呼。&lt;/p&gt;</summary>
    
    
    
    <category term="git" scheme="https://hmmmmmya.github.io/categories/git/"/>
    
    
    <category term="git" scheme="https://hmmmmmya.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>024_cpp初始化</title>
    <link href="https://hmmmmmya.github.io/2024/10/31/024_cpp%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>https://hmmmmmya.github.io/2024/10/31/024_cpp%E5%88%9D%E5%A7%8B%E5%8C%96/</id>
    <published>2024-10-31T09:43:25.000Z</published>
    <updated>2024-10-31T09:59:00.923Z</updated>
    
    <content type="html"><![CDATA[<p>介绍下 c++ 的初始化</p><span id="more"></span><h2 id="一-自动初始化为-0-的情况"><a href="#一-自动初始化为-0-的情况" class="headerlink" title="一. 自动初始化为 0 的情况"></a>一. 自动初始化为 0 的情况</h2><p>在 C++中，初始化为 0 的情况取决于变量的类型、存储位置和初始化方式。以下是 C++中会自动初始化为 0 的几种情况：</p><h3 id="1-全局变量和静态变量"><a href="#1-全局变量和静态变量" class="headerlink" title="1. 全局变量和静态变量"></a>1. <strong>全局变量和静态变量</strong></h3><ul><li><p><strong>全局变量</strong>（包括命名空间作用域的变量）和<strong>静态变量</strong>（<code>static</code>）在定义时会被自动初始化为 0。</p></li><li><p>这种自动初始化包括整型初始化为 0，浮点型初始化为 0.0，指针初始化为<code>nullptr</code>，类对象会调用默认构造函数。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> globalVar;          <span class="comment">// 自动初始化为0</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> staticVar;    <span class="comment">// 静态变量自动初始化为0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> funcStaticVar;  <span class="comment">// 函数内部的静态变量自动初始化为0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-类中的非静态成员变量（使用值初始化）"><a href="#2-类中的非静态成员变量（使用值初始化）" class="headerlink" title="2. 类中的非静态成员变量（使用值初始化）"></a>2. <strong>类中的非静态成员变量（使用值初始化）</strong></h3><ul><li><p>如果对象的非静态成员变量没有显式初始化，在值初始化时这些成员变量会被自动初始化为 0。</p></li><li><p>值初始化通常发生在使用花括号初始化或默认初始化的情况下。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">double</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj&#123;&#125;;  <span class="comment">// obj.a 和 obj.b 都会被初始化为0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-数组的值初始化"><a href="#3-数组的值初始化" class="headerlink" title="3. 数组的值初始化"></a>3. <strong>数组的值初始化</strong></h3><ul><li><p>如果数组通过值初始化进行初始化，数组中的元素会被初始化为 0。</p></li><li><p>通常使用花括号初始化或空花括号初始化的方式触发此行为。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr1[<span class="number">5</span>] = &#123;&#125;;   <span class="comment">// 所有元素初始化为0</span></span><br><span class="line"><span class="type">int</span> arr2[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">// 所有元素初始化为0</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="4-动态分配的内存初始化"><a href="#4-动态分配的内存初始化" class="headerlink" title="4. 动态分配的内存初始化"></a>4. <strong>动态分配的内存初始化</strong></h3><ul><li><p>使用<code>new</code>时，如果使用了带括号的方式，会将分配的内存初始化为 0。</p></li><li><p>不加括号的<code>new</code>不会自动初始化（需要手动赋值）。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p1 = <span class="keyword">new</span> <span class="built_in">int</span>();       <span class="comment">// *p1 被初始化为0</span></span><br><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>]();   <span class="comment">// arr数组的每个元素都初始化为0</span></span><br><span class="line"><span class="keyword">delete</span> p1;</span><br><span class="line"><span class="keyword">delete</span>[] arr;</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-内置类型的局部变量不会自动初始化"><a href="#5-内置类型的局部变量不会自动初始化" class="headerlink" title="5. 内置类型的局部变量不会自动初始化"></a>5. <strong>内置类型的局部变量不会自动初始化</strong></h3><ul><li><p>如果是局部变量且不属于静态存储期的内置类型变量（如局部整型、浮点型或指针），则它们不会自动初始化为 0，值是未定义的，需手动初始化。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> localVar;    <span class="comment">// 未初始化，值未定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>C++中会自动初始化为 0 的主要情形包括全局&#x2F;静态变量、类中的非静态成员变量（在值初始化时）、使用值初始化的数组和使用括号初始化的动态内存。</p><h3 id="1-vector-初始化"><a href="#1-vector-初始化" class="headerlink" title="1. vector 初始化"></a>1. vector 初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>是的,使用这种方式定义 vector 时,编译器会自动将所有元素初始化为 0。</p><p>具体来说:</p><ol><li>对于内置类型(如 int, double 等),会被初始化为 0</li><li>对于类类型,会调用默认构造函数</li></ol><p>举例说明:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下定义方式都会将元素初始化为0</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">5</span>)</span></span>;           <span class="comment">// &#123;0,0,0,0,0&#125;</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">double</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">3</span>)</span></span>;        <span class="comment">// &#123;0.0,0.0,0.0&#125;</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">2</span>)</span></span>;          <span class="comment">// &#123;false,false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类类型会调用默认构造函数</span></span><br><span class="line"><span class="function">std::vector&lt;std::string&gt; <span class="title">v4</span><span class="params">(<span class="number">2</span>)</span></span>;   <span class="comment">// &#123;&quot;&quot;,&quot;&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>所以 vector 中的所有 int 元素已经被初始化为 0 了。</p><h2 id="二-存放内置类型的容器初始化"><a href="#二-存放内置类型的容器初始化" class="headerlink" title="二. 存放内置类型的容器初始化"></a>二. 存放内置类型的容器初始化</h2><p>在 C++中，存放内置类型的容器（如<code>std::vector&lt;int&gt;</code>）中的值是否会被初始化，取决于容器的构造和初始化方式。默认情况下，内置类型的元素不会自动初始化为 0，需要显式设置或采用某些特定的构造方式。以下是不同情况下的初始化行为：</p><h3 id="1-默认构造的容器"><a href="#1-默认构造的容器" class="headerlink" title="1. 默认构造的容器"></a>1. <strong>默认构造的容器</strong></h3><ul><li><p>如果使用默认构造的容器（即没有指定大小或初始值），则容器的内容为空。</p></li><li><p>例如，<code>std::vector&lt;int&gt; v;</code>会创建一个空的<code>vector</code>，没有任何元素，因此不存在初始化的问题。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;  <span class="comment">// 空容器，没有元素，因此没有初始化</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-指定大小的构造方式"><a href="#2-指定大小的构造方式" class="headerlink" title="2. 指定大小的构造方式"></a>2. <strong>指定大小的构造方式</strong></h3><ul><li><p>如果通过指定大小来构造容器，例如<code>std::vector&lt;int&gt; v(5);</code>，容器会分配出对应数量的元素。</p></li><li><p>对于内置类型的元素，使用此方式初始化时，值是未定义的，不会自动初始化为 0。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">5</span>)</span></span>;  <span class="comment">// 分配5个int元素，值未定义</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-指定大小和初始值的构造方式"><a href="#3-指定大小和初始值的构造方式" class="headerlink" title="3. 指定大小和初始值的构造方式"></a>3. <strong>指定大小和初始值的构造方式</strong></h3><ul><li><p>使用<code>std::vector&lt;int&gt; v(5, 0);</code>指定大小并提供初始值时，所有元素都会被初始化为指定的值（此处为 0）。</p></li><li><p>这种方式适用于确保容器中所有元素的初始值。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">5</span>, <span class="number">0</span>)</span></span>;  <span class="comment">// 分配5个元素，全部初始化为0</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="4-使用std-array"><a href="#4-使用std-array" class="headerlink" title="4. 使用std::array"></a>4. <strong>使用<code>std::array</code></strong></h3><ul><li><p><code>std::array</code>的大小是固定的，初始化时如果没有提供所有元素的初始值，未指定的元素会被自动初始化为 0。</p></li><li><p>例如，<code>std::array&lt;int, 5&gt; arr = &#123;1&#125;;</code>会将第一个元素初始化为 1，其他元素初始化为 0。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::array&lt;<span class="type">int</span>, 5&gt; arr = &#123;<span class="number">1</span>&#125;;  <span class="comment">// arr = &#123;1, 0, 0, 0, 0&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="5-使用std-vector的resize方法"><a href="#5-使用std-vector的resize方法" class="headerlink" title="5. 使用std::vector的resize方法"></a>5. <strong>使用<code>std::vector</code>的<code>resize</code>方法</strong></h3><ul><li><p>使用<code>resize</code>调整大小时，如果提供初始值参数（如<code>v.resize(5, 0);</code>），所有新元素会被初始化为指定值（这里是 0）。</p></li><li><p>如果不提供初始值，则新元素的值未定义。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">resize</span>(<span class="number">5</span>, <span class="number">0</span>);  <span class="comment">// 将容器扩展为5个元素，全部初始化为0</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li>**默认构造或仅指定大小的<code>vector</code>**：元素不会被初始化，值未定义。</li><li>**指定大小和初始值的<code>vector</code>**：元素会被初始化为指定值。</li><li><strong><code>std::array</code>初始化不完全填充</strong>：剩余元素会被初始化为 0。</li><li><strong><code>resize</code>时提供初始值</strong>：新元素会被初始化为该值。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍下 c++ 的初始化&lt;/p&gt;</summary>
    
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/categories/c/"/>
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>023_c++折叠表达式</title>
    <link href="https://hmmmmmya.github.io/2024/10/31/023_cpp%E6%8A%98%E5%8F%A0%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://hmmmmmya.github.io/2024/10/31/023_cpp%E6%8A%98%E5%8F%A0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2024-10-31T08:50:14.000Z</published>
    <updated>2024-10-31T08:52:50.425Z</updated>
    
    <content type="html"><![CDATA[<p>C++中的折叠表达式（Fold Expressions）是一种简化变参模板函数编写的语法，从 C++17 开始引入。折叠表达式可以对可变参数模板进行自动折叠，从而简化代码。</p><span id="more"></span><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>折叠表达式可以将可变参数模板中的所有参数，通过特定的运算符折叠为一个结果。常见的运算符包括加法<code>+</code>、乘法<code>*</code>、逻辑与<code>&amp;&amp;</code>、逻辑或<code>||</code>等。折叠表达式主要有四种形式：</p><ol><li><strong>一元左折叠</strong>：从左到右依次折叠，例如：<code>(args + ...)</code></li><li><strong>一元右折叠</strong>：从右到左依次折叠，例如：<code>(... + args)</code></li><li><strong>二元左折叠</strong>：用于指定初始值，从左到右依次折叠，例如：<code>(init + ... + args)</code></li><li><strong>二元右折叠</strong>：用于指定初始值，从右到左依次折叠，例如：<code>(args + ... + init)</code></li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>以下是每种折叠表达式的代码示例：</p><h4 id="1-一元左折叠"><a href="#1-一元左折叠" class="headerlink" title="1. 一元左折叠"></a>1. 一元左折叠</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args + ...);  <span class="comment">// 将参数依次相加</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);  <span class="comment">// 返回 1 + 2 + 3 + 4 = 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-一元右折叠"><a href="#2-一元右折叠" class="headerlink" title="2. 一元右折叠"></a>2. 一元右折叠</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (... + args);  <span class="comment">// 从右到左依次相加</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-二元左折叠"><a href="#3-二元左折叠" class="headerlink" title="3. 二元左折叠"></a>3. 二元左折叠</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span> + ... + args);  <span class="comment">// 从0开始，依次相加</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);  <span class="comment">// 返回 0 + 1 + 2 + 3 + 4 = 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-二元右折叠"><a href="#4-二元右折叠" class="headerlink" title="4. 二元右折叠"></a>4. 二元右折叠</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args + ... + <span class="number">0</span>);  <span class="comment">// 从右到左依次相加，最终加0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常见应用场景"><a href="#常见应用场景" class="headerlink" title="常见应用场景"></a>常见应用场景</h3><p>折叠表达式在编写模板时非常有用，常见的应用场景包括：</p><ol><li><strong>累加求和</strong>：将参数列表中的所有值求和。</li><li><strong>逻辑判断</strong>：可以通过折叠表达式实现<code>&amp;&amp;</code>和<code>||</code>运算来检查所有参数是否满足某个条件。</li><li><strong>打印参数</strong>：配合<code>std::cout</code>可以实现简单的参数打印。</li></ol><h4 id="逻辑判断的示例"><a href="#逻辑判断的示例" class="headerlink" title="逻辑判断的示例"></a>逻辑判断的示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">allTrue</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args &amp;&amp; ...);  <span class="comment">// 如果所有参数都为true，则返回true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">anyTrue</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args || ...);  <span class="comment">// 如果任意一个参数为true，则返回true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>折叠表达式大大减少了变参模板代码的复杂性，是编写简洁、高效代码的重要工具。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++中的折叠表达式（Fold Expressions）是一种简化变参模板函数编写的语法，从 C++17 开始引入。折叠表达式可以对可变参数模板进行自动折叠，从而简化代码。&lt;/p&gt;</summary>
    
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/categories/c/"/>
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/tags/c/"/>
    
    <category term="c++17" scheme="https://hmmmmmya.github.io/tags/c-17/"/>
    
    <category term="现代c++" scheme="https://hmmmmmya.github.io/tags/%E7%8E%B0%E4%BB%A3c/"/>
    
  </entry>
  
  <entry>
    <title>022_c++结构化绑定</title>
    <link href="https://hmmmmmya.github.io/2024/10/31/022_cpp%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A/"/>
    <id>https://hmmmmmya.github.io/2024/10/31/022_cpp%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A/</id>
    <published>2024-10-31T06:58:46.000Z</published>
    <updated>2024-10-31T07:10:11.427Z</updated>
    
    <content type="html"><![CDATA[<p>介绍下 c++ 的结构化绑定</p><span id="more"></span><p>结构化绑定(Structured Binding)是 C++17 引入的新特性,允许我们将结构体、数组或元组中的多个元素同时绑定到多个变量上。</p><p>以下是几个常见的使用场景:</p><ol><li>绑定 tuple:</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::tuple&lt;<span class="type">int</span>, std::string, <span class="type">double</span>&gt; tuple&#123;<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>, <span class="number">3.14</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> [id, name, value] = tuple;  <span class="comment">// 自动解包到三个变量</span></span><br></pre></td></tr></table></figure><ol start="2"><li>绑定 pair:</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt; map&#123;&#123;<span class="string">&quot;one&quot;</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [key, value] : map) &#123;  <span class="comment">// 遍历map时直接获取键值</span></span><br><span class="line">    std::cout &lt;&lt; key &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>绑定结构体:</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line">Point p&#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> [x, y] = p;  <span class="comment">// 直接获取结构体的成员</span></span><br></pre></td></tr></table></figure><ol start="4"><li>绑定数组:</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> array[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> [a, b, c] = array;  <span class="comment">// 解包固定大小的数组</span></span><br></pre></td></tr></table></figure><ol start="5"><li>在函数返回多个值时使用:</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::tuple&lt;<span class="type">bool</span>, std::string&gt; <span class="title">ValidateUser</span><span class="params">(<span class="type">const</span> std::string&amp; user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="literal">true</span>, <span class="string">&quot;验证成功&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用时</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> [success, message] = <span class="built_in">ValidateUser</span>(<span class="string">&quot;admin&quot;</span>); success) &#123;</span><br><span class="line">    std::cout &lt;&lt; message &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在之前的代码中的应用:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原来的写法</span></span><br><span class="line">std::vector&lt;std::tuple&lt;T, T, T&gt;&gt; &amp;params;</span><br><span class="line">T min = std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(params.<span class="built_in">at</span>(i));</span><br><span class="line">T max = std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(params.<span class="built_in">at</span>(i));</span><br><span class="line">std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(params.<span class="built_in">at</span>(i)) = value;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用结构化绑定的写法</span></span><br><span class="line"><span class="keyword">auto</span>&amp; [value, min, max] = params[i];  <span class="comment">// 一次性获取所有值</span></span><br></pre></td></tr></table></figure><p>优点:</p><ol><li>代码更简洁易读</li><li>避免重复访问容器元素</li><li>减少了使用 std::get 的繁琐语法</li><li>变量名更有意义,提高代码可维护性</li></ol><p>注意事项:</p><ol><li>需要 C++17 或更高版本</li><li>绑定的变量数量必须与结构中的元素数量完全匹配</li><li>使用 auto 关键字声明</li><li>可以使用引用(&amp;)来避免拷贝</li></ol><p>结构化绑定是现代 C++中非常实用的特性,能让代码更加简洁优雅。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍下 c++ 的结构化绑定&lt;/p&gt;</summary>
    
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/categories/c/"/>
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/tags/c/"/>
    
    <category term="c++17" scheme="https://hmmmmmya.github.io/tags/c-17/"/>
    
    <category term="现代c++" scheme="https://hmmmmmya.github.io/tags/%E7%8E%B0%E4%BB%A3c/"/>
    
  </entry>
  
  <entry>
    <title>021_主题皮肤推荐</title>
    <link href="https://hmmmmmya.github.io/2024/10/30/021_%E4%B8%BB%E9%A2%98%E7%9A%AE%E8%82%A4%E6%8E%A8%E8%8D%90/"/>
    <id>https://hmmmmmya.github.io/2024/10/30/021_%E4%B8%BB%E9%A2%98%E7%9A%AE%E8%82%A4%E6%8E%A8%E8%8D%90/</id>
    <published>2024-10-30T03:44:23.000Z</published>
    <updated>2024-11-01T04:19:15.386Z</updated>
    
    <content type="html"><![CDATA[<p>好用的主题皮肤推荐</p><span id="more"></span><table><thead><tr><th>工具</th><th>主题皮肤</th><th>备注</th></tr></thead><tbody><tr><td><strong>vscode</strong></td><td><em>Night Owl</em></td><td>fav</td></tr><tr><td></td><td>One Dark Pro</td><td>foggy</td></tr><tr><td><strong>typora</strong></td><td><em>Vue</em></td><td>fav</td></tr><tr><td></td><td>Github</td><td></td></tr><tr><td></td><td>Juejin</td><td></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;好用的主题皮肤推荐&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>020_如何修改 Linux 栈区大小</title>
    <link href="https://hmmmmmya.github.io/2024/10/29/020_%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%20Linux%20%E6%A0%88%E5%8C%BA%E5%A4%A7%E5%B0%8F/"/>
    <id>https://hmmmmmya.github.io/2024/10/29/020_%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%20Linux%20%E6%A0%88%E5%8C%BA%E5%A4%A7%E5%B0%8F/</id>
    <published>2024-10-29T08:42:00.000Z</published>
    <updated>2024-10-29T08:42:33.731Z</updated>
    
    <content type="html"><![CDATA[<p>栈，就是那些由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区。里面的变量通常是局部变量、函数参数等。和堆相比，栈通常很小。<br>在 Linux 系统中，栈区的大小是固定的，通常为 8 MB。然而，在某些情况下，我们可能需要修改栈区的大小。本文将介绍如何修改 Linux 栈区大小。</p><span id="more"></span><h2 id="1-查看当前栈区大小"><a href="#1-查看当前栈区大小" class="headerlink" title="1. 查看当前栈区大小"></a>1. 查看当前栈区大小</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -s // 一般为8192KB, 即8MB</span><br></pre></td></tr></table></figure><p>注：线程栈大小默认为 8M，8192 KB。</p><h2 id="2-修改栈区大小"><a href="#2-修改栈区大小" class="headerlink" title="2. 修改栈区大小"></a>2. 修改栈区大小</h2><h3 id="临时修改"><a href="#临时修改" class="headerlink" title="临时修改"></a>临时修改</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -s 102400 // 改为100MB</span><br></pre></td></tr></table></figure><p>注：ulimit -s ulimited 不限制。</p><h3 id="永久修改"><a href="#永久修改" class="headerlink" title="永久修改"></a>永久修改</h3><p>有两种方法：</p><ul><li><p>方法一：可以在&#x2F;etc&#x2F;rc.local 内加入 ulimit -s 102400 则可以开机就设置栈空间大小，任何用户启动的时候都会调用</p></li><li><p>方法二：修改配置文件&#x2F;etc&#x2F;security&#x2F;limits.conf</p></li></ul><p>手动添加：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* soft stack 102400</span><br></pre></td></tr></table></figure><p>自动添加：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -ne <span class="string">&quot;* soft stack 102400\n&quot;</span> &gt;&gt; /etc/security/limits.conf</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;栈，就是那些由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区。里面的变量通常是局部变量、函数参数等。和堆相比，栈通常很小。&lt;br&gt;在 Linux 系统中，栈区的大小是固定的，通常为 8 MB。然而，在某些情况下，我们可能需要修改栈区的大小。本文将介绍如何修改 Linux 栈区大小。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://hmmmmmya.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://hmmmmmya.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>019_Linux 查看库中是否包含指定函数</title>
    <link href="https://hmmmmmya.github.io/2024/10/29/019_Linux%20%E6%9F%A5%E7%9C%8B%E5%BA%93%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E6%8C%87%E5%AE%9A%E5%87%BD%E6%95%B0/"/>
    <id>https://hmmmmmya.github.io/2024/10/29/019_Linux%20%E6%9F%A5%E7%9C%8B%E5%BA%93%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E6%8C%87%E5%AE%9A%E5%87%BD%E6%95%B0/</id>
    <published>2024-10-29T08:10:00.000Z</published>
    <updated>2024-10-29T08:40:27.196Z</updated>
    
    <content type="html"><![CDATA[<p>在 Linux 系统中，我们经常需要确认某个函数是否在特定的库文件中。以下是几种常用的查找方法。</p><span id="more"></span><h2 id="1-nm-命令（最常用）"><a href="#1-nm-命令（最常用）" class="headerlink" title="1. nm 命令（最常用）"></a>1. nm 命令（最常用）</h2><p><code>nm</code> 命令用于查看库文件中的符号表，是最直接的方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本语法</span></span><br><span class="line">nm -D /path/to/library.so | grep <span class="string">&#x27;function_name&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际示例</span></span><br><span class="line">nm -D /usr/lib/libc.so.6 | grep <span class="string">&#x27;printf&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="2-objdump-命令（详细信息）"><a href="#2-objdump-命令（详细信息）" class="headerlink" title="2. objdump 命令（详细信息）"></a>2. objdump 命令（详细信息）</h2><p><code>objdump</code> 提供了更详细的库文件信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本语法</span></span><br><span class="line">objdump -T /path/to/library.so | grep <span class="string">&#x27;function_name&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际示例</span></span><br><span class="line">objdump -T /usr/lib/libc.so.6 | grep <span class="string">&#x27;printf&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="3-readelf-命令（ELF-文件专用）"><a href="#3-readelf-命令（ELF-文件专用）" class="headerlink" title="3. readelf 命令（ELF 文件专用）"></a>3. readelf 命令（ELF 文件专用）</h2><p>专门用于分析 ELF 格式文件的工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本语法</span></span><br><span class="line">readelf -Ws /path/to/library.so | grep <span class="string">&#x27;function_name&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际示例</span></span><br><span class="line">readelf -Ws /usr/lib/libc.so.6 | grep <span class="string">&#x27;printf&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="4-批量查找方法"><a href="#4-批量查找方法" class="headerlink" title="4. 批量查找方法"></a>4. 批量查找方法</h2><h3 id="使用-find-配合-nm-命令"><a href="#使用-find-配合-nm-命令" class="headerlink" title="使用 find 配合 nm 命令"></a>使用 find 配合 nm 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在指定目录下查找所有.so文件中的特定函数</span></span><br><span class="line">find /usr/lib -name <span class="string">&quot;*.so&quot;</span> -<span class="built_in">exec</span> nm -D &#123;&#125; \; | grep <span class="string">&#x27;function_name&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="使用-grep-直接搜索"><a href="#使用-grep-直接搜索" class="headerlink" title="使用 grep 直接搜索"></a>使用 grep 直接搜索</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在库目录中搜索函数名</span></span><br><span class="line">grep -R <span class="string">&#x27;function_name&#x27;</span> /usr/lib/</span><br></pre></td></tr></table></figure><h2 id="5-依赖关系查看（ldd）"><a href="#5-依赖关系查看（ldd）" class="headerlink" title="5. 依赖关系查看（ldd）"></a>5. 依赖关系查看（ldd）</h2><p>虽然不能直接查看函数，但可以查看库的依赖关系。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看可执行文件的库依赖</span></span><br><span class="line">ldd /path/to/executable</span><br></pre></td></tr></table></figure><h2 id="常见参数说明"><a href="#常见参数说明" class="headerlink" title="常见参数说明"></a>常见参数说明</h2><table><thead><tr><th>命令</th><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>nm</td><td>-D</td><td>只显示动态符号</td></tr><tr><td>objdump</td><td>-T</td><td>显示动态符号表</td></tr><tr><td>readelf</td><td>-W</td><td>使用宽格式显示</td></tr><tr><td></td><td>-s</td><td>显示符号表</td></tr></tbody></table><h2 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h2><ol><li><strong>快速查找</strong>：优先使用 <code>nm -D</code> 命令</li><li><strong>详细分析</strong>：需要更多信息时使用 <code>objdump</code> 或 <code>readelf</code></li><li><strong>批量查找</strong>：使用 <code>find</code> 配合 <code>nm</code> 命令</li><li><strong>依赖确认</strong>：使用 <code>ldd</code> 确认库是否正确链接</li></ol><h2 id="常见问题排查"><a href="#常见问题排查" class="headerlink" title="常见问题排查"></a>常见问题排查</h2><p>如果找到函数但链接失败，请检查：</p><ul><li>库文件的链接路径是否正确</li><li>库版本是否兼容</li><li>符号修饰（symbol mangling）是否匹配</li><li>编译器选项是否正确</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 Linux 系统中，我们经常需要确认某个函数是否在特定的库文件中。以下是几种常用的查找方法。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://hmmmmmya.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://hmmmmmya.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>018_为什么我们常见的 IP 都是 192.168 开头的</title>
    <link href="https://hmmmmmya.github.io/2024/10/29/018_%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E5%B8%B8%E8%A7%81%E7%9A%84%20IP%20%E9%83%BD%E6%98%AF%20192.168%20%E5%BC%80%E5%A4%B4%E7%9A%84/"/>
    <id>https://hmmmmmya.github.io/2024/10/29/018_%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E5%B8%B8%E8%A7%81%E7%9A%84%20IP%20%E9%83%BD%E6%98%AF%20192.168%20%E5%BC%80%E5%A4%B4%E7%9A%84/</id>
    <published>2024-10-29T07:56:00.000Z</published>
    <updated>2024-11-11T03:31:34.345Z</updated>
    
    <content type="html"><![CDATA[<p>为什么我们常见的 IP 都是 192.168 开头的</p><span id="more"></span><h2 id="ip-地址划分"><a href="#ip-地址划分" class="headerlink" title="ip 地址划分"></a>ip 地址划分</h2><p>参考：<a href="https://xiaolincoding.com/network/4_ip/ip_base.html#ip-%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%86%E7%B1%BB">IP 地址的分类</a></p><p>互联网诞生之初，IP 地址显得很充裕，于是计算机科学家们设计了分类地址。</p><p>IP 地址分类成了 5 种类型，分别是 A 类、B 类、C 类、D 类、E 类。</p><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20241029151149.png" alt="IP 地址的分类"></p><p>上图中黄色部分为分类号，用以区分 IP 地址类别。</p><h2 id="私网地址划分"><a href="#私网地址划分" class="headerlink" title="私网地址划分"></a>私网地址划分</h2><blockquote><p>10.0.0.0–10.255.255.255</p><p>172.16.0.0–172.31.255.255</p><p>192.168.0.0–192.168.255.255</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/image-20241029144309499.png" alt="私网地址"></p><p>除了这三个 ip 地址段为私有 ip 地址外，其它的都为公网 ip。</p><p>这些地址已被声明私有化，任何内网中的设备可以任意使用这些地址，但是在这三个范围内的 IP 地址不允许出现在 Internet（外网）上。所以我们平台在内部组网时用的比较多，比如监控项目与公司内部电脑 ip 设置，用的多的就是 192.168.xx。</p><p>通常情况下，按照需要容纳的主机数选择私有地址段。家庭网络规模比较小，一个 C 类地址，192.168.1.x 可以容纳 254 个终端，足够使用。</p><p>学校或者大型企业可能使用 B 类甚至 A 类作为内部网络的地址段。比如手机上网很可能获取的也是一个 10 开头的内网地址，而不是公网地址。</p><h2 id="NAT-地址转换"><a href="#NAT-地址转换" class="headerlink" title="NAT 地址转换"></a>NAT 地址转换</h2><p>私网地址只能在局域网中使用，不同的局域网可以使用同样的私网地址，私网地址是不能出现在互联网上的。那么私网地址如何访问互联网呢？这就需要用到 NAT 地址转换，将内网地址映射到外网地址。</p><p>而<strong>NAT 地址转换</strong>它实现内网的 IP 地址与公网的地址之间的相互转换，将大量的内网 IP 地址转换为一个或少量的公网 IP 地址，减少对公网 IP 地址的占用。</p><p>家庭网络普遍使用端口映射的方式，NAT 的核心是一张映射表（源 IP 地址，源端口，目的 IP 地址，目的端口），将内网源 IP 地址和端口映射到同一个公网地址的不同端口，如下图所示。</p><table><thead><tr><th>内网 IP（源地址:端口）</th><th>外网 IP（目标地址:端口）</th></tr></thead><tbody><tr><td>192.168.1.55:5566</td><td>219.152.168.222:9200</td></tr><tr><td>192.168.1.59:80</td><td>219.152.168.222:9201</td></tr><tr><td>192.168.1.59:4465</td><td>219.152.168.222:9202</td></tr></tbody></table><p>总之，家庭网络由于网络规模比较小，通常使用了 192.168 开头的私网地址，光猫拨号获取了一个公网地址（或者运营商私网地址），通过 NAT 方式的映射到这个公网地址的不同端口，访问互联网。主要注意的 NAT 模式和路由模式是不同的。</p><h2 id="无分类地址-CIDR"><a href="#无分类地址-CIDR" class="headerlink" title="无分类地址 CIDR"></a>无分类地址 CIDR</h2><p>正因为 IP 分类存在许多缺点，所以后面提出了无分类地址的方案，即 CIDR。</p><p>这种方式不再有分类地址的概念，32 比特的 IP 地址被划分为两部分，前面是网络号，后面是主机号。</p><p>怎么划分网络号和主机号的呢？</p><p>表示形式 a.b.c.d&#x2F;x，其中 &#x2F;x 表示前 x 位属于网络号， x 的范围是 0 ~ 32，这就使得 IP 地址更加具有灵活性。</p><p>比如 10.100.122.2&#x2F;24，这种地址表示形式就是 CIDR，&#x2F;24 表示前 24 位是网络号，剩余的 8 位是主机号。</p><h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><p>子网掩码和 CIDR 是配套使用的，CIDR 表示网络号，子网掩码表示主机号。掩码的意思就是掩盖掉主机号，剩余的就是网络号。</p><p>子网掩码和 IP 地址一样，也是 32 比特，左边是网络号，右边是主机号。</p><h2 id="网络号和主机号"><a href="#网络号和主机号" class="headerlink" title="网络号和主机号"></a>网络号和主机号</h2><p>网络号和主机号在 IP 地址中有着各自重要的作用，帮助计算机网络有效地传输数据和管理地址。具体来说：</p><h3 id="网络号-Network-Part"><a href="#网络号-Network-Part" class="headerlink" title="网络号 (Network Part)"></a>网络号 (Network Part)</h3><ul><li><p>定义：网络号是 IP 地址的前一部分，用于标识一个特定的网络。</p></li><li><p>作用：</p><ul><li><p>路由：网络设备（如路由器）利用网络号将数据包发送到正确的子网或网络。只需要检查数据包的网络号，就可以决定将其转发到哪个子网。</p></li><li><p>网络管理：网络号有助于网络管理员管理和组织不同的子网。通过网络号，管理员可以轻松地分配和控制 IP 地址资源。</p></li></ul></li></ul><h3 id="主机号-Host-Part"><a href="#主机号-Host-Part" class="headerlink" title="主机号 (Host Part)"></a>主机号 (Host Part)</h3><ul><li><p>定义：主机号是 IP 地址的后一部分，用于标识网络中的特定设备或节点。</p></li><li><p>作用：</p><ul><li><p>设备标识：主机号唯一标识网络中的每一个设备，确保数据包能准确地到达目标设备。</p></li><li><p>地址分配：在同一子网内，主机号确保每一个设备都有一个独一无二的地址，以避免地址冲突。</p></li></ul></li></ul><p>例如：<br>对于 IP 地址 192.168.1.1 和 子网掩码 255.255.255.0（C 类地址）：</p><ul><li><p>网络号：192.168.1（前 24 位）</p></li><li><p>主机号：1（后 8 位）</p></li></ul><p>这个地址划分方式确保了不同网络可以通过网络号来区分，同时在同一网络内的每个设备通过主机号来区分，从而实现高效的网络管理和数据传输。</p><h2 id="192-168"><a href="#192-168" class="headerlink" title="192.168"></a>192.168</h2><p>192.168.x.x 是 ipv4 的 c 类地址划分的一部分</p><p>C 类网络地址划分: 110 开头，21 位网络号，8 位主机号。C 类网络地址的 192.168 号段才是私有地址，其他号段是公有地址。</p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/image-20241029144154815.png" alt="image-20241029144154815" style="zoom: 67%;" /><p>C 类网络中，192.168 划分为私有地址，从 192.168.0.0 到 192.168.255.255。</p><h2 id="192-168-11-63"><a href="#192-168-11-63" class="headerlink" title="192.168.11.63"></a>192.168.11.63</h2><p>inet: 192.168.11.63<br>netmask: 255.255.248.0&#x2F;21</p><p>192.168.11.63 是 C 类网络地址，192.168 是网络号，11 是子网号，63 是主机号。</p><p>192.168.11.63 的二进制表示：</p><p>11000000.10101000.00001011.01111111</p><p>网络号：11000000.10101000.00001, 21 位网络号, 用于标识同一子网。</p><p>主机号：011 11111, 8 位主机号, 用于标识同一子网内的不同设备。</p><p>255.255.248.0 的二进制表示：</p><p>11111111.11111111.11111000.00000000</p><h3 id="同一子网"><a href="#同一子网" class="headerlink" title="同一子网"></a>同一子网</h3><p>从 11000000.10101000.00001000.00000000 到 11000000.10101000.00001111.11111111</p><p>即: 192.168.8.0 到 192.168.15.255</p><p>可用设备数: 2^8 - 2 &#x3D; 254</p><p>特殊地址:</p><ul><li><p>192.168.8.0: 网络地址, 不能分配给设备, 用于标识子网</p></li><li><p>192.168.15.255: 广播地址</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;为什么我们常见的 IP 都是 192.168 开头的&lt;/p&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="https://hmmmmmya.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://hmmmmmya.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>017_开发工具推荐</title>
    <link href="https://hmmmmmya.github.io/2024/10/23/017_%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/"/>
    <id>https://hmmmmmya.github.io/2024/10/23/017_%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/</id>
    <published>2024-10-23T06:30:00.000Z</published>
    <updated>2024-10-24T01:33:48.744Z</updated>
    
    <content type="html"><![CDATA[<p>开发工具推荐</p><span id="more"></span><h3 id="开发工具推荐"><a href="#开发工具推荐" class="headerlink" title="开发工具推荐"></a>开发工具推荐</h3><table><thead><tr><th>平台</th><th>工具名称</th><th>功能描述</th><th>网址</th></tr></thead><tbody><tr><td><strong>IDE</strong></td><td>cursor</td><td>内置大模型, 完美兼容 vscode</td><td></td></tr><tr><td></td><td>vscode</td><td>插件丰富</td><td></td></tr><tr><td><strong>Git</strong></td><td>git</td><td>版本控制</td><td></td></tr><tr><td></td><td>Github Desktop</td><td>github 桌面客户端</td><td></td></tr><tr><td><strong>比较</strong></td><td>Beyond Compare</td><td>文件对比</td><td></td></tr><tr><td><strong>远程</strong></td><td>MobaXterm</td><td>远程连接</td><td></td></tr><tr><td><strong>数据库</strong></td><td>Navicat Premium Lite</td><td>数据库管理</td><td><a href="https://www.navicat.com.cn/download/navicat-premium-lite">https://www.navicat.com.cn/download/navicat-premium-lite</a></td></tr><tr><td><strong>容器</strong></td><td>Docker Desktop</td><td>容器化</td><td></td></tr><tr><td><strong>代理</strong></td><td>clash</td><td>代理工具</td><td></td></tr><tr><td><strong>抓包</strong></td><td>wireshark</td><td>抓包工具</td><td></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;开发工具推荐&lt;/p&gt;</summary>
    
    
    
    <category term="工具" scheme="https://hmmmmmya.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="工具" scheme="https://hmmmmmya.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>016_笔记工具推荐</title>
    <link href="https://hmmmmmya.github.io/2024/10/23/016_%E7%AC%94%E8%AE%B0%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/"/>
    <id>https://hmmmmmya.github.io/2024/10/23/016_%E7%AC%94%E8%AE%B0%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/</id>
    <published>2024-10-23T04:00:00.000Z</published>
    <updated>2024-10-25T01:29:42.320Z</updated>
    
    <content type="html"><![CDATA[<p>笔记工具推荐</p><span id="more"></span><h3 id="笔记工具推荐"><a href="#笔记工具推荐" class="headerlink" title="笔记工具推荐"></a>笔记工具推荐</h3><table><thead><tr><th>平台</th><th>工具名称</th><th>功能描述</th></tr></thead><tbody><tr><td>windows</td><td>vscode</td><td>编辑功能强大, 代码管控</td></tr><tr><td>windows</td><td>typora</td><td>界面优雅, pin 目录后可以快速切换</td></tr><tr><td>windows</td><td><del>vnote</del></td><td>快速切换, 快速修改, 不够优雅, 配置麻烦</td></tr><tr><td>windows</td><td>heynote</td><td>程序员笔记</td></tr><tr><td>windows</td><td>navicat</td><td>数据库</td></tr><tr><td>跨平台</td><td>wps</td><td>表格</td></tr><tr><td>跨平台</td><td>flomo</td><td>简短, 方便同步</td></tr><tr><td>跨平台</td><td>幕布</td><td>思维导图</td></tr><tr><td>跨平台</td><td>github</td><td>笔记托管</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;笔记工具推荐&lt;/p&gt;</summary>
    
    
    
    <category term="工具" scheme="https://hmmmmmya.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="工具" scheme="https://hmmmmmya.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>015_windows实用工具推荐</title>
    <link href="https://hmmmmmya.github.io/2024/10/23/015_windows%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/"/>
    <id>https://hmmmmmya.github.io/2024/10/23/015_windows%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/</id>
    <published>2024-10-23T02:09:14.000Z</published>
    <updated>2024-10-24T01:32:46.825Z</updated>
    
    <content type="html"><![CDATA[<p>windows 实用工具推荐</p><span id="more"></span><h3 id="Windows-实用工具推荐"><a href="#Windows-实用工具推荐" class="headerlink" title="Windows 实用工具推荐"></a>Windows 实用工具推荐</h3><table><thead><tr><th>分类</th><th>工具名称</th><th>功能描述</th><th>网址</th></tr></thead><tbody><tr><td>截图工具</td><td>Snipaste</td><td>支持截图后贴图，贴图后可继续截图</td><td><a href="https://zh.snipaste.com/download.html">https://zh.snipaste.com/download.html</a></td></tr><tr><td>文件管理</td><td>Everything</td><td>快速文件搜索工具，比 Windows 自带搜索更快</td><td><a href="https://www.voidtools.com/zh-cn/downloads/">https://www.voidtools.com/zh-cn/downloads/</a></td></tr><tr><td>系统维护</td><td>Geek Uninstaller</td><td>卸载软件工具，可彻底清理残留文件</td><td></td></tr><tr><td>桌面管理</td><td>DeskPins</td><td>桌面置顶工具，可置顶任何窗口</td><td></td></tr><tr><td>翻译工具</td><td>网易有道翻译</td><td>多语言翻译工具</td><td></td></tr><tr><td>网盘</td><td>百度网盘</td><td>文件存储与下载</td><td></td></tr><tr><td>聊天工具</td><td>CleanMyWechat</td><td>微信清理工具</td><td></td></tr></tbody></table><p>这些工具可以大大提高 Windows 系统的使用效率和体验。根据个人需求，选择合适的工具来优化您的工作流程。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;windows 实用工具推荐&lt;/p&gt;</summary>
    
    
    
    <category term="工具" scheme="https://hmmmmmya.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="工具" scheme="https://hmmmmmya.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>014_rss订阅</title>
    <link href="https://hmmmmmya.github.io/2024/10/12/014_rss%E8%AE%A2%E9%98%85%20copy/"/>
    <id>https://hmmmmmya.github.io/2024/10/12/014_rss%E8%AE%A2%E9%98%85%20copy/</id>
    <published>2024-10-12T02:09:14.000Z</published>
    <updated>2024-10-23T06:56:10.303Z</updated>
    
    <content type="html"><![CDATA[<p>rss 可以绕过算法推荐, 并且不遗漏地接收关注的动态, 重新成为订阅的主人</p><span id="more"></span><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ol><li><a href="https://www.inoreader.com/">Inoreader</a></li><li><a href="https://github.com/DIYgod/RSSHub">RssHub</a></li><li><a href="https://vercel.com/">Vercel</a></li></ol><h3 id="Inoreader"><a href="#Inoreader" class="headerlink" title="Inoreader"></a>Inoreader</h3><p>多端同步的 rss 阅读器, 亲测是最方便, 最容易同步, 加载源最容易成功的 rss 服务器, 页面也很高大上</p><p>包含了网页端、浏览器插件、app</p><h3 id="RssHub"><a href="#RssHub" class="headerlink" title="RssHub"></a>RssHub</h3><p>集成了最新的 rss 订阅源, 号称是让每一个网站都能做成 rss 订阅。当前绝大部分的网站都不主动公开 rss 订阅的方式了, RssHub 可以弥补这一点。</p><h3 id="Vercel"><a href="#Vercel" class="headerlink" title="Vercel"></a>Vercel</h3><p>很多网站对爬虫源进行了屏蔽, RssHub 也是一种网络爬虫的方式。将 RssHub 部署到自己的服务器, 有了新的域名, 便可以绕过这一层。Vercel 可以部署 RssHub 项目, 从而省去了购买服务器的花销。</p><p>Vercel 部署 RssHub 的教程可以参考: <a href="https://cloud.tencent.com/developer/article/2432561">手把手教你用 Vercel 免费部署 RSSHub</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;rss 可以绕过算法推荐, 并且不遗漏地接收关注的动态, 重新成为订阅的主人&lt;/p&gt;</summary>
    
    
    
    
    <category term="rss" scheme="https://hmmmmmya.github.io/tags/rss/"/>
    
  </entry>
  
  <entry>
    <title>013_内网穿透工具</title>
    <link href="https://hmmmmmya.github.io/2024/09/21/013_%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7/"/>
    <id>https://hmmmmmya.github.io/2024/09/21/013_%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7/</id>
    <published>2024-09-21T02:24:14.000Z</published>
    <updated>2024-10-29T04:05:24.333Z</updated>
    
    <content type="html"><![CDATA[<p>localtunnel 和 Cloudflare Tunnels 都是内网穿透工具，可以方便快捷的将本地 Localhost 暴露给全世界，无需修改 DNS 和防火墙设置</p><span id="more"></span><h2 id="localtunnel"><a href="#localtunnel" class="headerlink" title="localtunnel"></a>localtunnel</h2><p>localtunnel 是一款基于 node.js 的内网穿透工具，非常流行，可以方便快捷的将本地 Localhost 暴露给全世界，无需修改 DNS 和防火墙设置</p><p>github 地址: <code>https://github.com/localtunnel/localtunnel</code></p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><ol><li><p>安装: <code>npm install -g localtunnel</code></p></li><li><p>绑定端口: <code>lt --port 8000</code>, 绑定要访问内网服务的端口, 即本地访问该服务的端口</p></li><li><p>公网 ip:之后会生成一个 https 的公网 ip 地址, 通过该地址可以访问内网</p></li><li><p>访问密码: 本地访问该 ip, 点击查看密码, 即可看到。从外网访问 ip，并输出密码即可</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240921095753.png" alt="获取并输入密码"></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol><li>服务关闭后, 外网不可访问, 再次开启后会分配新的 ip</li></ol><h2 id="Cloudflare-Tunnels"><a href="#Cloudflare-Tunnels" class="headerlink" title="Cloudflare Tunnels"></a>Cloudflare Tunnels</h2><p>Tunnels：如果你想在外网访问家里的设备，又很难申请到公网 IP，就可以使用 Cloudflare Tunnels 实现的免费内网穿透服务，这种方案配置简单，无数量限制、无流量限制</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;localtunnel 和 Cloudflare Tunnels 都是内网穿透工具，可以方便快捷的将本地 Localhost 暴露给全世界，无需修改 DNS 和防火墙设置&lt;/p&gt;</summary>
    
    
    
    <category term="网络" scheme="https://hmmmmmya.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络" scheme="https://hmmmmmya.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>012_修改wsl环境下的docker container 端口</title>
    <link href="https://hmmmmmya.github.io/2024/09/19/012_%E4%BF%AE%E6%94%B9wsl%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84docker%20container%20%E7%AB%AF%E5%8F%A3/"/>
    <id>https://hmmmmmya.github.io/2024/09/19/012_%E4%BF%AE%E6%94%B9wsl%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84docker%20container%20%E7%AB%AF%E5%8F%A3/</id>
    <published>2024-09-19T01:52:12.000Z</published>
    <updated>2024-10-09T02:01:16.488Z</updated>
    
    <content type="html"><![CDATA[<p>wsl 下, 修改已创建容器的端口</p><p>工具: wsl, docker</p><span id="more"></span><p>路径: <code>\\wsl.localhost\docker-desktop-data\data\docker\containers\</code></p><p>容器文件名参考 <code>docker desktop</code> 的容器名下的序列号</p><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240919100031.png" alt="容器文件名"></p><p>修改文件: <code>hostconfig.json</code> 中的 <code>PortBindings</code> 的 <code>HostPort</code></p><p>重启 <code>docker desktop</code>, 注意需要退出后再开启, 不能仅 restart docker, 否则修改被抹除</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;wsl 下, 修改已创建容器的端口&lt;/p&gt;
&lt;p&gt;工具: wsl, docker&lt;/p&gt;</summary>
    
    
    
    <category term="docker" scheme="https://hmmmmmya.github.io/categories/docker/"/>
    
    
    <category term="docker" scheme="https://hmmmmmya.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>011_Linux配置依赖环境</title>
    <link href="https://hmmmmmya.github.io/2024/06/25/011_Linux%E9%85%8D%E7%BD%AE%E4%BE%9D%E8%B5%96%E7%8E%AF%E5%A2%83/"/>
    <id>https://hmmmmmya.github.io/2024/06/25/011_Linux%E9%85%8D%E7%BD%AE%E4%BE%9D%E8%B5%96%E7%8E%AF%E5%A2%83/</id>
    <published>2024-06-25T03:47:32.000Z</published>
    <updated>2024-10-29T08:40:39.540Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 依赖各种库，有的是项目文件夹 lib 里面已经有了，有的需要安装。本文介绍了在 WSL2 编译一个项目遇到的环境问题。在一天半的时间尝试下，终于解决了，记录下解决的过程。</p><span id="more"></span><h2 id="配置-Linux-依赖"><a href="#配置-Linux-依赖" class="headerlink" title="配置 Linux 依赖"></a>配置 Linux 依赖</h2><h3 id="查找库或依赖"><a href="#查找库或依赖" class="headerlink" title="查找库或依赖"></a>查找库或依赖</h3><ol><li><p><strong>使用包管理工具</strong>：</p><ul><li><p>在 Debian 或 Ubuntu 系统上，可以使用<code>apt-cache search</code>命令查找库。例如，要查找包含“mat”关键字的库：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-cache search mat</span><br></pre></td></tr></table></figure></li><li><p>在 CentOS 或 Red Hat 系统上，可以使用<code>yum search</code>命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum search mat</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>使用<code>ldconfig</code>命令</strong>：</p><ul><li><p><code>ldconfig</code>命令用于配置和管理共享库的符号链接和缓存。</p></li><li><p>可以使用<code>ldconfig -p | grep libmat</code>命令查看系统中已知的库：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldconfig -p | grep libmat</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>手动查找</strong>：</p><ul><li><p>使用<code>find</code>或<code>locate</code>命令在系统中搜索特定的库文件。例如，查找<code>libmat.so</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name libmat.so 2&gt;/dev/null</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate libmat</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="设置路径"><a href="#设置路径" class="headerlink" title="设置路径"></a>设置路径</h3><ol><li><p><strong>编译时设置库路径</strong>：</p><ul><li><p>使用<code>-L</code>选项指定库文件所在的目录。例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o your_program your_program.c -L/path/to/library -lmat</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>运行时设置库路径</strong>：</p><ul><li><p>设置<code>LD_LIBRARY_PATH</code>环境变量以包括库文件所在的目录。例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/path/to/library:<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure></li><li><p>将上述命令添加到<code>.bashrc</code>或<code>.bash_profile</code>文件中以使其在每次终端启动时生效：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export LD_LIBRARY_PATH=/path/to/library:$LD_LIBRARY_PATH&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>使用<code>ldconfig</code>配置共享库</strong>：</p><ul><li><p>将库文件路径添加到系统的共享库配置中。编辑或创建文件<code>/etc/ld.so.conf.d/custom_libs.conf</code>，添加库路径：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/path/to/library</span><br></pre></td></tr></table></figure></li><li><p>然后运行<code>ldconfig</code>命令更新缓存：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>假设你在<code>/home/user/libs</code>目录下有<code>libmat.so</code>和<code>libmx.so</code>库文件，并且需要在编译和运行时使用这些库。</p><ol><li><p><strong>编译时设置路径</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o my_program my_program.c -L/home/user/libs -lmat -lmx</span><br></pre></td></tr></table></figure></li><li><p><strong>运行时设置路径</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/home/user/libs:<span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line">./my_program</span><br></pre></td></tr></table></figure></li><li><p><strong>永久设置路径</strong>：<br>编辑<code>~/.bashrc</code>文件，添加以下行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/home/user/libs:<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure><p>然后运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure></li></ol><p>通过以上步骤，你可以查找和配置所需的库路径，确保程序能够正确链接和运行。</p><h2 id="安装的库版本不匹配"><a href="#安装的库版本不匹配" class="headerlink" title="安装的库版本不匹配"></a>安装的库版本不匹配</h2><p>根据您提供的信息，链接器无法找到<code>libjsoncpp.so.1</code>，而是找到了其他版本的<code>libjsoncpp.so</code>。这是因为系统上安装的<code>libjsoncpp</code>库版本不匹配。您可以通过以下步骤解决这个问题：</p><h3 id="解决方案-1：使用-rpath或-rpath-link"><a href="#解决方案-1：使用-rpath或-rpath-link" class="headerlink" title="解决方案 1：使用-rpath或-rpath-link"></a>解决方案 1：使用<code>-rpath</code>或<code>-rpath-link</code></h3><p>您可以在链接时使用<code>-rpath</code>或<code>-rpath-link</code>选项来指定库的路径。</p><p>假设您的库文件在<code>/usr/lib/x86_64-Linux-gnu</code>目录下，可以这样做：</p><ol><li><p>修改您的编译命令以包含<code>-Wl,-rpath,/usr/lib/x86_64-Linux-gnu</code></p></li><li><p>或者在 CMakeLists.txt 文件中设置链接器路径：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_INSTALL_RPATH <span class="string">&quot;/usr/lib/x86_64-Linux-gnu&quot;</span>)</span><br></pre></td></tr></table></figure></li></ol><h3 id="解决方案-2：创建符号链接"><a href="#解决方案-2：创建符号链接" class="headerlink" title="解决方案 2：创建符号链接"></a>解决方案 2：创建符号链接</h3><p>如果您需要的<code>libjsoncpp.so.1</code>确实存在于不同的位置，可以创建一个符号链接以便系统能够找到它。</p><ol><li><p>创建符号链接：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">ln</span> -s /usr/lib/x86_64-Linux-gnu/libjsoncpp.so.1.9.5 /usr/lib/x86_64-Linux-gnu/libjsoncpp.so.1</span><br></pre></td></tr></table></figure><p>如果使用<code>locate</code>定位不到新建的包, 更新 locate 数据库运行以下命令来更新 locate 数据库：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo updatedb</span><br></pre></td></tr></table></figure><p>然后再次运行 locate 命令</p></li></ol><h3 id="解决方案-3：安装正确版本的库"><a href="#解决方案-3：安装正确版本的库" class="headerlink" title="解决方案 3：安装正确版本的库"></a>解决方案 3：安装正确版本的库</h3><p>如果库的版本不匹配，您可以尝试安装正确版本的<code>libjsoncpp</code>。</p><ol><li><p>更新包管理器并安装正确的版本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install libjsoncpp1</span><br></pre></td></tr></table></figure></li></ol><h3 id="解决方案-4：指定库路径"><a href="#解决方案-4：指定库路径" class="headerlink" title="解决方案 4：指定库路径"></a>解决方案 4：指定库路径</h3><p>确保在链接器中指定正确的库路径。在编译时添加正确的路径：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o your_program your_program.cpp -L/usr/lib/x86_64-Linux-gnu -ljsoncpp</span><br></pre></td></tr></table></figure><h3 id="解决方案-5：环境变量"><a href="#解决方案-5：环境变量" class="headerlink" title="解决方案 5：环境变量"></a>解决方案 5：环境变量</h3><p>通过设置环境变量<code>LD_LIBRARY_PATH</code>来指定库的路径：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/usr/lib/x86_64-Linux-gnu:<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure><p>将上述命令添加到<code>.bashrc</code>文件中，以便每次启动终端时都生效：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export LD_LIBRARY_PATH=/usr/lib/x86_64-Linux-gnu:$LD_LIBRARY_PATH&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><p>通过这些步骤，您应该能够解决链接器找不到<code>libjsoncpp.so.1</code>的问题并成功编译您的程序。</p><h2 id="Q-A"><a href="#Q-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ol><li><p>shell 脚本文件没有可执行权限</p><p>matlab.sh 负责将 matlab 所用的库拷贝到&#x2F;build&#x2F;lib 文件夹, 这里发现 matlab.sh 并没有执行, 增加可执行权限后正常执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@DESKTOP-S5NII96:/home/guo/code/WT328/api<span class="comment"># ./matlab.sh</span></span><br><span class="line">bash: ./matlab.sh: Permission denied</span><br></pre></td></tr></table></figure></li><li><p>安装的软件版本不匹配</p><p>手动复制一份并重命名为所需软件(不行)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> /usr/lib/x86_64-Linux-gnu/libjsoncpp.so.1.9.5 /usr/lib/x86_64-Linux-gnu/libjsoncpp.so.1</span><br></pre></td></tr></table></figure><p>增加软链接(手动增加软连接无效)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@DESKTOP-S5NII96:/home/guo/code/WT328/source<span class="comment"># ls -l /usr/lib/x86_64-Linux-gnu/libjson*</span></span><br><span class="line">lrwxrwxrwx 1 root root     18 Aug 24  2023 /usr/lib/x86_64-Linux-gnu/libjson-c.so.5 -&gt; libjson-c.so.5.1.0</span><br><span class="line">-rw-r--r-- 1 root root  72080 Aug 24  2023 /usr/lib/x86_64-Linux-gnu/libjson-c.so.5.1.0</span><br><span class="line">lrwxrwxrwx 1 root root     16 Jan 30  2022 /usr/lib/x86_64-Linux-gnu/libjsoncpp.so -&gt; libjsoncpp.so.25</span><br><span class="line">-rwxrwxrwx 1 root root 215792 Jun 24 15:57 /usr/lib/x86_64-Linux-gnu/libjsoncpp.so.1</span><br><span class="line">-rw-r--r-- 1 root root 215792 Jan 30  2022 /usr/lib/x86_64-Linux-gnu/libjsoncpp.so.1.9.5</span><br><span class="line">lrwxrwxrwx 1 root root     19 Jan 30  2022 /usr/lib/x86_64-Linux-gnu/libjsoncpp.so.25 -&gt; libjsoncpp.so.1.9.5</span><br></pre></td></tr></table></figure><p>检查报错地方的依赖，能找到啊！！！怎么还报错呢</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@DESKTOP-S5NII96:/home/guo/code/WT328/source<span class="comment"># ldd /home/guo/code/WT328/source/../extlib/lib/libwt-calibration.so</span></span><br><span class="line"></span><br><span class="line">Linux-vdso.so.1 (0x00007fffab961000)</span><br><span class="line">libjsoncpp.so.1 =&gt; /lib/x86_64-Linux-gnu/libjsoncpp.so.1 (0x00007f466786a000)</span><br><span class="line">libstdc++.so.6 =&gt; /lib/x86_64-Linux-gnu/libstdc++.so.6 (0x00007f466763e000)</span><br><span class="line">libgcc_s.so.1 =&gt; /lib/x86_64-Linux-gnu/libgcc_s.so.1 (0x00007f466761e000)</span><br><span class="line">libpthread.so.0 =&gt; /lib/x86_64-Linux-gnu/libpthread.so.0 (0x00007f4667619000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-Linux-gnu/libc.so.6 (0x00007f46673f0000)</span><br><span class="line">libm.so.6 =&gt; /lib/x86_64-Linux-gnu/libm.so.6 (0x00007f4667309000)</span><br><span class="line">/lib64/ld-Linux-x86-64.so.2 (0x00007f4667922000)</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@DESKTOP-S5NII96:/home/guo/code/WT328/source<span class="comment"># locate libjsoncpp</span></span><br><span class="line"></span><br><span class="line">/usr/lib/x86_64-Linux-gnu/libjsoncpp.so</span><br><span class="line">/usr/lib/x86_64-Linux-gnu/libjsoncpp.so.1</span><br><span class="line">/usr/lib/x86_64-Linux-gnu/libjsoncpp.so.1.9.5</span><br><span class="line">/usr/lib/x86_64-Linux-gnu/libjsoncpp.so.25</span><br><span class="line">/usr/share/doc/libjsoncpp-dev</span><br><span class="line">/usr/share/doc/libjsoncpp25</span><br><span class="line">/usr/share/doc/libjsoncpp-dev/changelog.Debian.gz</span><br><span class="line">/usr/share/doc/libjsoncpp-dev/copyright</span><br><span class="line">/usr/share/doc/libjsoncpp25/README.Debian</span><br><span class="line">/usr/share/doc/libjsoncpp25/README.md</span><br><span class="line">/usr/share/doc/libjsoncpp25/changelog.Debian.gz</span><br><span class="line">/usr/share/doc/libjsoncpp25/copyright</span><br><span class="line">/var/lib/dpkg/info/libjsoncpp-dev:amd64.list</span><br><span class="line">/var/lib/dpkg/info/libjsoncpp-dev:amd64.md5sums</span><br><span class="line">/var/lib/dpkg/info/libjsoncpp25:amd64.list</span><br><span class="line">/var/lib/dpkg/info/libjsoncpp25:amd64.md5sums</span><br><span class="line">/var/lib/dpkg/info/libjsoncpp25:amd64.shlibs</span><br><span class="line">/var/lib/dpkg/info/libjsoncpp25:amd64.triggers</span><br><span class="line">root@DESKTOP-S5NII96:/home/guo/code/WT328/source<span class="comment"># ^C</span></span><br><span class="line">root@DESKTOP-S5NII96:/home/guo/code/WT328/source<span class="comment">#</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ld: /home/guo/code/WT328/source/../extlib/lib/libwt-calibration.so: undefined reference to  Json::Value::operator=(Json::Value)</span><br><span class="line">collect2: error: ld returned 1 <span class="built_in">exit</span> status</span><br><span class="line">make[1]: ***[/home/guo/code/WT328/source/base.mk:15: /home/guo/code/WT328/source/bin/WT-Manager] Error 1</span><br><span class="line">make[1]: Leaving directory /home/guo/code/WT328/source/manager</span><br><span class="line">make:*** [Makefile:85: all] Error 1</span><br></pre></td></tr></table></figure><p>可能是库有问题，这个版本的没有<code>Json::Value::operator=(Json::Value)</code></p><p>明天试试装 1.7.4 的版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 卸载1.9.5版本</span><br><span class="line">dpkg --list</span><br><span class="line"></span><br><span class="line">sudo apt-get remove software</span><br><span class="line"></span><br><span class="line">// qinghua下载指定版本deb包</span><br><span class="line">// libjsoncpp1_1.7.4-3_amd64.deb 和 libjsoncpp-dev_1.7.4-3_amd64.deb</span><br><span class="line"></span><br><span class="line">// 安装</span><br><span class="line">root@DESKTOP-S5NII96:/home/guo/code<span class="comment"># dpkg -i libjsoncpp1_1.7.4-3_amd64.deb</span></span><br><span class="line"></span><br><span class="line">Selecting previously unselected package libjsoncpp1:amd64.</span><br><span class="line">(Reading database ... 49184 files and directories currently installed.)</span><br><span class="line">Preparing to unpack libjsoncpp1_1.7.4-3_amd64.deb ...</span><br><span class="line">Unpacking libjsoncpp1:amd64 (1.7.4-3) ...</span><br><span class="line">Setting up libjsoncpp1:amd64 (1.7.4-3) ...</span><br><span class="line">Processing triggers <span class="keyword">for</span> libc-bin (2.35-0ubuntu3.4) ...</span><br><span class="line">root@DESKTOP-S5NII96:/home/guo/code<span class="comment"># dpkg -i libjsoncpp-dev_1.7.4-3_amd64.deb</span></span><br><span class="line">Selecting previously unselected package libjsoncpp-dev:amd64.</span><br><span class="line">(Reading database ... 49193 files and directories currently installed.)</span><br><span class="line">Preparing to unpack libjsoncpp-dev_1.7.4-3_amd64.deb ...</span><br><span class="line">Unpacking libjsoncpp-dev:amd64 (1.7.4-3) ...</span><br><span class="line">Setting up libjsoncpp-dev:amd64 (1.7.4-3) ...</span><br><span class="line"></span><br><span class="line">// 查看效果</span><br><span class="line">root@DESKTOP-S5NII96:/usr/lib/x86_64-Linux-gnu<span class="comment"># ls -l |grep libjsonc</span></span><br><span class="line"></span><br><span class="line">-rw-r--r--  1 root root   372584 Aug 23  2016 libjsoncpp.a</span><br><span class="line">lrwxrwxrwx  1 root root       15 Aug 23  2016 libjsoncpp.so -&gt; libjsoncpp.so.1</span><br><span class="line">lrwxrwxrwx  1 root root       19 Aug 23  2016 libjsoncpp.so.1 -&gt; libjsoncpp.so.1.7.4</span><br><span class="line">-rw-r--r--  1 root root   203464 Aug 23  2016 libjsoncpp.so.1.7.4</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 编译服务器里面的依赖</span><br><span class="line">root@wt400:/home/j00503/Code/WT328/source/bin<span class="comment"># ldd libgeneral.so</span></span><br><span class="line"></span><br><span class="line">Linux-vdso.so.1 (0x00007ffe8c14c000)</span><br><span class="line">libjsoncpp.so.1 =&gt; /lib/x86_64-Linux-gnu/libjsoncpp.so.1 (0x00007f7cfb129000)</span><br><span class="line">libwt-calibration.so =&gt; not found</span><br><span class="line">libwt-crypto.so =&gt; not found</span><br><span class="line">libft4222.so =&gt; not found</span><br><span class="line">libAlg3gppVsa.so =&gt; not found</span><br><span class="line">libAlg3gppVsg.so =&gt; not found</span><br><span class="line">libAlgVsa.so =&gt; not found</span><br><span class="line">libAlgVsaGle.so =&gt; not found</span><br><span class="line">libAlgVsaSlb.so =&gt; not found</span><br><span class="line">libAlgVsaWifi11az.so =&gt; not found</span><br><span class="line">libAlgVsg.so =&gt; not found</span><br><span class="line">libAlgVsgGle.so =&gt; not found</span><br><span class="line">libAlgVsgSlb.so =&gt; not found</span><br><span class="line">libAlgVsgWifi11ah.so =&gt; not found</span><br><span class="line">libWT-Debug-Mem.so =&gt; not found</span><br><span class="line">libsqlite3.so.0 =&gt; /lib/x86_64-Linux-gnu/libsqlite3.so.0 (0x00007f7cfaffc000)</span><br><span class="line">libstdc++.so.6 =&gt; /lib/x86_64-Linux-gnu/libstdc++.so.6 (0x00007f7cfae1a000)</span><br><span class="line">libm.so.6 =&gt; /lib/x86_64-Linux-gnu/libm.so.6 (0x00007f7cfaccb000)</span><br><span class="line">libgcc_s.so.1 =&gt; /lib/x86_64-Linux-gnu/libgcc_s.so.1 (0x00007f7cfacae000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-Linux-gnu/libc.so.6 (0x00007f7cfaabc000)</span><br><span class="line">/lib64/ld-Linux-x86-64.so.2 (0x00007f7cfb806000)</span><br><span class="line">libpthread.so.0 =&gt; /lib/x86_64-Linux-gnu/libpthread.so.0 (0x00007f7cfaa99000)</span><br><span class="line">libdl.so.2 =&gt; /lib/x86_64-Linux-gnu/libdl.so.2 (0x00007f7cfaa93000)</span><br><span class="line"></span><br><span class="line">root@wt400:/home/j00503/Code/WT328/source/bin<span class="comment"># ldd /lib/x86_64-Linux-gnu/libjsoncpp.so.1</span></span><br><span class="line">Linux-vdso.so.1 (0x00007ffce2ad4000)</span><br><span class="line">libstdc++.so.6 =&gt; /lib/x86_64-Linux-gnu/libstdc++.so.6 (0x00007f3dde1ae000)</span><br><span class="line">libm.so.6 =&gt; /lib/x86_64-Linux-gnu/libm.so.6 (0x00007f3dde05f000)</span><br><span class="line">libgcc_s.so.1 =&gt; /lib/x86_64-Linux-gnu/libgcc_s.so.1 (0x00007f3dde044000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-Linux-gnu/libc.so.6 (0x00007f3ddde52000)</span><br><span class="line">/lib64/ld-Linux-x86-64.so.2 (0x00007f3dde3db000)</span><br><span class="line"></span><br><span class="line">root@wt400:/home/j00503/Code/WT328/source/bin<span class="comment"># ls -l /lib/x86_64-Linux-gnu/libjsoncpp*</span></span><br><span class="line">-rw-r--r-- 1 root root 436438 3月  21  2020 /lib/x86_64-Linux-gnu/libjsoncpp.a</span><br><span class="line">lrwxrwxrwx 1 root root     15 3月  21  2020 /lib/x86_64-Linux-gnu/libjsoncpp.so -&gt; libjsoncpp.so.1</span><br><span class="line">lrwxrwxrwx 1 root root     19 3月  21  2020 /lib/x86_64-Linux-gnu/libjsoncpp.so.1 -&gt; libjsoncpp.so.1.7.4</span><br><span class="line">-rw-r--r-- 1 root root 215840 3月  21  2020 /lib/x86_64-Linux-gnu/libjsoncpp.so.1.7.4</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240625095531.png" alt="WSL2"></p><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240625095607.png" alt="编译服务器"></p><p>又发现了 cmake 失效</p><p>cmake 依赖于<code>libjsoncpp.so.25</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 手动安装 libjsoncpp25 并使用 1.9.5-3 版本</span><br><span class="line">root@DESKTOP-S5NII96:/home/guo<span class="comment"># dpkg -i ./libjsoncpp25_1.9.5-3_amd64.deb</span></span><br><span class="line">(Reading database ... 49218 files and directories currently installed.)</span><br><span class="line">Preparing to unpack .../libjsoncpp25_1.9.5-3_amd64.deb ...</span><br><span class="line">Unpacking libjsoncpp25:amd64 (1.9.5-3) over (1.9.5-3) ...</span><br><span class="line">Setting up libjsoncpp25:amd64 (1.9.5-3) ...</span><br><span class="line">Processing triggers <span class="keyword">for</span> libc-bin (2.35-0ubuntu3.8) ...</span><br><span class="line"></span><br><span class="line">// cmake正常使用</span><br><span class="line">root@DESKTOP-S5NII96:/home/guo<span class="comment"># cmake</span></span><br><span class="line">Usage</span><br><span class="line">cmake [options] &lt;path-to-source&gt;</span><br><span class="line">cmake [options] &lt;path-to-existing-build&gt;</span><br><span class="line">cmake [options] -S &lt;path-to-source&gt; -B &lt;path-to-build&gt;</span><br><span class="line">Specify a <span class="built_in">source</span> directory to (re-)generate a build system <span class="keyword">for</span> it <span class="keyword">in</span> the</span><br><span class="line">current working directory.  Specify an existing build directory to</span><br><span class="line">re-generate its build system.</span><br><span class="line">Run <span class="string">&#x27;cmake --help&#x27;</span> <span class="keyword">for</span> more information.</span><br><span class="line"></span><br><span class="line">// 先安装 libjsoncpp.so.1.9.5 和 libjsoncpp25，cmake正常使用</span><br><span class="line">// <span class="built_in">source</span>编译还是报找不到libjsoncpp.so.1的错误</span><br><span class="line">root@DESKTOP-S5NII96:/usr/lib/x86_64-Linux-gnu<span class="comment"># ls -l libjsoncpp*</span></span><br><span class="line">lrwxrwxrwx 1 root root     16 Jan 30  2022 libjsoncpp.so -&gt; libjsoncpp.so.25</span><br><span class="line">-rw-r--r-- 1 root root 215792 Jan 30  2022 libjsoncpp.so.1.9.5</span><br><span class="line">lrwxrwxrwx 1 root root     19 Jan 30  2022 libjsoncpp.so.25 -&gt; libjsoncpp.so.1.9.5</span><br></pre></td></tr></table></figure><p>再次安装<code>libjsoncpp1_1.7.4-3_amd64.deb</code>, 编译 source 正常</p><p>总结:</p><ol><li><p>需要安装 3 个软件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">libjsoncpp-dev // 当前最新是 1.9.5 版本</span><br><span class="line">libjsoncpp25_1.9.5-3_amd64.deb // 对应上面的最新版本</span><br><span class="line">libjsoncpp1_1.7.4-3_amd64.deb // 安装 libjsoncpp1，安装1.7.4版本，后面没有更新了</span><br><span class="line"></span><br><span class="line">// 当前效果</span><br><span class="line">root@DESKTOP-S5NII96:/usr/lib/x86_64-Linux-gnu<span class="comment"># ls -l libjsoncpp*</span></span><br><span class="line"></span><br><span class="line">lrwxrwxrwx 1 root root     16 Jan 30  2022 libjsoncpp.so -&gt; libjsoncpp.so.25</span><br><span class="line">lrwxrwxrwx 1 root root     19 Aug 23  2016 libjsoncpp.so.1 -&gt; libjsoncpp.so.1.7.4</span><br><span class="line">-rw-r--r-- 1 root root 203464 Aug 23  2016 libjsoncpp.so.1.7.4</span><br><span class="line">-rw-r--r-- 1 root root 215792 Jan 30  2022 libjsoncpp.so.1.9.5</span><br><span class="line">lrwxrwxrwx 1 root root     19 Jan 30  2022 libjsoncpp.so.25 -&gt; libjsoncpp.so.1.9.5</span><br></pre></td></tr></table></figure></li><li><p>手动设置软连接是无效的, 本因是需要装三个软件</p></li><li><p>手动安装软件包。在清华源里面查找对应包，下载下来，使用<code>dpkg -i a.deb</code>来安装 &#x2F;&#x2F; 假设 a 为软件包名</p></li><li><p>卸载软件包 <code>sudo apt remove a</code></p></li><li><p>定位软件包 <code>locate a</code></p></li><li><p>更新<code>locate</code>用 <code>updatedb</code></p></li></ol></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;Linux 依赖各种库，有的是项目文件夹 lib 里面已经有了，有的需要安装。本文介绍了在 WSL2 编译一个项目遇到的环境问题。在一天半的时间尝试下，终于解决了，记录下解决的过程。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://hmmmmmya.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://hmmmmmya.github.io/tags/Linux/"/>
    
  </entry>
  
</feed>
