<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hymns</title>
  
  
  <link href="https://hmmmmmya.github.io/atom.xml" rel="self"/>
  
  <link href="https://hmmmmmya.github.io/"/>
  <updated>2024-10-31T08:51:03.102Z</updated>
  <id>https://hmmmmmya.github.io/</id>
  
  <author>
    <name>Hymns</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>023_cpp折叠表达式</title>
    <link href="https://hmmmmmya.github.io/2024/10/31/023-cpp%E6%8A%98%E5%8F%A0%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://hmmmmmya.github.io/2024/10/31/023-cpp%E6%8A%98%E5%8F%A0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2024-10-31T08:50:14.000Z</published>
    <updated>2024-10-31T08:51:03.102Z</updated>
    
    <content type="html"><![CDATA[<p>C++中的折叠表达式（Fold Expressions）是一种简化变参模板函数编写的语法，从 C++17 开始引入。折叠表达式可以对可变参数模板进行自动折叠，从而简化代码。</p><span id="more"></span><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>折叠表达式可以将可变参数模板中的所有参数，通过特定的运算符折叠为一个结果。常见的运算符包括加法<code>+</code>、乘法<code>*</code>、逻辑与<code>&amp;&amp;</code>、逻辑或<code>||</code>等。折叠表达式主要有四种形式：</p><ol><li><strong>一元左折叠</strong>：从左到右依次折叠，例如：<code>(args + ...)</code></li><li><strong>一元右折叠</strong>：从右到左依次折叠，例如：<code>(... + args)</code></li><li><strong>二元左折叠</strong>：用于指定初始值，从左到右依次折叠，例如：<code>(init + ... + args)</code></li><li><strong>二元右折叠</strong>：用于指定初始值，从右到左依次折叠，例如：<code>(args + ... + init)</code></li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>以下是每种折叠表达式的代码示例：</p><h4 id="1-一元左折叠"><a href="#1-一元左折叠" class="headerlink" title="1. 一元左折叠"></a>1. 一元左折叠</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args + ...);  <span class="comment">// 将参数依次相加</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);  <span class="comment">// 返回 1 + 2 + 3 + 4 = 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-一元右折叠"><a href="#2-一元右折叠" class="headerlink" title="2. 一元右折叠"></a>2. 一元右折叠</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (... + args);  <span class="comment">// 从右到左依次相加</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-二元左折叠"><a href="#3-二元左折叠" class="headerlink" title="3. 二元左折叠"></a>3. 二元左折叠</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span> + ... + args);  <span class="comment">// 从0开始，依次相加</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);  <span class="comment">// 返回 0 + 1 + 2 + 3 + 4 = 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-二元右折叠"><a href="#4-二元右折叠" class="headerlink" title="4. 二元右折叠"></a>4. 二元右折叠</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args + ... + <span class="number">0</span>);  <span class="comment">// 从右到左依次相加，最终加0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常见应用场景"><a href="#常见应用场景" class="headerlink" title="常见应用场景"></a>常见应用场景</h3><p>折叠表达式在编写模板时非常有用，常见的应用场景包括：</p><ol><li><strong>累加求和</strong>：将参数列表中的所有值求和。</li><li><strong>逻辑判断</strong>：可以通过折叠表达式实现<code>&amp;&amp;</code>和<code>||</code>运算来检查所有参数是否满足某个条件。</li><li><strong>打印参数</strong>：配合<code>std::cout</code>可以实现简单的参数打印。</li></ol><h4 id="逻辑判断的示例"><a href="#逻辑判断的示例" class="headerlink" title="逻辑判断的示例"></a>逻辑判断的示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">allTrue</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args &amp;&amp; ...);  <span class="comment">// 如果所有参数都为true，则返回true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">anyTrue</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args || ...);  <span class="comment">// 如果任意一个参数为true，则返回true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>折叠表达式大大减少了变参模板代码的复杂性，是编写简洁、高效代码的重要工具。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++中的折叠表达式（Fold Expressions）是一种简化变参模板函数编写的语法，从 C++17 开始引入。折叠表达式可以对可变参数模板进行自动折叠，从而简化代码。&lt;/p&gt;</summary>
    
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/categories/c/"/>
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/tags/c/"/>
    
    <category term="c++17" scheme="https://hmmmmmya.github.io/tags/c-17/"/>
    
    <category term="现代c++" scheme="https://hmmmmmya.github.io/tags/%E7%8E%B0%E4%BB%A3c/"/>
    
  </entry>
  
  <entry>
    <title>022_c++结构化绑定</title>
    <link href="https://hmmmmmya.github.io/2024/10/31/022_cpp%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A/"/>
    <id>https://hmmmmmya.github.io/2024/10/31/022_cpp%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A/</id>
    <published>2024-10-31T06:58:46.000Z</published>
    <updated>2024-10-31T07:10:11.427Z</updated>
    
    <content type="html"><![CDATA[<p>介绍下 c++ 的结构化绑定</p><span id="more"></span><p>结构化绑定(Structured Binding)是 C++17 引入的新特性,允许我们将结构体、数组或元组中的多个元素同时绑定到多个变量上。</p><p>以下是几个常见的使用场景:</p><ol><li>绑定 tuple:</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::tuple&lt;<span class="type">int</span>, std::string, <span class="type">double</span>&gt; tuple&#123;<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>, <span class="number">3.14</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> [id, name, value] = tuple;  <span class="comment">// 自动解包到三个变量</span></span><br></pre></td></tr></table></figure><ol start="2"><li>绑定 pair:</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt; map&#123;&#123;<span class="string">&quot;one&quot;</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [key, value] : map) &#123;  <span class="comment">// 遍历map时直接获取键值</span></span><br><span class="line">    std::cout &lt;&lt; key &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>绑定结构体:</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line">Point p&#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> [x, y] = p;  <span class="comment">// 直接获取结构体的成员</span></span><br></pre></td></tr></table></figure><ol start="4"><li>绑定数组:</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> array[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> [a, b, c] = array;  <span class="comment">// 解包固定大小的数组</span></span><br></pre></td></tr></table></figure><ol start="5"><li>在函数返回多个值时使用:</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::tuple&lt;<span class="type">bool</span>, std::string&gt; <span class="title">ValidateUser</span><span class="params">(<span class="type">const</span> std::string&amp; user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="literal">true</span>, <span class="string">&quot;验证成功&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用时</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> [success, message] = <span class="built_in">ValidateUser</span>(<span class="string">&quot;admin&quot;</span>); success) &#123;</span><br><span class="line">    std::cout &lt;&lt; message &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在之前的代码中的应用:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原来的写法</span></span><br><span class="line">std::vector&lt;std::tuple&lt;T, T, T&gt;&gt; &amp;params;</span><br><span class="line">T min = std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(params.<span class="built_in">at</span>(i));</span><br><span class="line">T max = std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(params.<span class="built_in">at</span>(i));</span><br><span class="line">std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(params.<span class="built_in">at</span>(i)) = value;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用结构化绑定的写法</span></span><br><span class="line"><span class="keyword">auto</span>&amp; [value, min, max] = params[i];  <span class="comment">// 一次性获取所有值</span></span><br></pre></td></tr></table></figure><p>优点:</p><ol><li>代码更简洁易读</li><li>避免重复访问容器元素</li><li>减少了使用 std::get 的繁琐语法</li><li>变量名更有意义,提高代码可维护性</li></ol><p>注意事项:</p><ol><li>需要 C++17 或更高版本</li><li>绑定的变量数量必须与结构中的元素数量完全匹配</li><li>使用 auto 关键字声明</li><li>可以使用引用(&amp;)来避免拷贝</li></ol><p>结构化绑定是现代 C++中非常实用的特性,能让代码更加简洁优雅。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍下 c++ 的结构化绑定&lt;/p&gt;</summary>
    
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/categories/c/"/>
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/tags/c/"/>
    
    <category term="c++17" scheme="https://hmmmmmya.github.io/tags/c-17/"/>
    
    <category term="现代c++" scheme="https://hmmmmmya.github.io/tags/%E7%8E%B0%E4%BB%A3c/"/>
    
  </entry>
  
  <entry>
    <title>021_主题皮肤推荐</title>
    <link href="https://hmmmmmya.github.io/2024/10/30/021_%E4%B8%BB%E9%A2%98%E7%9A%AE%E8%82%A4%E6%8E%A8%E8%8D%90/"/>
    <id>https://hmmmmmya.github.io/2024/10/30/021_%E4%B8%BB%E9%A2%98%E7%9A%AE%E8%82%A4%E6%8E%A8%E8%8D%90/</id>
    <published>2024-10-30T03:44:23.000Z</published>
    <updated>2024-10-30T03:49:08.494Z</updated>
    
    <content type="html"><![CDATA[<p>好用的主题皮肤推荐</p><span id="more"></span><table><thead><tr><th>工具</th><th>主题皮肤</th><th>备注</th></tr></thead><tbody><tr><td><strong>vscode</strong></td><td><em>Night Owl</em></td><td>最美观</td></tr><tr><td></td><td>One Dark Pro</td><td>雾蒙蒙</td></tr><tr><td><strong>typora</strong></td><td><em>Vue</em></td><td></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;好用的主题皮肤推荐&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>020_如何修改 Linux 栈区大小</title>
    <link href="https://hmmmmmya.github.io/2024/10/29/020_%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%20Linux%20%E6%A0%88%E5%8C%BA%E5%A4%A7%E5%B0%8F/"/>
    <id>https://hmmmmmya.github.io/2024/10/29/020_%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%20Linux%20%E6%A0%88%E5%8C%BA%E5%A4%A7%E5%B0%8F/</id>
    <published>2024-10-29T08:42:00.000Z</published>
    <updated>2024-10-29T08:42:33.731Z</updated>
    
    <content type="html"><![CDATA[<p>栈，就是那些由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区。里面的变量通常是局部变量、函数参数等。和堆相比，栈通常很小。<br>在 Linux 系统中，栈区的大小是固定的，通常为 8 MB。然而，在某些情况下，我们可能需要修改栈区的大小。本文将介绍如何修改 Linux 栈区大小。</p><span id="more"></span><h2 id="1-查看当前栈区大小"><a href="#1-查看当前栈区大小" class="headerlink" title="1. 查看当前栈区大小"></a>1. 查看当前栈区大小</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -s // 一般为8192KB, 即8MB</span><br></pre></td></tr></table></figure><p>注：线程栈大小默认为 8M，8192 KB。</p><h2 id="2-修改栈区大小"><a href="#2-修改栈区大小" class="headerlink" title="2. 修改栈区大小"></a>2. 修改栈区大小</h2><h3 id="临时修改"><a href="#临时修改" class="headerlink" title="临时修改"></a>临时修改</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -s 102400 // 改为100MB</span><br></pre></td></tr></table></figure><p>注：ulimit -s ulimited 不限制。</p><h3 id="永久修改"><a href="#永久修改" class="headerlink" title="永久修改"></a>永久修改</h3><p>有两种方法：</p><ul><li><p>方法一：可以在&#x2F;etc&#x2F;rc.local 内加入 ulimit -s 102400 则可以开机就设置栈空间大小，任何用户启动的时候都会调用</p></li><li><p>方法二：修改配置文件&#x2F;etc&#x2F;security&#x2F;limits.conf</p></li></ul><p>手动添加：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* soft stack 102400</span><br></pre></td></tr></table></figure><p>自动添加：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -ne <span class="string">&quot;* soft stack 102400\n&quot;</span> &gt;&gt; /etc/security/limits.conf</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;栈，就是那些由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区。里面的变量通常是局部变量、函数参数等。和堆相比，栈通常很小。&lt;br&gt;在 Linux 系统中，栈区的大小是固定的，通常为 8 MB。然而，在某些情况下，我们可能需要修改栈区的大小。本文将介绍如何修改 Linux 栈区大小。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://hmmmmmya.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://hmmmmmya.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>019_Linux 查看库中是否包含指定函数</title>
    <link href="https://hmmmmmya.github.io/2024/10/29/019_Linux%20%E6%9F%A5%E7%9C%8B%E5%BA%93%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E6%8C%87%E5%AE%9A%E5%87%BD%E6%95%B0/"/>
    <id>https://hmmmmmya.github.io/2024/10/29/019_Linux%20%E6%9F%A5%E7%9C%8B%E5%BA%93%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E6%8C%87%E5%AE%9A%E5%87%BD%E6%95%B0/</id>
    <published>2024-10-29T08:10:00.000Z</published>
    <updated>2024-10-29T08:40:27.196Z</updated>
    
    <content type="html"><![CDATA[<p>在 Linux 系统中，我们经常需要确认某个函数是否在特定的库文件中。以下是几种常用的查找方法。</p><span id="more"></span><h2 id="1-nm-命令（最常用）"><a href="#1-nm-命令（最常用）" class="headerlink" title="1. nm 命令（最常用）"></a>1. nm 命令（最常用）</h2><p><code>nm</code> 命令用于查看库文件中的符号表，是最直接的方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本语法</span></span><br><span class="line">nm -D /path/to/library.so | grep <span class="string">&#x27;function_name&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际示例</span></span><br><span class="line">nm -D /usr/lib/libc.so.6 | grep <span class="string">&#x27;printf&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="2-objdump-命令（详细信息）"><a href="#2-objdump-命令（详细信息）" class="headerlink" title="2. objdump 命令（详细信息）"></a>2. objdump 命令（详细信息）</h2><p><code>objdump</code> 提供了更详细的库文件信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本语法</span></span><br><span class="line">objdump -T /path/to/library.so | grep <span class="string">&#x27;function_name&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际示例</span></span><br><span class="line">objdump -T /usr/lib/libc.so.6 | grep <span class="string">&#x27;printf&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="3-readelf-命令（ELF-文件专用）"><a href="#3-readelf-命令（ELF-文件专用）" class="headerlink" title="3. readelf 命令（ELF 文件专用）"></a>3. readelf 命令（ELF 文件专用）</h2><p>专门用于分析 ELF 格式文件的工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本语法</span></span><br><span class="line">readelf -Ws /path/to/library.so | grep <span class="string">&#x27;function_name&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际示例</span></span><br><span class="line">readelf -Ws /usr/lib/libc.so.6 | grep <span class="string">&#x27;printf&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="4-批量查找方法"><a href="#4-批量查找方法" class="headerlink" title="4. 批量查找方法"></a>4. 批量查找方法</h2><h3 id="使用-find-配合-nm-命令"><a href="#使用-find-配合-nm-命令" class="headerlink" title="使用 find 配合 nm 命令"></a>使用 find 配合 nm 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在指定目录下查找所有.so文件中的特定函数</span></span><br><span class="line">find /usr/lib -name <span class="string">&quot;*.so&quot;</span> -<span class="built_in">exec</span> nm -D &#123;&#125; \; | grep <span class="string">&#x27;function_name&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="使用-grep-直接搜索"><a href="#使用-grep-直接搜索" class="headerlink" title="使用 grep 直接搜索"></a>使用 grep 直接搜索</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在库目录中搜索函数名</span></span><br><span class="line">grep -R <span class="string">&#x27;function_name&#x27;</span> /usr/lib/</span><br></pre></td></tr></table></figure><h2 id="5-依赖关系查看（ldd）"><a href="#5-依赖关系查看（ldd）" class="headerlink" title="5. 依赖关系查看（ldd）"></a>5. 依赖关系查看（ldd）</h2><p>虽然不能直接查看函数，但可以查看库的依赖关系。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看可执行文件的库依赖</span></span><br><span class="line">ldd /path/to/executable</span><br></pre></td></tr></table></figure><h2 id="常见参数说明"><a href="#常见参数说明" class="headerlink" title="常见参数说明"></a>常见参数说明</h2><table><thead><tr><th>命令</th><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>nm</td><td>-D</td><td>只显示动态符号</td></tr><tr><td>objdump</td><td>-T</td><td>显示动态符号表</td></tr><tr><td>readelf</td><td>-W</td><td>使用宽格式显示</td></tr><tr><td></td><td>-s</td><td>显示符号表</td></tr></tbody></table><h2 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h2><ol><li><strong>快速查找</strong>：优先使用 <code>nm -D</code> 命令</li><li><strong>详细分析</strong>：需要更多信息时使用 <code>objdump</code> 或 <code>readelf</code></li><li><strong>批量查找</strong>：使用 <code>find</code> 配合 <code>nm</code> 命令</li><li><strong>依赖确认</strong>：使用 <code>ldd</code> 确认库是否正确链接</li></ol><h2 id="常见问题排查"><a href="#常见问题排查" class="headerlink" title="常见问题排查"></a>常见问题排查</h2><p>如果找到函数但链接失败，请检查：</p><ul><li>库文件的链接路径是否正确</li><li>库版本是否兼容</li><li>符号修饰（symbol mangling）是否匹配</li><li>编译器选项是否正确</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 Linux 系统中，我们经常需要确认某个函数是否在特定的库文件中。以下是几种常用的查找方法。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://hmmmmmya.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://hmmmmmya.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>018_为什么我们常见的 IP 都是 192.168 开头的</title>
    <link href="https://hmmmmmya.github.io/2024/10/29/018_%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E5%B8%B8%E8%A7%81%E7%9A%84%20IP%20%E9%83%BD%E6%98%AF%20192.168%20%E5%BC%80%E5%A4%B4%E7%9A%84/"/>
    <id>https://hmmmmmya.github.io/2024/10/29/018_%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E5%B8%B8%E8%A7%81%E7%9A%84%20IP%20%E9%83%BD%E6%98%AF%20192.168%20%E5%BC%80%E5%A4%B4%E7%9A%84/</id>
    <published>2024-10-29T07:56:00.000Z</published>
    <updated>2024-10-31T04:28:37.103Z</updated>
    
    <content type="html"><![CDATA[<p>为什么我们常见的 IP 都是 192.168 开头的</p><span id="more"></span><h2 id="ip-地址划分"><a href="#ip-地址划分" class="headerlink" title="ip 地址划分"></a>ip 地址划分</h2><p>参考：<a href="https://xiaolincoding.com/network/4_ip/ip_base.html#ip-%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%86%E7%B1%BB">IP 地址的分类</a></p><p>互联网诞生之初，IP 地址显得很充裕，于是计算机科学家们设计了分类地址。</p><p>IP 地址分类成了 5 种类型，分别是 A 类、B 类、C 类、D 类、E 类。</p><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20241029151149.png" alt="IP 地址的分类"></p><p>上图中黄色部分为分类号，用以区分 IP 地址类别。</p><h2 id="私网地址划分"><a href="#私网地址划分" class="headerlink" title="私网地址划分"></a>私网地址划分</h2><blockquote><p>10.0.0.0–10.255.255.255</p><p>172.16.0.0–172.31.255.255</p><p>192.168.0.0–192.168.255.255</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/image-20241029144309499.png" alt="私网地址"></p><p>除了这三个 ip 地址段为私有 ip 地址外，其它的都为公网 ip。</p><p>这些地址已被声明私有化，任何内网中的设备可以任意使用这些地址，但是在这三个范围内的 IP 地址不允许出现在 Internet（外网）上。所以我们平台在内部组网时用的比较多，比如监控项目与公司内部电脑 ip 设置，用的多的就是 192.168.xx。</p><p>通常情况下，按照需要容纳的主机数选择私有地址段。家庭网络规模比较小，一个 C 类地址，192.168.1.x 可以容纳 254 个终端，足够使用。</p><p>学校或者大型企业可能使用 B 类甚至 A 类作为内部网络的地址段。比如手机上网很可能获取的也是一个 10 开头的内网地址，而不是公网地址。</p><h2 id="NAT-地址转换"><a href="#NAT-地址转换" class="headerlink" title="NAT 地址转换"></a>NAT 地址转换</h2><p>私网地址只能在局域网中使用，不同的局域网可以使用同样的私网地址，私网地址是不能出现在互联网上的。那么私网地址如何访问互联网呢？这就需要用到 NAT 地址转换，将内网地址映射到外网地址。</p><p>而<strong>NAT 地址转换</strong>它实现内网的 IP 地址与公网的地址之间的相互转换，将大量的内网 IP 地址转换为一个或少量的公网 IP 地址，减少对公网 IP 地址的占用。</p><p>家庭网络普遍使用端口映射的方式，NAT 的核心是一张映射表（源 IP 地址，源端口，目的 IP 地址，目的端口），将内网源 IP 地址和端口映射到同一个公网地址的不同端口，如下图所示。</p><table><thead><tr><th>内网 IP（源地址:端口）</th><th>外网 IP（目标地址:端口）</th></tr></thead><tbody><tr><td>192.168.1.55:5566</td><td>219.152.168.222:9200</td></tr><tr><td>192.168.1.59:80</td><td>219.152.168.222:9201</td></tr><tr><td>192.168.1.59:4465</td><td>219.152.168.222:9202</td></tr></tbody></table><p>总之，家庭网络由于网络规模比较小，通常使用了 192.168 开头的私网地址，光猫拨号获取了一个公网地址（或者运营商私网地址），通过 NAT 方式的映射到这个公网地址的不同端口，访问互联网。主要注意的 NAT 模式和路由模式是不同的。</p><h2 id="无分类地址-CIDR"><a href="#无分类地址-CIDR" class="headerlink" title="无分类地址 CIDR"></a>无分类地址 CIDR</h2><p>正因为 IP 分类存在许多缺点，所以后面提出了无分类地址的方案，即 CIDR。</p><p>这种方式不再有分类地址的概念，32 比特的 IP 地址被划分为两部分，前面是网络号，后面是主机号。</p><p>怎么划分网络号和主机号的呢？</p><p>表示形式 a.b.c.d&#x2F;x，其中 &#x2F;x 表示前 x 位属于网络号， x 的范围是 0 ~ 32，这就使得 IP 地址更加具有灵活性。</p><p>比如 10.100.122.2&#x2F;24，这种地址表示形式就是 CIDR，&#x2F;24 表示前 24 位是网络号，剩余的 8 位是主机号。</p><h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><p>子网掩码和 CIDR 是配套使用的，CIDR 表示网络号，子网掩码表示主机号。掩码的意思就是掩盖掉主机号，剩余的就是网络号。</p><p>子网掩码和 IP 地址一样，也是 32 比特，左边是网络号，右边是主机号。</p><h2 id="网络号和主机号"><a href="#网络号和主机号" class="headerlink" title="网络号和主机号"></a>网络号和主机号</h2><p>网络号和主机号在 IP 地址中有着各自重要的作用，帮助计算机网络有效地传输数据和管理地址。具体来说：</p><h3 id="网络号-Network-Part"><a href="#网络号-Network-Part" class="headerlink" title="网络号 (Network Part)"></a>网络号 (Network Part)</h3><ul><li><p>定义：网络号是 IP 地址的前一部分，用于标识一个特定的网络。</p></li><li><p>作用：</p><ul><li><p>路由：网络设备（如路由器）利用网络号将数据包发送到正确的子网或网络。只需要检查数据包的网络号，就可以决定将其转发到哪个子网。</p></li><li><p>网络管理：网络号有助于网络管理员管理和组织不同的子网。通过网络号，管理员可以轻松地分配和控制 IP 地址资源。</p></li></ul></li></ul><h3 id="主机号-Host-Part"><a href="#主机号-Host-Part" class="headerlink" title="主机号 (Host Part)"></a>主机号 (Host Part)</h3><ul><li><p>定义：主机号是 IP 地址的后一部分，用于标识网络中的特定设备或节点。</p></li><li><p>作用：</p><ul><li><p>设备标识：主机号唯一标识网络中的每一个设备，确保数据包能准确地到达目标设备。</p></li><li><p>地址分配：在同一子网内，主机号确保每一个设备都有一个独一无二的地址，以避免地址冲突。</p></li></ul></li></ul><p>例如：<br>对于 IP 地址 192.168.1.1 和 子网掩码 255.255.255.0（C 类地址）：</p><ul><li><p>网络号：192.168.1（前 24 位）</p></li><li><p>主机号：1（后 8 位）</p></li></ul><p>这个地址划分方式确保了不同网络可以通过网络号来区分，同时在同一网络内的每个设备通过主机号来区分，从而实现高效的网络管理和数据传输。</p><h2 id="192-168"><a href="#192-168" class="headerlink" title="192.168"></a>192.168</h2><p>192.168.x.x 是 ipv4 的 c 类地址划分的一部分</p><p>C 类网络地址划分: 110 开头，21 位网络号，8 位主机号。C 类网络地址的 192.168 号段才是私有地址，其他号段是公有地址。</p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/image-20241029144154815.png" alt="image-20241029144154815" style="zoom: 67%;" /><p>C 类网络中，192.168 划分为私有地址，从 192.168.0.0 到 192.168.255.255。</p><h2 id="192-168-11-63"><a href="#192-168-11-63" class="headerlink" title="192.168.11.63"></a>192.168.11.63</h2><p>inet: 192.168.11.63<br>netmask: 255.255.248.0&#x2F;21</p><p>192.168.11.63 是 C 类网络地址，192.168 是网络号，11 是子网号，63 是主机号。</p><p>192.168.11.63 的二进制表示：</p><p>11000000.10101000.00001011.01111111</p><p>网络号：11000000.10101000.00001, 21 位网络号, 用于标识同一子网。</p><p>主机号：011 11111, 8 位主机号, 用于标识同一子网内的不同设备。</p><p>255.255.248.0 的二进制表示：</p><p>11111111.11111111.11111000.00000000</p><h3 id="同一子网"><a href="#同一子网" class="headerlink" title="同一子网"></a>同一子网</h3><p>从 11000000.10101000.00001000.00000000 到 11000000.10101000.00001111.11111111</p><p>即: 192.168.8.0 到 192.168.15.255</p><p>可用设备数: 2^8 - 2 &#x3D; 254</p><p>特殊地址:</p><ul><li><p>192.168.8.0: 网络地址, 不能分配给设备, 用于标识子网</p></li><li><p>192.168.15.255: 广播地址</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;为什么我们常见的 IP 都是 192.168 开头的&lt;/p&gt;</summary>
    
    
    
    <category term="网络" scheme="https://hmmmmmya.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络" scheme="https://hmmmmmya.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>017_开发工具推荐</title>
    <link href="https://hmmmmmya.github.io/2024/10/23/017_%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/"/>
    <id>https://hmmmmmya.github.io/2024/10/23/017_%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/</id>
    <published>2024-10-23T06:30:00.000Z</published>
    <updated>2024-10-24T01:33:48.744Z</updated>
    
    <content type="html"><![CDATA[<p>开发工具推荐</p><span id="more"></span><h3 id="开发工具推荐"><a href="#开发工具推荐" class="headerlink" title="开发工具推荐"></a>开发工具推荐</h3><table><thead><tr><th>平台</th><th>工具名称</th><th>功能描述</th><th>网址</th></tr></thead><tbody><tr><td><strong>IDE</strong></td><td>cursor</td><td>内置大模型, 完美兼容 vscode</td><td></td></tr><tr><td></td><td>vscode</td><td>插件丰富</td><td></td></tr><tr><td><strong>Git</strong></td><td>git</td><td>版本控制</td><td></td></tr><tr><td></td><td>Github Desktop</td><td>github 桌面客户端</td><td></td></tr><tr><td><strong>比较</strong></td><td>Beyond Compare</td><td>文件对比</td><td></td></tr><tr><td><strong>远程</strong></td><td>MobaXterm</td><td>远程连接</td><td></td></tr><tr><td><strong>数据库</strong></td><td>Navicat Premium Lite</td><td>数据库管理</td><td><a href="https://www.navicat.com.cn/download/navicat-premium-lite">https://www.navicat.com.cn/download/navicat-premium-lite</a></td></tr><tr><td><strong>容器</strong></td><td>Docker Desktop</td><td>容器化</td><td></td></tr><tr><td><strong>代理</strong></td><td>clash</td><td>代理工具</td><td></td></tr><tr><td><strong>抓包</strong></td><td>wireshark</td><td>抓包工具</td><td></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;开发工具推荐&lt;/p&gt;</summary>
    
    
    
    <category term="工具" scheme="https://hmmmmmya.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="工具" scheme="https://hmmmmmya.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>016_笔记工具推荐</title>
    <link href="https://hmmmmmya.github.io/2024/10/23/016_%E7%AC%94%E8%AE%B0%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/"/>
    <id>https://hmmmmmya.github.io/2024/10/23/016_%E7%AC%94%E8%AE%B0%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/</id>
    <published>2024-10-23T04:00:00.000Z</published>
    <updated>2024-10-25T01:29:42.320Z</updated>
    
    <content type="html"><![CDATA[<p>笔记工具推荐</p><span id="more"></span><h3 id="笔记工具推荐"><a href="#笔记工具推荐" class="headerlink" title="笔记工具推荐"></a>笔记工具推荐</h3><table><thead><tr><th>平台</th><th>工具名称</th><th>功能描述</th></tr></thead><tbody><tr><td>windows</td><td>vscode</td><td>编辑功能强大, 代码管控</td></tr><tr><td>windows</td><td>typora</td><td>界面优雅, pin 目录后可以快速切换</td></tr><tr><td>windows</td><td><del>vnote</del></td><td>快速切换, 快速修改, 不够优雅, 配置麻烦</td></tr><tr><td>windows</td><td>heynote</td><td>程序员笔记</td></tr><tr><td>windows</td><td>navicat</td><td>数据库</td></tr><tr><td>跨平台</td><td>wps</td><td>表格</td></tr><tr><td>跨平台</td><td>flomo</td><td>简短, 方便同步</td></tr><tr><td>跨平台</td><td>幕布</td><td>思维导图</td></tr><tr><td>跨平台</td><td>github</td><td>笔记托管</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;笔记工具推荐&lt;/p&gt;</summary>
    
    
    
    <category term="工具" scheme="https://hmmmmmya.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="工具" scheme="https://hmmmmmya.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>015_windows实用工具推荐</title>
    <link href="https://hmmmmmya.github.io/2024/10/23/015_windows%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/"/>
    <id>https://hmmmmmya.github.io/2024/10/23/015_windows%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/</id>
    <published>2024-10-23T02:09:14.000Z</published>
    <updated>2024-10-24T01:32:46.825Z</updated>
    
    <content type="html"><![CDATA[<p>windows 实用工具推荐</p><span id="more"></span><h3 id="Windows-实用工具推荐"><a href="#Windows-实用工具推荐" class="headerlink" title="Windows 实用工具推荐"></a>Windows 实用工具推荐</h3><table><thead><tr><th>分类</th><th>工具名称</th><th>功能描述</th><th>网址</th></tr></thead><tbody><tr><td>截图工具</td><td>Snipaste</td><td>支持截图后贴图，贴图后可继续截图</td><td><a href="https://zh.snipaste.com/download.html">https://zh.snipaste.com/download.html</a></td></tr><tr><td>文件管理</td><td>Everything</td><td>快速文件搜索工具，比 Windows 自带搜索更快</td><td><a href="https://www.voidtools.com/zh-cn/downloads/">https://www.voidtools.com/zh-cn/downloads/</a></td></tr><tr><td>系统维护</td><td>Geek Uninstaller</td><td>卸载软件工具，可彻底清理残留文件</td><td></td></tr><tr><td>桌面管理</td><td>DeskPins</td><td>桌面置顶工具，可置顶任何窗口</td><td></td></tr><tr><td>翻译工具</td><td>网易有道翻译</td><td>多语言翻译工具</td><td></td></tr><tr><td>网盘</td><td>百度网盘</td><td>文件存储与下载</td><td></td></tr><tr><td>聊天工具</td><td>CleanMyWechat</td><td>微信清理工具</td><td></td></tr></tbody></table><p>这些工具可以大大提高 Windows 系统的使用效率和体验。根据个人需求，选择合适的工具来优化您的工作流程。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;windows 实用工具推荐&lt;/p&gt;</summary>
    
    
    
    <category term="工具" scheme="https://hmmmmmya.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="工具" scheme="https://hmmmmmya.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>014_rss订阅</title>
    <link href="https://hmmmmmya.github.io/2024/10/12/014_rss%E8%AE%A2%E9%98%85%20copy/"/>
    <id>https://hmmmmmya.github.io/2024/10/12/014_rss%E8%AE%A2%E9%98%85%20copy/</id>
    <published>2024-10-12T02:09:14.000Z</published>
    <updated>2024-10-23T06:56:10.303Z</updated>
    
    <content type="html"><![CDATA[<p>rss 可以绕过算法推荐, 并且不遗漏地接收关注的动态, 重新成为订阅的主人</p><span id="more"></span><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ol><li><a href="https://www.inoreader.com/">Inoreader</a></li><li><a href="https://github.com/DIYgod/RSSHub">RssHub</a></li><li><a href="https://vercel.com/">Vercel</a></li></ol><h3 id="Inoreader"><a href="#Inoreader" class="headerlink" title="Inoreader"></a>Inoreader</h3><p>多端同步的 rss 阅读器, 亲测是最方便, 最容易同步, 加载源最容易成功的 rss 服务器, 页面也很高大上</p><p>包含了网页端、浏览器插件、app</p><h3 id="RssHub"><a href="#RssHub" class="headerlink" title="RssHub"></a>RssHub</h3><p>集成了最新的 rss 订阅源, 号称是让每一个网站都能做成 rss 订阅。当前绝大部分的网站都不主动公开 rss 订阅的方式了, RssHub 可以弥补这一点。</p><h3 id="Vercel"><a href="#Vercel" class="headerlink" title="Vercel"></a>Vercel</h3><p>很多网站对爬虫源进行了屏蔽, RssHub 也是一种网络爬虫的方式。将 RssHub 部署到自己的服务器, 有了新的域名, 便可以绕过这一层。Vercel 可以部署 RssHub 项目, 从而省去了购买服务器的花销。</p><p>Vercel 部署 RssHub 的教程可以参考: <a href="https://cloud.tencent.com/developer/article/2432561">手把手教你用 Vercel 免费部署 RSSHub</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;rss 可以绕过算法推荐, 并且不遗漏地接收关注的动态, 重新成为订阅的主人&lt;/p&gt;</summary>
    
    
    
    
    <category term="rss" scheme="https://hmmmmmya.github.io/tags/rss/"/>
    
  </entry>
  
  <entry>
    <title>013_内网穿透工具</title>
    <link href="https://hmmmmmya.github.io/2024/09/21/013_%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7/"/>
    <id>https://hmmmmmya.github.io/2024/09/21/013_%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7/</id>
    <published>2024-09-21T02:24:14.000Z</published>
    <updated>2024-10-29T04:05:24.333Z</updated>
    
    <content type="html"><![CDATA[<p>localtunnel 和 Cloudflare Tunnels 都是内网穿透工具，可以方便快捷的将本地 Localhost 暴露给全世界，无需修改 DNS 和防火墙设置</p><span id="more"></span><h2 id="localtunnel"><a href="#localtunnel" class="headerlink" title="localtunnel"></a>localtunnel</h2><p>localtunnel 是一款基于 node.js 的内网穿透工具，非常流行，可以方便快捷的将本地 Localhost 暴露给全世界，无需修改 DNS 和防火墙设置</p><p>github 地址: <code>https://github.com/localtunnel/localtunnel</code></p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><ol><li><p>安装: <code>npm install -g localtunnel</code></p></li><li><p>绑定端口: <code>lt --port 8000</code>, 绑定要访问内网服务的端口, 即本地访问该服务的端口</p></li><li><p>公网 ip:之后会生成一个 https 的公网 ip 地址, 通过该地址可以访问内网</p></li><li><p>访问密码: 本地访问该 ip, 点击查看密码, 即可看到。从外网访问 ip，并输出密码即可</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240921095753.png" alt="获取并输入密码"></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol><li>服务关闭后, 外网不可访问, 再次开启后会分配新的 ip</li></ol><h2 id="Cloudflare-Tunnels"><a href="#Cloudflare-Tunnels" class="headerlink" title="Cloudflare Tunnels"></a>Cloudflare Tunnels</h2><p>Tunnels：如果你想在外网访问家里的设备，又很难申请到公网 IP，就可以使用 Cloudflare Tunnels 实现的免费内网穿透服务，这种方案配置简单，无数量限制、无流量限制</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;localtunnel 和 Cloudflare Tunnels 都是内网穿透工具，可以方便快捷的将本地 Localhost 暴露给全世界，无需修改 DNS 和防火墙设置&lt;/p&gt;</summary>
    
    
    
    <category term="网络" scheme="https://hmmmmmya.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络" scheme="https://hmmmmmya.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>012_修改wsl环境下的docker container 端口</title>
    <link href="https://hmmmmmya.github.io/2024/09/19/012_%E4%BF%AE%E6%94%B9wsl%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84docker%20container%20%E7%AB%AF%E5%8F%A3/"/>
    <id>https://hmmmmmya.github.io/2024/09/19/012_%E4%BF%AE%E6%94%B9wsl%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84docker%20container%20%E7%AB%AF%E5%8F%A3/</id>
    <published>2024-09-19T01:52:12.000Z</published>
    <updated>2024-10-09T02:01:16.488Z</updated>
    
    <content type="html"><![CDATA[<p>wsl 下, 修改已创建容器的端口</p><p>工具: wsl, docker</p><span id="more"></span><p>路径: <code>\\wsl.localhost\docker-desktop-data\data\docker\containers\</code></p><p>容器文件名参考 <code>docker desktop</code> 的容器名下的序列号</p><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240919100031.png" alt="容器文件名"></p><p>修改文件: <code>hostconfig.json</code> 中的 <code>PortBindings</code> 的 <code>HostPort</code></p><p>重启 <code>docker desktop</code>, 注意需要退出后再开启, 不能仅 restart docker, 否则修改被抹除</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;wsl 下, 修改已创建容器的端口&lt;/p&gt;
&lt;p&gt;工具: wsl, docker&lt;/p&gt;</summary>
    
    
    
    <category term="docker" scheme="https://hmmmmmya.github.io/categories/docker/"/>
    
    
    <category term="docker" scheme="https://hmmmmmya.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>011_Linux配置依赖环境</title>
    <link href="https://hmmmmmya.github.io/2024/06/25/011_Linux%E9%85%8D%E7%BD%AE%E4%BE%9D%E8%B5%96%E7%8E%AF%E5%A2%83/"/>
    <id>https://hmmmmmya.github.io/2024/06/25/011_Linux%E9%85%8D%E7%BD%AE%E4%BE%9D%E8%B5%96%E7%8E%AF%E5%A2%83/</id>
    <published>2024-06-25T03:47:32.000Z</published>
    <updated>2024-10-29T08:40:39.540Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 依赖各种库，有的是项目文件夹 lib 里面已经有了，有的需要安装。本文介绍了在 WSL2 编译一个项目遇到的环境问题。在一天半的时间尝试下，终于解决了，记录下解决的过程。</p><span id="more"></span><h2 id="配置-Linux-依赖"><a href="#配置-Linux-依赖" class="headerlink" title="配置 Linux 依赖"></a>配置 Linux 依赖</h2><h3 id="查找库或依赖"><a href="#查找库或依赖" class="headerlink" title="查找库或依赖"></a>查找库或依赖</h3><ol><li><p><strong>使用包管理工具</strong>：</p><ul><li><p>在 Debian 或 Ubuntu 系统上，可以使用<code>apt-cache search</code>命令查找库。例如，要查找包含“mat”关键字的库：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-cache search mat</span><br></pre></td></tr></table></figure></li><li><p>在 CentOS 或 Red Hat 系统上，可以使用<code>yum search</code>命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum search mat</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>使用<code>ldconfig</code>命令</strong>：</p><ul><li><p><code>ldconfig</code>命令用于配置和管理共享库的符号链接和缓存。</p></li><li><p>可以使用<code>ldconfig -p | grep libmat</code>命令查看系统中已知的库：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldconfig -p | grep libmat</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>手动查找</strong>：</p><ul><li><p>使用<code>find</code>或<code>locate</code>命令在系统中搜索特定的库文件。例如，查找<code>libmat.so</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name libmat.so 2&gt;/dev/null</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate libmat</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="设置路径"><a href="#设置路径" class="headerlink" title="设置路径"></a>设置路径</h3><ol><li><p><strong>编译时设置库路径</strong>：</p><ul><li><p>使用<code>-L</code>选项指定库文件所在的目录。例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o your_program your_program.c -L/path/to/library -lmat</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>运行时设置库路径</strong>：</p><ul><li><p>设置<code>LD_LIBRARY_PATH</code>环境变量以包括库文件所在的目录。例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/path/to/library:<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure></li><li><p>将上述命令添加到<code>.bashrc</code>或<code>.bash_profile</code>文件中以使其在每次终端启动时生效：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export LD_LIBRARY_PATH=/path/to/library:$LD_LIBRARY_PATH&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>使用<code>ldconfig</code>配置共享库</strong>：</p><ul><li><p>将库文件路径添加到系统的共享库配置中。编辑或创建文件<code>/etc/ld.so.conf.d/custom_libs.conf</code>，添加库路径：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/path/to/library</span><br></pre></td></tr></table></figure></li><li><p>然后运行<code>ldconfig</code>命令更新缓存：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>假设你在<code>/home/user/libs</code>目录下有<code>libmat.so</code>和<code>libmx.so</code>库文件，并且需要在编译和运行时使用这些库。</p><ol><li><p><strong>编译时设置路径</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o my_program my_program.c -L/home/user/libs -lmat -lmx</span><br></pre></td></tr></table></figure></li><li><p><strong>运行时设置路径</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/home/user/libs:<span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line">./my_program</span><br></pre></td></tr></table></figure></li><li><p><strong>永久设置路径</strong>：<br>编辑<code>~/.bashrc</code>文件，添加以下行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/home/user/libs:<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure><p>然后运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure></li></ol><p>通过以上步骤，你可以查找和配置所需的库路径，确保程序能够正确链接和运行。</p><h2 id="安装的库版本不匹配"><a href="#安装的库版本不匹配" class="headerlink" title="安装的库版本不匹配"></a>安装的库版本不匹配</h2><p>根据您提供的信息，链接器无法找到<code>libjsoncpp.so.1</code>，而是找到了其他版本的<code>libjsoncpp.so</code>。这是因为系统上安装的<code>libjsoncpp</code>库版本不匹配。您可以通过以下步骤解决这个问题：</p><h3 id="解决方案-1：使用-rpath或-rpath-link"><a href="#解决方案-1：使用-rpath或-rpath-link" class="headerlink" title="解决方案 1：使用-rpath或-rpath-link"></a>解决方案 1：使用<code>-rpath</code>或<code>-rpath-link</code></h3><p>您可以在链接时使用<code>-rpath</code>或<code>-rpath-link</code>选项来指定库的路径。</p><p>假设您的库文件在<code>/usr/lib/x86_64-Linux-gnu</code>目录下，可以这样做：</p><ol><li><p>修改您的编译命令以包含<code>-Wl,-rpath,/usr/lib/x86_64-Linux-gnu</code></p></li><li><p>或者在 CMakeLists.txt 文件中设置链接器路径：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_INSTALL_RPATH <span class="string">&quot;/usr/lib/x86_64-Linux-gnu&quot;</span>)</span><br></pre></td></tr></table></figure></li></ol><h3 id="解决方案-2：创建符号链接"><a href="#解决方案-2：创建符号链接" class="headerlink" title="解决方案 2：创建符号链接"></a>解决方案 2：创建符号链接</h3><p>如果您需要的<code>libjsoncpp.so.1</code>确实存在于不同的位置，可以创建一个符号链接以便系统能够找到它。</p><ol><li><p>创建符号链接：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">ln</span> -s /usr/lib/x86_64-Linux-gnu/libjsoncpp.so.1.9.5 /usr/lib/x86_64-Linux-gnu/libjsoncpp.so.1</span><br></pre></td></tr></table></figure><p>如果使用<code>locate</code>定位不到新建的包, 更新 locate 数据库运行以下命令来更新 locate 数据库：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo updatedb</span><br></pre></td></tr></table></figure><p>然后再次运行 locate 命令</p></li></ol><h3 id="解决方案-3：安装正确版本的库"><a href="#解决方案-3：安装正确版本的库" class="headerlink" title="解决方案 3：安装正确版本的库"></a>解决方案 3：安装正确版本的库</h3><p>如果库的版本不匹配，您可以尝试安装正确版本的<code>libjsoncpp</code>。</p><ol><li><p>更新包管理器并安装正确的版本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install libjsoncpp1</span><br></pre></td></tr></table></figure></li></ol><h3 id="解决方案-4：指定库路径"><a href="#解决方案-4：指定库路径" class="headerlink" title="解决方案 4：指定库路径"></a>解决方案 4：指定库路径</h3><p>确保在链接器中指定正确的库路径。在编译时添加正确的路径：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o your_program your_program.cpp -L/usr/lib/x86_64-Linux-gnu -ljsoncpp</span><br></pre></td></tr></table></figure><h3 id="解决方案-5：环境变量"><a href="#解决方案-5：环境变量" class="headerlink" title="解决方案 5：环境变量"></a>解决方案 5：环境变量</h3><p>通过设置环境变量<code>LD_LIBRARY_PATH</code>来指定库的路径：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/usr/lib/x86_64-Linux-gnu:<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure><p>将上述命令添加到<code>.bashrc</code>文件中，以便每次启动终端时都生效：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export LD_LIBRARY_PATH=/usr/lib/x86_64-Linux-gnu:$LD_LIBRARY_PATH&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><p>通过这些步骤，您应该能够解决链接器找不到<code>libjsoncpp.so.1</code>的问题并成功编译您的程序。</p><h2 id="Q-A"><a href="#Q-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ol><li><p>shell 脚本文件没有可执行权限</p><p>matlab.sh 负责将 matlab 所用的库拷贝到&#x2F;build&#x2F;lib 文件夹, 这里发现 matlab.sh 并没有执行, 增加可执行权限后正常执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@DESKTOP-S5NII96:/home/guo/code/WT328/api<span class="comment"># ./matlab.sh</span></span><br><span class="line">bash: ./matlab.sh: Permission denied</span><br></pre></td></tr></table></figure></li><li><p>安装的软件版本不匹配</p><p>手动复制一份并重命名为所需软件(不行)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> /usr/lib/x86_64-Linux-gnu/libjsoncpp.so.1.9.5 /usr/lib/x86_64-Linux-gnu/libjsoncpp.so.1</span><br></pre></td></tr></table></figure><p>增加软链接(手动增加软连接无效)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@DESKTOP-S5NII96:/home/guo/code/WT328/source<span class="comment"># ls -l /usr/lib/x86_64-Linux-gnu/libjson*</span></span><br><span class="line">lrwxrwxrwx 1 root root     18 Aug 24  2023 /usr/lib/x86_64-Linux-gnu/libjson-c.so.5 -&gt; libjson-c.so.5.1.0</span><br><span class="line">-rw-r--r-- 1 root root  72080 Aug 24  2023 /usr/lib/x86_64-Linux-gnu/libjson-c.so.5.1.0</span><br><span class="line">lrwxrwxrwx 1 root root     16 Jan 30  2022 /usr/lib/x86_64-Linux-gnu/libjsoncpp.so -&gt; libjsoncpp.so.25</span><br><span class="line">-rwxrwxrwx 1 root root 215792 Jun 24 15:57 /usr/lib/x86_64-Linux-gnu/libjsoncpp.so.1</span><br><span class="line">-rw-r--r-- 1 root root 215792 Jan 30  2022 /usr/lib/x86_64-Linux-gnu/libjsoncpp.so.1.9.5</span><br><span class="line">lrwxrwxrwx 1 root root     19 Jan 30  2022 /usr/lib/x86_64-Linux-gnu/libjsoncpp.so.25 -&gt; libjsoncpp.so.1.9.5</span><br></pre></td></tr></table></figure><p>检查报错地方的依赖，能找到啊！！！怎么还报错呢</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@DESKTOP-S5NII96:/home/guo/code/WT328/source<span class="comment"># ldd /home/guo/code/WT328/source/../extlib/lib/libwt-calibration.so</span></span><br><span class="line"></span><br><span class="line">Linux-vdso.so.1 (0x00007fffab961000)</span><br><span class="line">libjsoncpp.so.1 =&gt; /lib/x86_64-Linux-gnu/libjsoncpp.so.1 (0x00007f466786a000)</span><br><span class="line">libstdc++.so.6 =&gt; /lib/x86_64-Linux-gnu/libstdc++.so.6 (0x00007f466763e000)</span><br><span class="line">libgcc_s.so.1 =&gt; /lib/x86_64-Linux-gnu/libgcc_s.so.1 (0x00007f466761e000)</span><br><span class="line">libpthread.so.0 =&gt; /lib/x86_64-Linux-gnu/libpthread.so.0 (0x00007f4667619000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-Linux-gnu/libc.so.6 (0x00007f46673f0000)</span><br><span class="line">libm.so.6 =&gt; /lib/x86_64-Linux-gnu/libm.so.6 (0x00007f4667309000)</span><br><span class="line">/lib64/ld-Linux-x86-64.so.2 (0x00007f4667922000)</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@DESKTOP-S5NII96:/home/guo/code/WT328/source<span class="comment"># locate libjsoncpp</span></span><br><span class="line"></span><br><span class="line">/usr/lib/x86_64-Linux-gnu/libjsoncpp.so</span><br><span class="line">/usr/lib/x86_64-Linux-gnu/libjsoncpp.so.1</span><br><span class="line">/usr/lib/x86_64-Linux-gnu/libjsoncpp.so.1.9.5</span><br><span class="line">/usr/lib/x86_64-Linux-gnu/libjsoncpp.so.25</span><br><span class="line">/usr/share/doc/libjsoncpp-dev</span><br><span class="line">/usr/share/doc/libjsoncpp25</span><br><span class="line">/usr/share/doc/libjsoncpp-dev/changelog.Debian.gz</span><br><span class="line">/usr/share/doc/libjsoncpp-dev/copyright</span><br><span class="line">/usr/share/doc/libjsoncpp25/README.Debian</span><br><span class="line">/usr/share/doc/libjsoncpp25/README.md</span><br><span class="line">/usr/share/doc/libjsoncpp25/changelog.Debian.gz</span><br><span class="line">/usr/share/doc/libjsoncpp25/copyright</span><br><span class="line">/var/lib/dpkg/info/libjsoncpp-dev:amd64.list</span><br><span class="line">/var/lib/dpkg/info/libjsoncpp-dev:amd64.md5sums</span><br><span class="line">/var/lib/dpkg/info/libjsoncpp25:amd64.list</span><br><span class="line">/var/lib/dpkg/info/libjsoncpp25:amd64.md5sums</span><br><span class="line">/var/lib/dpkg/info/libjsoncpp25:amd64.shlibs</span><br><span class="line">/var/lib/dpkg/info/libjsoncpp25:amd64.triggers</span><br><span class="line">root@DESKTOP-S5NII96:/home/guo/code/WT328/source<span class="comment"># ^C</span></span><br><span class="line">root@DESKTOP-S5NII96:/home/guo/code/WT328/source<span class="comment">#</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ld: /home/guo/code/WT328/source/../extlib/lib/libwt-calibration.so: undefined reference to  Json::Value::operator=(Json::Value)</span><br><span class="line">collect2: error: ld returned 1 <span class="built_in">exit</span> status</span><br><span class="line">make[1]: ***[/home/guo/code/WT328/source/base.mk:15: /home/guo/code/WT328/source/bin/WT-Manager] Error 1</span><br><span class="line">make[1]: Leaving directory /home/guo/code/WT328/source/manager</span><br><span class="line">make:*** [Makefile:85: all] Error 1</span><br></pre></td></tr></table></figure><p>可能是库有问题，这个版本的没有<code>Json::Value::operator=(Json::Value)</code></p><p>明天试试装 1.7.4 的版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 卸载1.9.5版本</span><br><span class="line">dpkg --list</span><br><span class="line"></span><br><span class="line">sudo apt-get remove software</span><br><span class="line"></span><br><span class="line">// qinghua下载指定版本deb包</span><br><span class="line">// libjsoncpp1_1.7.4-3_amd64.deb 和 libjsoncpp-dev_1.7.4-3_amd64.deb</span><br><span class="line"></span><br><span class="line">// 安装</span><br><span class="line">root@DESKTOP-S5NII96:/home/guo/code<span class="comment"># dpkg -i libjsoncpp1_1.7.4-3_amd64.deb</span></span><br><span class="line"></span><br><span class="line">Selecting previously unselected package libjsoncpp1:amd64.</span><br><span class="line">(Reading database ... 49184 files and directories currently installed.)</span><br><span class="line">Preparing to unpack libjsoncpp1_1.7.4-3_amd64.deb ...</span><br><span class="line">Unpacking libjsoncpp1:amd64 (1.7.4-3) ...</span><br><span class="line">Setting up libjsoncpp1:amd64 (1.7.4-3) ...</span><br><span class="line">Processing triggers <span class="keyword">for</span> libc-bin (2.35-0ubuntu3.4) ...</span><br><span class="line">root@DESKTOP-S5NII96:/home/guo/code<span class="comment"># dpkg -i libjsoncpp-dev_1.7.4-3_amd64.deb</span></span><br><span class="line">Selecting previously unselected package libjsoncpp-dev:amd64.</span><br><span class="line">(Reading database ... 49193 files and directories currently installed.)</span><br><span class="line">Preparing to unpack libjsoncpp-dev_1.7.4-3_amd64.deb ...</span><br><span class="line">Unpacking libjsoncpp-dev:amd64 (1.7.4-3) ...</span><br><span class="line">Setting up libjsoncpp-dev:amd64 (1.7.4-3) ...</span><br><span class="line"></span><br><span class="line">// 查看效果</span><br><span class="line">root@DESKTOP-S5NII96:/usr/lib/x86_64-Linux-gnu<span class="comment"># ls -l |grep libjsonc</span></span><br><span class="line"></span><br><span class="line">-rw-r--r--  1 root root   372584 Aug 23  2016 libjsoncpp.a</span><br><span class="line">lrwxrwxrwx  1 root root       15 Aug 23  2016 libjsoncpp.so -&gt; libjsoncpp.so.1</span><br><span class="line">lrwxrwxrwx  1 root root       19 Aug 23  2016 libjsoncpp.so.1 -&gt; libjsoncpp.so.1.7.4</span><br><span class="line">-rw-r--r--  1 root root   203464 Aug 23  2016 libjsoncpp.so.1.7.4</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 编译服务器里面的依赖</span><br><span class="line">root@wt400:/home/j00503/Code/WT328/source/bin<span class="comment"># ldd libgeneral.so</span></span><br><span class="line"></span><br><span class="line">Linux-vdso.so.1 (0x00007ffe8c14c000)</span><br><span class="line">libjsoncpp.so.1 =&gt; /lib/x86_64-Linux-gnu/libjsoncpp.so.1 (0x00007f7cfb129000)</span><br><span class="line">libwt-calibration.so =&gt; not found</span><br><span class="line">libwt-crypto.so =&gt; not found</span><br><span class="line">libft4222.so =&gt; not found</span><br><span class="line">libAlg3gppVsa.so =&gt; not found</span><br><span class="line">libAlg3gppVsg.so =&gt; not found</span><br><span class="line">libAlgVsa.so =&gt; not found</span><br><span class="line">libAlgVsaGle.so =&gt; not found</span><br><span class="line">libAlgVsaSlb.so =&gt; not found</span><br><span class="line">libAlgVsaWifi11az.so =&gt; not found</span><br><span class="line">libAlgVsg.so =&gt; not found</span><br><span class="line">libAlgVsgGle.so =&gt; not found</span><br><span class="line">libAlgVsgSlb.so =&gt; not found</span><br><span class="line">libAlgVsgWifi11ah.so =&gt; not found</span><br><span class="line">libWT-Debug-Mem.so =&gt; not found</span><br><span class="line">libsqlite3.so.0 =&gt; /lib/x86_64-Linux-gnu/libsqlite3.so.0 (0x00007f7cfaffc000)</span><br><span class="line">libstdc++.so.6 =&gt; /lib/x86_64-Linux-gnu/libstdc++.so.6 (0x00007f7cfae1a000)</span><br><span class="line">libm.so.6 =&gt; /lib/x86_64-Linux-gnu/libm.so.6 (0x00007f7cfaccb000)</span><br><span class="line">libgcc_s.so.1 =&gt; /lib/x86_64-Linux-gnu/libgcc_s.so.1 (0x00007f7cfacae000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-Linux-gnu/libc.so.6 (0x00007f7cfaabc000)</span><br><span class="line">/lib64/ld-Linux-x86-64.so.2 (0x00007f7cfb806000)</span><br><span class="line">libpthread.so.0 =&gt; /lib/x86_64-Linux-gnu/libpthread.so.0 (0x00007f7cfaa99000)</span><br><span class="line">libdl.so.2 =&gt; /lib/x86_64-Linux-gnu/libdl.so.2 (0x00007f7cfaa93000)</span><br><span class="line"></span><br><span class="line">root@wt400:/home/j00503/Code/WT328/source/bin<span class="comment"># ldd /lib/x86_64-Linux-gnu/libjsoncpp.so.1</span></span><br><span class="line">Linux-vdso.so.1 (0x00007ffce2ad4000)</span><br><span class="line">libstdc++.so.6 =&gt; /lib/x86_64-Linux-gnu/libstdc++.so.6 (0x00007f3dde1ae000)</span><br><span class="line">libm.so.6 =&gt; /lib/x86_64-Linux-gnu/libm.so.6 (0x00007f3dde05f000)</span><br><span class="line">libgcc_s.so.1 =&gt; /lib/x86_64-Linux-gnu/libgcc_s.so.1 (0x00007f3dde044000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-Linux-gnu/libc.so.6 (0x00007f3ddde52000)</span><br><span class="line">/lib64/ld-Linux-x86-64.so.2 (0x00007f3dde3db000)</span><br><span class="line"></span><br><span class="line">root@wt400:/home/j00503/Code/WT328/source/bin<span class="comment"># ls -l /lib/x86_64-Linux-gnu/libjsoncpp*</span></span><br><span class="line">-rw-r--r-- 1 root root 436438 3月  21  2020 /lib/x86_64-Linux-gnu/libjsoncpp.a</span><br><span class="line">lrwxrwxrwx 1 root root     15 3月  21  2020 /lib/x86_64-Linux-gnu/libjsoncpp.so -&gt; libjsoncpp.so.1</span><br><span class="line">lrwxrwxrwx 1 root root     19 3月  21  2020 /lib/x86_64-Linux-gnu/libjsoncpp.so.1 -&gt; libjsoncpp.so.1.7.4</span><br><span class="line">-rw-r--r-- 1 root root 215840 3月  21  2020 /lib/x86_64-Linux-gnu/libjsoncpp.so.1.7.4</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240625095531.png" alt="WSL2"></p><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240625095607.png" alt="编译服务器"></p><p>又发现了 cmake 失效</p><p>cmake 依赖于<code>libjsoncpp.so.25</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 手动安装 libjsoncpp25 并使用 1.9.5-3 版本</span><br><span class="line">root@DESKTOP-S5NII96:/home/guo<span class="comment"># dpkg -i ./libjsoncpp25_1.9.5-3_amd64.deb</span></span><br><span class="line">(Reading database ... 49218 files and directories currently installed.)</span><br><span class="line">Preparing to unpack .../libjsoncpp25_1.9.5-3_amd64.deb ...</span><br><span class="line">Unpacking libjsoncpp25:amd64 (1.9.5-3) over (1.9.5-3) ...</span><br><span class="line">Setting up libjsoncpp25:amd64 (1.9.5-3) ...</span><br><span class="line">Processing triggers <span class="keyword">for</span> libc-bin (2.35-0ubuntu3.8) ...</span><br><span class="line"></span><br><span class="line">// cmake正常使用</span><br><span class="line">root@DESKTOP-S5NII96:/home/guo<span class="comment"># cmake</span></span><br><span class="line">Usage</span><br><span class="line">cmake [options] &lt;path-to-source&gt;</span><br><span class="line">cmake [options] &lt;path-to-existing-build&gt;</span><br><span class="line">cmake [options] -S &lt;path-to-source&gt; -B &lt;path-to-build&gt;</span><br><span class="line">Specify a <span class="built_in">source</span> directory to (re-)generate a build system <span class="keyword">for</span> it <span class="keyword">in</span> the</span><br><span class="line">current working directory.  Specify an existing build directory to</span><br><span class="line">re-generate its build system.</span><br><span class="line">Run <span class="string">&#x27;cmake --help&#x27;</span> <span class="keyword">for</span> more information.</span><br><span class="line"></span><br><span class="line">// 先安装 libjsoncpp.so.1.9.5 和 libjsoncpp25，cmake正常使用</span><br><span class="line">// <span class="built_in">source</span>编译还是报找不到libjsoncpp.so.1的错误</span><br><span class="line">root@DESKTOP-S5NII96:/usr/lib/x86_64-Linux-gnu<span class="comment"># ls -l libjsoncpp*</span></span><br><span class="line">lrwxrwxrwx 1 root root     16 Jan 30  2022 libjsoncpp.so -&gt; libjsoncpp.so.25</span><br><span class="line">-rw-r--r-- 1 root root 215792 Jan 30  2022 libjsoncpp.so.1.9.5</span><br><span class="line">lrwxrwxrwx 1 root root     19 Jan 30  2022 libjsoncpp.so.25 -&gt; libjsoncpp.so.1.9.5</span><br></pre></td></tr></table></figure><p>再次安装<code>libjsoncpp1_1.7.4-3_amd64.deb</code>, 编译 source 正常</p><p>总结:</p><ol><li><p>需要安装 3 个软件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">libjsoncpp-dev // 当前最新是 1.9.5 版本</span><br><span class="line">libjsoncpp25_1.9.5-3_amd64.deb // 对应上面的最新版本</span><br><span class="line">libjsoncpp1_1.7.4-3_amd64.deb // 安装 libjsoncpp1，安装1.7.4版本，后面没有更新了</span><br><span class="line"></span><br><span class="line">// 当前效果</span><br><span class="line">root@DESKTOP-S5NII96:/usr/lib/x86_64-Linux-gnu<span class="comment"># ls -l libjsoncpp*</span></span><br><span class="line"></span><br><span class="line">lrwxrwxrwx 1 root root     16 Jan 30  2022 libjsoncpp.so -&gt; libjsoncpp.so.25</span><br><span class="line">lrwxrwxrwx 1 root root     19 Aug 23  2016 libjsoncpp.so.1 -&gt; libjsoncpp.so.1.7.4</span><br><span class="line">-rw-r--r-- 1 root root 203464 Aug 23  2016 libjsoncpp.so.1.7.4</span><br><span class="line">-rw-r--r-- 1 root root 215792 Jan 30  2022 libjsoncpp.so.1.9.5</span><br><span class="line">lrwxrwxrwx 1 root root     19 Jan 30  2022 libjsoncpp.so.25 -&gt; libjsoncpp.so.1.9.5</span><br></pre></td></tr></table></figure></li><li><p>手动设置软连接是无效的, 本因是需要装三个软件</p></li><li><p>手动安装软件包。在清华源里面查找对应包，下载下来，使用<code>dpkg -i a.deb</code>来安装 &#x2F;&#x2F; 假设 a 为软件包名</p></li><li><p>卸载软件包 <code>sudo apt remove a</code></p></li><li><p>定位软件包 <code>locate a</code></p></li><li><p>更新<code>locate</code>用 <code>updatedb</code></p></li></ol></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;Linux 依赖各种库，有的是项目文件夹 lib 里面已经有了，有的需要安装。本文介绍了在 WSL2 编译一个项目遇到的环境问题。在一天半的时间尝试下，终于解决了，记录下解决的过程。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://hmmmmmya.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://hmmmmmya.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>010_wsl2使用介绍</title>
    <link href="https://hmmmmmya.github.io/2024/06/21/010_wsl2%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/"/>
    <id>https://hmmmmmya.github.io/2024/06/21/010_wsl2%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/</id>
    <published>2024-06-21T07:06:34.000Z</published>
    <updated>2024-10-23T06:56:18.350Z</updated>
    
    <content type="html"><![CDATA[<p>适用于 Linux 的 Windows 子系统 (WSL) 是 Windows 的一项功能，可用于在 Windows 计算机上运行 Linux 环境，而无需单独的虚拟机或双引导。 WSL 旨在为希望同时使用 Windows 和 Linux 的开发人员提供无缝高效的体验。比 VMWare 或 Virtual Box 等虚拟机更轻量, 最主要是 Windows 原生支持。</p><span id="more"></span><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>开发人员可以在 Windows 计算机上同时访问 Windows 和 Linux 的强大功能。</p><ul><li><a href="https://learn.microsoft.com/zh-cn/windows/wsl/install#step-1---enable-the-windows-subsystem-for-linux">安装 WSL2</a></li></ul><h2 id="管理-Linux"><a href="#管理-Linux" class="headerlink" title="管理 Linux"></a>管理 Linux</h2><p><a href="https://learn.microsoft.com/zh-cn/windows/wsl/basic-commands">WSL 的基本命令</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">安装</span><br><span class="line">将目录更改为主页</span><br><span class="line">Help 命令</span><br><span class="line">以特定用户的身份运行</span><br><span class="line">更改发行版的默认用户</span><br><span class="line">标识 IP 地址</span><br><span class="line">导出分发版</span><br><span class="line">导入分发版</span><br><span class="line">就地导入发行版</span><br><span class="line">装载磁盘或设备</span><br><span class="line">卸载磁盘</span><br><span class="line">已弃用的 WSL 命令</span><br></pre></td></tr></table></figure><table><thead><tr><th>功能</th><th>命令</th></tr></thead><tbody><tr><td>列出可用(可在线安装)的 Linux 发行版</td><td><code>wsl --list --online</code></td></tr><tr><td>列出已安装的 Linux 发行版</td><td><code>wsl --list --verbose</code></td></tr><tr><td>安装指定 Linux 发行版</td><td><code>wsl --install &lt;Distribution Name&gt;</code></td></tr><tr><td>检查正在运行的 WSL 版本</td><td><code>wsl -l -v</code></td></tr><tr><td>将 WSL 版本设置为 1 或 2</td><td><code>wsl --set-version &lt;distribution name&gt; &lt;versionNumber&gt;</code></td></tr><tr><td>检查 WSL 版本</td><td><code>wsl --version</code></td></tr><tr><td>设置默认版本为 WSL 1 或 WSL 2</td><td><code>wsl --set-default-version &lt;Version#&gt;</code>，将 <code>Version#</code> 替换为 1 或 2</td></tr><tr><td>检查 WSL 状态</td><td><code>wsl --status</code></td></tr><tr><td>更新 WSL</td><td><code>wsl --update</code></td></tr><tr><td>设置默认 Linux 发行版</td><td><code>wsl --set-default &lt;Distribution Name&gt;</code></td></tr><tr><td>通过 PowerShell 或 CMD 运行特定的 Linux 发行版</td><td><code>wsl --distribution &lt;Distribution Name&gt; --user &lt;User Name&gt;</code></td></tr><tr><td>关闭</td><td><code>wsl --shutdown</code></td></tr><tr><td>Terminate</td><td><code>wsl --terminate &lt;Distribution Name&gt;</code></td></tr><tr><td>注销或卸载 Linux 发行版</td><td><code>wsl --unregister &lt;DistributionName&gt;</code></td></tr></tbody></table><h3 id="设置-Linux-用户名和密码"><a href="#设置-Linux-用户名和密码" class="headerlink" title="设置 Linux 用户名和密码"></a>设置 Linux 用户名和密码</h3><p>参考: <a href="https://learn.microsoft.com/zh-cn/windows/wsl/setup/environment#set-up-your-linux-username-and-password">https://learn.microsoft.com/zh-cn/windows/wsl/setup/environment#set-up-your-linux-username-and-password</a></p><h3 id="vscode-中连接-wsl"><a href="#vscode-中连接-wsl" class="headerlink" title="vscode 中连接 wsl"></a>vscode 中连接 wsl</h3><ul><li><p>安装 WSL 插件</p></li><li><p>安装 Remote - SSH 插件</p></li><li><p>F9 输入<code>WSL</code>, 选择<code>WSL:Connect to WSL using Distro</code></p><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240621145853.png" alt="命名面板输入WSL"></p></li><li><p>选择已安装的版本</p><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240621145749.png" alt="选择已安装的版本"></p></li><li><p>连接成功后, 打开 wsl 文件夹</p><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240621150828.png" alt="打开wsl文件夹"></p></li></ul><h2 id="Q-A"><a href="#Q-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ul><li><p>wsl: 检测到 localhost 代理配置，但未镜像到 WSL。NAT 模式下的 WSL 不支持 localhost 代理。</p><ul><li><code>wsl.exe --update</code></li></ul></li><li><p>进入不了 root</p><ul><li>使用 sudo su 进入 root, 账号密码都是创建时的, 即管理员账号</li></ul><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240621143616.png" alt="使用sudo su进入root"></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;适用于 Linux 的 Windows 子系统 (WSL) 是 Windows 的一项功能，可用于在 Windows 计算机上运行 Linux 环境，而无需单独的虚拟机或双引导。 WSL 旨在为希望同时使用 Windows 和 Linux 的开发人员提供无缝高效的体验。比 VMWare 或 Virtual Box 等虚拟机更轻量, 最主要是 Windows 原生支持。&lt;/p&gt;</summary>
    
    
    
    
    <category term="wsl2" scheme="https://hmmmmmya.github.io/tags/wsl2/"/>
    
  </entry>
  
  <entry>
    <title>009_使用vscode调试rust项目</title>
    <link href="https://hmmmmmya.github.io/2024/06/20/009_%E4%BD%BF%E7%94%A8vscode%E8%B0%83%E8%AF%95rust%E9%A1%B9%E7%9B%AE/"/>
    <id>https://hmmmmmya.github.io/2024/06/20/009_%E4%BD%BF%E7%94%A8vscode%E8%B0%83%E8%AF%95rust%E9%A1%B9%E7%9B%AE/</id>
    <published>2024-06-20T06:44:58.000Z</published>
    <updated>2024-10-09T02:00:59.296Z</updated>
    
    <content type="html"><![CDATA[<p>windows 下, 使用 vscode 调试 rust 项目</p><p>工具: vscode, rust-analyzer 插件, rust 环境</p><span id="more"></span><ul><li><p>安装 vscode 插件: rust-analyzer</p></li><li><p>创建 rust 项目</p><ul><li>终端输入命令 <code>cargo new ProjectName</code></li></ul></li><li><p>使用<code>cargo run</code>或者<code>cargo build</code>命令编译项目, 生成可执行文件<code>target/debug/ProjectName.exe</code></p><p>注意: 必须编译通过生成可执行文件后才能进行 debug</p></li><li><p>创建 launch.json 文件</p><ul><li><p>debug 点击创建 launch.json 文件<br><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240620164934.png" alt="创建 launch.json文件"></p></li><li><p>调试器选择 LLDB (rust 调试器为 LLDB)</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240620165044.png" alt="调试器选择LLDB"></p><ul><li>选择 yes, 调试环境会自动配置好</li></ul><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240620165225.png" alt="选择yes"></p></li><li><p>设置断点</p></li><li><p>F5 或者 运行-&gt;终端-&gt;开启调试</p></li><li><p>在左侧查看 debug 的变量和堆栈<br><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240620150545.png" alt="debug结果"></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;windows 下, 使用 vscode 调试 rust 项目&lt;/p&gt;
&lt;p&gt;工具: vscode, rust-analyzer 插件, rust 环境&lt;/p&gt;</summary>
    
    
    
    <category term="rust" scheme="https://hmmmmmya.github.io/categories/rust/"/>
    
    
    <category term="vscode" scheme="https://hmmmmmya.github.io/tags/vscode/"/>
    
    <category term="rust" scheme="https://hmmmmmya.github.io/tags/rust/"/>
    
    <category term="debug" scheme="https://hmmmmmya.github.io/tags/debug/"/>
    
  </entry>
  
  <entry>
    <title>008_vscode插件推荐</title>
    <link href="https://hmmmmmya.github.io/2024/06/17/008_vscode%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
    <id>https://hmmmmmya.github.io/2024/06/17/008_vscode%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/</id>
    <published>2024-06-17T02:14:14.000Z</published>
    <updated>2024-10-23T06:10:35.325Z</updated>
    
    <content type="html"><![CDATA[<p>自用 vscode 插件推荐</p><span id="more"></span><table><thead><tr><th>类别</th><th>插件名称</th><th>备注</th></tr></thead><tbody><tr><td><strong>开发语言与框架</strong></td><td></td><td></td></tr><tr><td>C&#x2F;C++</td><td>C&#x2F;C++ Extension Pack</td><td>包含 C&#x2F;C++, C&#x2F;C++ Themes, CMake, CMake Tools</td></tr><tr><td></td><td>C&#x2F;C++</td><td>C++ 编译、调试 (需提前安装编译器, 如 MinGW)</td></tr><tr><td></td><td>CMake</td><td>语法高亮, 代码补全</td></tr><tr><td></td><td>CMake Tools</td><td>CMake 工具包</td></tr><tr><td>Rust</td><td>rust-analyzer</td><td>Rust 语言支持</td></tr><tr><td><strong>开发工具</strong></td><td></td><td></td></tr><tr><td>路径智能提示</td><td>Path Intellisense</td><td>文件路径自动补全</td></tr><tr><td>文档编辑</td><td>Markdown All in One</td><td>Markdown 全功能支持</td></tr><tr><td>版本控制</td><td>GitLens</td><td>增强的 Git 功能，查看修改历史，Git blame</td></tr><tr><td></td><td>SVN</td><td>Subversion 版本控制支持</td></tr><tr><td></td><td>SVN Lens</td><td>SVN blame 功能</td></tr><tr><td>远程开发</td><td>Remote - SSH</td><td>通过 SSH 进行远程开发</td></tr><tr><td>容器化</td><td>Docker</td><td>Docker 容器支持</td></tr><tr><td>虚拟化</td><td>WSL</td><td>Windows Subsystem for Linux 支持</td></tr><tr><td>数据库</td><td>SQLite</td><td>SQLite 数据库支持</td></tr><tr><td><strong>效率工具</strong></td><td></td><td></td></tr><tr><td>项目管理</td><td>Project Manager</td><td>快速切换项目，支持标签</td></tr><tr><td>AI IDE</td><td>Cursor</td><td>智能 IDE</td></tr><tr><td>AI 代码补全</td><td>Codeium</td><td>智能代码补全</td></tr><tr><td>代码运行</td><td>Code Runner</td><td>快速运行各种语言的代码片段</td></tr><tr><td><strong>界面美化</strong></td><td></td><td></td></tr><tr><td>本地化</td><td>Chinese (Simplified)</td><td>简体中文界面</td></tr><tr><td>图标主题</td><td>Material Icon Theme</td><td>美化文件图标</td></tr><tr><td>颜色主题</td><td>Night Owl</td><td>深色主题</td></tr><tr><td></td><td>One Dark Pro</td><td>另一款流行的深色主题</td></tr><tr><td><strong>代码质量</strong></td><td></td><td></td></tr><tr><td>代码格式化</td><td>Prettier</td><td>支持多种语言的代码格式化</td></tr><tr><td></td><td>markdownlint</td><td>Markdown 语法检查和格式化</td></tr><tr><td><strong>可视化工具</strong></td><td></td><td></td></tr><tr><td>JSON 可视化</td><td>JSON Crack</td><td>JSON 数据可视化工具</td></tr><tr><td>思维导图</td><td>markmap</td><td>将 Markdown 转换为思维导图</td></tr><tr><td>PDF 阅读</td><td>vscode-pdf</td><td>PDF 阅读工具</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;自用 vscode 插件推荐&lt;/p&gt;</summary>
    
    
    
    <category term="工具" scheme="https://hmmmmmya.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="vscode" scheme="https://hmmmmmya.github.io/tags/vscode/"/>
    
  </entry>
  
  <entry>
    <title>007_windows下搭建C++编译环境</title>
    <link href="https://hmmmmmya.github.io/2024/06/17/007_windows%E4%B8%8B%E6%90%AD%E5%BB%BACpp%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/"/>
    <id>https://hmmmmmya.github.io/2024/06/17/007_windows%E4%B8%8B%E6%90%AD%E5%BB%BACpp%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/</id>
    <published>2024-06-17T01:46:24.000Z</published>
    <updated>2024-10-09T01:59:49.373Z</updated>
    
    <content type="html"><![CDATA[<p>using CMake + MinGW + VSCode</p><p>CMake is an open-source, cross-platform tool that uses compiler and platform independent configuration files to generate native build tool files specific to your compiler and platform.</p><p>The CMake Tools extension integrates Visual Studio Code and CMake to make it easy to configure, build, and debug your C++ project.</p><span id="more"></span><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><ol><li><p>安装 VSCode</p><p>配置 VSCode 终端<br><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240614104906.png" alt="配置VSCode终端"></p></li><li><p>安装 VSCode 插件 C&#x2F;C++</p></li><li><p>安装 VSCode 插件 CMake 和 CMake Tools</p><ul><li><p>CMake 插件主要功能是 CMake 语法高亮、自动补全</p></li><li><p>CMake Tools 的功能主要是结合 VSCode IDE 使用 CMake 这个工具，比如生成 CMake 项目、构建、调试 CMake 项目等。不能跨平台。</p></li></ul></li><li><p>安装 CMake</p><p>The VS Code CMake Tools extension does its work by using CMake installed on your system. For best results, use CMake version 3.27 or greater.</p><p>下载地址：<a href="https://cmake.org/download/">https://cmake.org/download/</a></p><p>下载 zip 版本“cmake-3.xx-win64-x64.zip”，下载完成解压到指定目录并添加 bin 所在目录到环境变量。</p><p>在终端输入“cmake –help”或 “cmake –version”查看是否配置成功。</p><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240614105048.png" alt="查看cmake是否配置成功"></p></li><li><p>安装编译器 MinGW</p><ul><li><p>MSVC 即 Microsoft Visual C++ Compiler，即微软自己的编译器。</p></li><li><p>MinGW 则是指 Minimalist GNU for Windows 的缩写它是将 GNU 开发工具移植到 Win32 平台下的产物，即一套 Windows 上的 GNU 工具集。能够跨平台，能够在 linux、arm 等平台使用，这些平台使用的编译器都是 g++、gcc。</p></li><li><p>跨平台开发的话，用的库基本上一定是 Linux 能用的库，而 Linux 能用的库一定是在 mingw 下支持会比较好。</p></li><li><p>MinGW-w64</p><p>下载地址：<a href="https://sourceforge.net/projects/mingw-w64/files/mingw-w64/mingw-w64-release/">https://sourceforge.net/projects/mingw-w64/files/mingw-w64/mingw-w64-release/</a></p><p>页面往下滑，选择 MinGW-W64 Online Installer 下面的最新版本，现在是 MinGW-W64 GCC-8.1.0</p><p>推荐下载 离线版本“x86_64-posix-seh”</p><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240614110612.png" alt="选择mingw版本"></p><p>下载完成解压到指定目录并添加 bin 所在目录到环境变量。</p><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240614111327.png" alt="添加到环境变量"></p><p>将 mingw64\bin 目录下的“mingw32-make.exe”复制一份并改名为 “make.exe”，就可以在终端直接使用 “make”指令而不必使用“mingw32-make”指令。</p><p>在终端输入 “gcc -v”（或输入“make -v”查看版本信息）</p><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240614111656.png" alt="make -v"></p></li></ul></li><li><p>VSCode 配置</p><p>两种方式配置 CMake Tools extension，参考 Ref_1</p><ul><li>Use CMake Presets (recommended)<ul><li>通过 JSON 配置，可以跨 IDE 和操作系统使用</li></ul></li><li>Use CMake Kits&#x2F;Variants</li></ul></li></ol><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol><li><a href="https://code.visualstudio.com/docs/cpp/CMake-linux">CMake Tools for VSCode documentation</a></li><li><a href="https://vector-of-bool.github.io/docs/vscode-cmake-tools/getting_started.html#">vscode-cmake-tools getting started</a></li><li><a href="https://blog.csdn.net/dcrmg/article/details/103918543">windows 下 CMake+MinGW 搭建 C&#x2F;C++编译环境</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;using CMake + MinGW + VSCode&lt;/p&gt;
&lt;p&gt;CMake is an open-source, cross-platform tool that uses compiler and platform independent configuration files to generate native build tool files specific to your compiler and platform.&lt;/p&gt;
&lt;p&gt;The CMake Tools extension integrates Visual Studio Code and CMake to make it easy to configure, build, and debug your C++ project.&lt;/p&gt;</summary>
    
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/categories/c/"/>
    
    
    <category term="c++" scheme="https://hmmmmmya.github.io/tags/c/"/>
    
    <category term="vscode" scheme="https://hmmmmmya.github.io/tags/vscode/"/>
    
  </entry>
  
  <entry>
    <title>006_云访问图片</title>
    <link href="https://hmmmmmya.github.io/2024/06/12/006_%E4%BA%91%E8%AE%BF%E9%97%AE%E5%9B%BE%E7%89%87/"/>
    <id>https://hmmmmmya.github.io/2024/06/12/006_%E4%BA%91%E8%AE%BF%E9%97%AE%E5%9B%BE%E7%89%87/</id>
    <published>2024-06-12T03:03:04.000Z</published>
    <updated>2024-10-23T06:52:40.179Z</updated>
    
    <content type="html"><![CDATA[<p>使用 PicGo + GitHub + Typora 来搭建图床，实现云访问图片</p><span id="more"></span><p>图床简介:</p><p>如果没有图床，markdown 插入图片的保存位置是本地，例如 c 盘某个位置，发布到网上后是找不到对应图片的。</p><p>图床将图片存储在云服务器，markdown 插入图片在云服务器内的链接地址，这样任何人都可以访问到了。</p><h2 id="一、配置-GitHub"><a href="#一、配置-GitHub" class="headerlink" title="一、配置 GitHub"></a>一、配置 GitHub</h2><h3 id="1-1-创建一个新的仓库-用于存放图片"><a href="#1-1-创建一个新的仓库-用于存放图片" class="headerlink" title="1.1 创建一个新的仓库, 用于存放图片"></a>1.1 创建一个新的仓库, 用于存放图片</h3><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/image-20240612120448018.png" alt="image-20240612120448018"></p><p>填写仓库名称和描述，且仓库必须是 public 的，否则存储的图片不能正常访问。</p><h3 id="2-2-生成一个-token，用于-picGo-访问-github"><a href="#2-2-生成一个-token，用于-picGo-访问-github" class="headerlink" title="2.2 生成一个 token，用于 picGo 访问 github"></a>2.2 生成一个 token，用于 picGo 访问 github</h3><p>仓库 -&gt; settings</p><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/image-20240612120807226.png" alt="image-20240612120807226"></p><p>选择 Developer settings</p><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/image-20240612120845815.png" alt="image-20240612120845815"></p><p>选择 Personal access tokens</p><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/image-20240612121032553.png" alt="image-20240612121032553"></p><p>点击右侧的 Generate new token</p><p>把 repo 的勾打上即可。然后翻到页面最底部，点击<code>Generate token</code>的绿色按钮生成 token。</p><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/image-20240612121746408.png" alt="image-20240612121746408"></p><p><strong>注意:</strong> 这个 token 生成后只会显示一次！你要把这个 token 复制一下存到其他地方以备以后要用。</p><h2 id="二、配置-PicGo"><a href="#二、配置-PicGo" class="headerlink" title="二、配置 PicGo"></a>二、配置 PicGo</h2><h3 id="2-1-下载-PicGo"><a href="#2-1-下载-PicGo" class="headerlink" title="2.1 下载 PicGo"></a>2.1 下载 PicGo</h3><p><a href="https://github.com/Molunerfinn/PicGo/releases">GitHub 链接</a></p><h3 id="2-2-设置-GitHub-图床"><a href="#2-2-设置-GitHub-图床" class="headerlink" title="2.2 设置 GitHub 图床"></a>2.2 设置 GitHub 图床</h3><p>打开 PicGo 桌面应用，选择图床设置 -&gt; GitHub</p><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/image-20240612122325497.png" alt="image-20240612122325497"></p><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/image-20240612141946042.png" alt="image-20240612141946042"></p><p><strong>注意:</strong></p><ul><li>仓库名的格式是<code>用户名/仓库</code>，比如我创建了一个叫做<code>test</code>的仓库，在 PicGo 里我要设定的仓库名就是<code>Molunerfinn/test</code>。</li><li>分支: 一般我们选择<code>main</code>分支即可。</li><li>设定 Token: 将刚才保存的 Token 粘贴到这里</li><li>存储路径是 GitHub 仓库里面的指定目录</li><li>点击确定以生效，然后可以点击<code>设为默认图床</code>来确保上传的图床是 GitHub。</li></ul><h3 id="2-3-使用-cdn-加速"><a href="#2-3-使用-cdn-加速" class="headerlink" title="2.3 使用 cdn 加速"></a>2.3 使用 cdn 加速</h3><h4 id="2-3-1-cdn-简介"><a href="#2-3-1-cdn-简介" class="headerlink" title="2.3.1 cdn 简介"></a>2.3.1 cdn 简介</h4><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240612151908.png" alt="cdn分发原理图"></p><ul><li><p>CDN 全称 Content Delivery Network 即内容分发网络，是一组分布在多个不同地方的 WEB 服务器，会根据用户距离的远近来选择最近的服务器 。</p></li><li><p>是一个免费、快速和可信赖的 CDN 加速服务，声称它每个月可以支撑 680 亿次的请求。服务在 Github 上是开源的。</p></li><li><p>只要我们的项目中用到了第三方的静态资源，譬如 JavaScript 脚本，css 样式表，图片，图标，Flash 等静态资源文件都应该考虑接入到 CDN 中</p></li><li><p>jsDelivr + Github 便是免费且好用的 CDN，非常适合博客网站使用</p></li></ul><h4 id="2-3-2-cdn-使用"><a href="#2-3-2-cdn-使用" class="headerlink" title="2.3.2 cdn 使用"></a>2.3.2 cdn 使用</h4><p>通过如下地址应用资源</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径</span><br></pre></td></tr></table></figure><p>举个栗子,获取 source&#x2F;bgimg 路径下的 back-rain.png</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://cdn.jsdelivr.net/gh/xiezhr/mycdn/source/bgimg/back-rain.png       ## 获取最新资源</span><br><span class="line">https://cdn.jsdelivr.net/gh/xiezhr/mycdn@1.0/source/bgimg/back-rain.png   ## 获取1.0版本的资源</span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 版本号不是必需的，是为了区分新旧资源</p><h4 id="2-3-3-使用-cdn-加速-PicGo-中的静态资源"><a href="#2-3-3-使用-cdn-加速-PicGo-中的静态资源" class="headerlink" title="2.3.3 使用 cdn 加速 PicGo 中的静态资源"></a>2.3.3 使用 cdn 加速 PicGo 中的静态资源</h4><p>PicGo -&gt; 设置自定义域名</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main</span><br></pre></td></tr></table></figure><h3 id="2-4-上传图片"><a href="#2-4-上传图片" class="headerlink" title="2.4 上传图片"></a>2.4 上传图片</h3><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/image-20240612122804700.png" alt="image-20240612122804700"></p><p>至此配置完毕，已经可以使用了。当你上传的时候，你会发现你的仓库里也会增加新的图片了</p><h3 id="2-5-编辑相册的图片信息"><a href="#2-5-编辑相册的图片信息" class="headerlink" title="2.5 编辑相册的图片信息"></a>2.5 编辑相册的图片信息</h3><p>选择相册</p><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/image-20240612122946564.png" alt="image-20240612122946564"></p><p>选择复制的链接格式</p><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/image-20240612123028558.png" alt="image-20240612123028558"></p><h2 id="三、配置-Typora"><a href="#三、配置-Typora" class="headerlink" title="三、配置 Typora"></a>三、配置 Typora</h2><p>Typora 偏好设置 -&gt; 图像</p><ol><li>插入图片时，选择上传图片，对本地图片应用上述规则</li><li>上传服务: 选择 PicGo（app）</li><li>PicGo 路径: 选择安装路径</li><li>验证: 验证图片上传选项</li></ol><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/image-20240612140917028.png" alt="image-20240612140917028"></p><p>总结: github+picGo+typora 他们三个是好基友</p><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><ul><li><a href="https://picgo.github.io/PicGo-Doc/zh/guide/config.html">PicGo 配置手册</a></li><li><a href="https://zhuanlan.zhihu.com/p/489236769">使用 Github+picGo 搭建图床，保姆级教程</a></li><li><a href="https://www.cnblogs.com/xiezhr/p/17343616.html">如何使用 jsDelivr+Github 实现免费 CDN 加速?</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用 PicGo + GitHub + Typora 来搭建图床，实现云访问图片&lt;/p&gt;</summary>
    
    
    
    <category term="博客" scheme="https://hmmmmmya.github.io/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="图床" scheme="https://hmmmmmya.github.io/tags/%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
  <entry>
    <title>005_云访问博客</title>
    <link href="https://hmmmmmya.github.io/2024/06/12/005_%E4%BA%91%E8%AE%BF%E9%97%AE%E5%8D%9A%E5%AE%A2/"/>
    <id>https://hmmmmmya.github.io/2024/06/12/005_%E4%BA%91%E8%AE%BF%E9%97%AE%E5%8D%9A%E5%AE%A2/</id>
    <published>2024-06-12T01:07:12.000Z</published>
    <updated>2024-10-23T06:52:26.908Z</updated>
    
    <content type="html"><![CDATA[<p>使用 GitHub Pages 作为博客的云服务器，实现云访问博客</p><span id="more"></span><h2 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h2><p>新建仓库，填写内容如下，<strong>特别注意红框位置</strong></p><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/image-20240520143122990.png" alt="image-20240520143122990"></p><p>保证仓库<strong>public</strong>，名称填写正确<strong>用户名.github.io</strong>，系统自动变更为<strong>Pages</strong></p><p>在仓库设置中找到<strong>Pages</strong></p><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/image-20240520143142668.png" alt="image-20240520143142668"></p><p>记住仓库地址，我们会将本地的文件上传到仓库</p><h2 id="配置-Git"><a href="#配置-Git" class="headerlink" title="配置 Git"></a>配置 Git</h2><h2 id="Hexo-中配置-GitHub"><a href="#Hexo-中配置-GitHub" class="headerlink" title="Hexo 中配置 GitHub"></a>Hexo 中配置 GitHub</h2><p>在 Hexo 项目主目录中修改<code>_config.yml</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> url: https://hmmmmmya.github.io</span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">type: git # 不要使用 github, 没有双引号</span><br><span class="line">repo: git@github.com:hmmmmmya/hmmmmmya.github.io.git # 使用 ssh 连接</span><br><span class="line">branch: main # 分支</span><br><span class="line">message: add new blog # 自动部署 commit 备注，可不填</span><br></pre></td></tr></table></figure><p>注意 url 不能直接拷贝仓库地址<code>https://github.com/hmmmmmya/hmmmmmya.github.io</code>, 否则显示会有问题</p><p>url 要写成<code>https://hmmmmmya.github.io</code></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用 GitHub Pages 作为博客的云服务器，实现云访问博客&lt;/p&gt;</summary>
    
    
    
    <category term="博客" scheme="https://hmmmmmya.github.io/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="博客" scheme="https://hmmmmmya.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>004_git连接github</title>
    <link href="https://hmmmmmya.github.io/2024/06/11/004_git%E8%BF%9E%E6%8E%A5github/"/>
    <id>https://hmmmmmya.github.io/2024/06/11/004_git%E8%BF%9E%E6%8E%A5github/</id>
    <published>2024-06-11T08:46:43.000Z</published>
    <updated>2024-10-23T06:55:24.482Z</updated>
    
    <content type="html"><![CDATA[<p>配置 git 来连接 GitHub</p><span id="more"></span><h2 id="配置-Git"><a href="#配置-Git" class="headerlink" title="配置 Git"></a>配置 Git</h2><h3 id="一、安装-Git"><a href="#一、安装-Git" class="headerlink" title="一、安装 Git"></a>一、安装 Git</h3><p>安装<a href="https://git-scm.com/download/win">git</a></p><h3 id="二、本地生成-SSH-keys"><a href="#二、本地生成-SSH-keys" class="headerlink" title="二、本地生成 SSH keys"></a>二、本地生成 SSH keys</h3><ol><li><p>打开 Git Bash</p></li><li><p>输入生成命令</p><p><code>ssh-keygen -t ed25519 -C &quot;&lt;your_email@example.com&gt;&quot;</code></p></li><li><p>一路回车, 保存 key 到默认位置(<code>/c/Users/Users/.ssh/</code>)</p><blockquote><p>目录下有两个 rsa 文件, id_rsa 和 id_rsa.pub</p></blockquote></li></ol><h3 id="三、使用-SSH-keys-连接到-GitHub"><a href="#三、使用-SSH-keys-连接到-GitHub" class="headerlink" title="三、使用 SSH keys 连接到 GitHub"></a>三、使用 SSH keys 连接到 GitHub</h3><ol><li>选择 <code>GitHub Settings -&gt; SSH and GPG keys -&gt; New SSH key</code></li><li>复制本地的公钥<code>id_rsa.pub</code>到<code>New SSH key</code>, 起一个名字, 保存</li></ol><h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><ul><li>可以安装 GitHub Desktop 桌面端, 直接用图形化界面管理 GitHub 仓库</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;配置 git 来连接 GitHub&lt;/p&gt;</summary>
    
    
    
    <category term="github" scheme="https://hmmmmmya.github.io/categories/github/"/>
    
    
    <category term="github" scheme="https://hmmmmmya.github.io/tags/github/"/>
    
  </entry>
  
</feed>
