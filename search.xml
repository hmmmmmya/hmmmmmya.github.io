<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>002_搭建本地博客</title>
    <url>/2024/06/07/002_%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>使用博客框架 hexo 搭建本地博客，可切换主题</p>
<span id="more"></span>

<h2 id="一、环境准备"><a href="#一、环境准备" class="headerlink" title="一、环境准备"></a>一、环境准备</h2><p>安装<a href="https://nodejs.cn/download/">node.js</a></p>
<blockquote>
<p>Windows Powershell 检查是否安装成功: <code>node -v</code></p>
</blockquote>
<h2 id="二、安装-hexo"><a href="#二、安装-hexo" class="headerlink" title="二、安装 hexo"></a>二、安装 hexo</h2><p>使用 nodejs 的包管理工具 npm 安装 hexo, 在终端 Powershell 中输入下面的命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<h2 id="三、初始化-hexo"><a href="#三、初始化-hexo" class="headerlink" title="三、初始化 hexo"></a>三、初始化 hexo</h2><p>自选合适的目录，新建文件夹 folder</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd folder</span><br><span class="line">hexo init</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<h2 id="四、主题配置"><a href="#四、主题配置" class="headerlink" title="四、主题配置"></a>四、主题配置</h2><ul>
<li><p>安装主题</p>
<ul>
<li><p>以 Ayer 主题为例</p>
<ul>
<li><p><a href="https://github.com/Shen-Yu/hexo-theme-ayer">GitHub 仓库</a></p>
</li>
<li><p><a href="https://easyhexo.com/2-Theme-use-and-config/2-19-hexo-theme-ayer/">安装步骤</a></p>
</li>
<li><p>注意 <code>npm i hexo-theme-ayer -S</code> 会安装到 <code>node_modules</code>, 用<code>git clone</code> 则是在<code>themes</code>下面，提交代码时要 add <code>node_modules/hexo-theme-*/</code>来包含自定义主题</p>
</li>
<li><p>注意安装后再使用 <code>npm update hexo-theme-ayer -S</code> 会覆盖当前主题, 自己的配置被覆盖!!! 不要 npm 更新, 或者先保存下该主题的配置文件(已经提交过的包含了上次的配置就还好)</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>切换主题</p>
<ul>
<li><p>修改主目录下的<code>_config.yml</code>文件配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: &lt;https://hexo.io/plugins/&gt;</span><br><span class="line">## Themes: &lt;https://hexo.io/themes/&gt;</span><br><span class="line">theme: ayer</span><br><span class="line"># theme: landscape</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>003_hexo使用说明</title>
    <url>/2024/06/11/003_hexo%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<p>一款博客框架 hexo 的安装和使用说明</p>
<span id="more"></span>

<h2 id="安装-hexo"><a href="#安装-hexo" class="headerlink" title="安装 hexo"></a>安装 hexo</h2><ol>
<li><p>安装<a href="https://nodejs.cn/download/">node.js</a></p>
</li>
<li><p>安装<a href="https://git-scm.com/download/win">git</a></p>
</li>
<li><p>安装 hexo</p>
<p><code>npm install -g hexo-cli</code></p>
</li>
</ol>
<h2 id="初始化-hexo-项目"><a href="#初始化-hexo-项目" class="headerlink" title="初始化 hexo 项目"></a>初始化 hexo 项目</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">hexo init</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<h2 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h2><ol>
<li><p>找一个自己喜欢的主题: <a href="https://hexo.io/themes/">hexo 主题商店</a></p>
</li>
<li><p>使用<code>npm</code>直接安装到<code>node_modules</code>，或者<code>git clone</code>安装到<code>source/themes</code></p>
</li>
<li><p>修改主目录下的<code>_config.yml</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">ayer</span> <span class="comment"># 新主题名</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="配置-GitHub-Pages"><a href="#配置-GitHub-Pages" class="headerlink" title="配置 GitHub Pages"></a>配置 GitHub Pages</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- url: https://hmmmmmya.github.io</span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">    type: git # 不要使用github</span><br><span class="line">    repo: git@github.com:hmmmmmya/hmmmmmya.github.io.git # 使用ssh连接</span><br><span class="line">    branch: main # 分支</span><br><span class="line">    message: add new blog # 自动部署commit备注，可不填</span><br></pre></td></tr></table></figure>

<p>注意 url 不能直接拷贝仓库地址<code>https://github.com/hmmmmmya/hmmmmmya.github.io</code>, 否则显示会有问题, 要写成<code>https://hmmmmmya.github.io</code></p>
<p>hexo 使用 git 前要先安装<code>hexo-deployer-git</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<h2 id="hexo-常用命令"><a href="#hexo-常用命令" class="headerlink" title="hexo 常用命令"></a>hexo 常用命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章</span><br><span class="line">hexo g == hexo generate #生成</span><br><span class="line">hexo s == hexo server #启动服务本地预览</span><br><span class="line">hexo d == hexo deploy #部署</span><br><span class="line">hexo clean #清除缓存 网页正常情况下可以忽略此条命令</span><br></pre></td></tr></table></figure>

<ul>
<li><p>创建博客也可以在 <code>source/_posts</code>目录下创建 markdown</p>
</li>
<li><p>本地调试用 <code>hexo g</code> 和 <code>hexo s</code>, 需要清除本地生成的内容则用<code>hexo clean</code></p>
</li>
<li><p>调试时修改并保存, 本地网页能动态加载的, 不需要再重新生成再加载</p>
</li>
<li><p>本地调试无问题后，使用 <code>hexo d</code>部署到 GitHub。提交前要重新<code>hexo g</code>生成下</p>
</li>
<li><p><code>hexo clean</code>可用于提交代码时清除本地的 public 内容, 若配置了.gitignore 则提交代码时可以不用此命令</p>
</li>
</ul>
<h2 id="hexo-分类和标签"><a href="#hexo-分类和标签" class="headerlink" title="hexo 分类和标签"></a>hexo 分类和标签</h2><h3 id="创建分类"><a href="#创建分类" class="headerlink" title="创建分类"></a>创建分类</h3><p>1.1 生成“分类”页并添加 tpye 属性<br>打开命令行，进入博客所在文件夹。执行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page categories`</span><br></pre></td></tr></table></figure>

<p>成功后会提示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">INFO  Created: ~/Documents/blog/source/categories/index.md</span><br></pre></td></tr></table></figure>

<p>根据上面的路径，找到 index.md 这个文件，打开后默认内容是这样的：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章分类</span><br><span class="line"><span class="section">date: 2017-05-27 13:47:40</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>

<p>按照更换的主题指示修改后</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">layout: &quot;categories&quot;</span><br><span class="line"><span class="section">date: 2024-06-07 17:19:12</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>

<p>创建分类成功，保存并关闭文件。</p>
<p>1.2 给文章添加“categories”属性<br>打开需要添加分类的文章，为其添加 categories 属性。下方的 categories: web 前端表示添加这篇文章到“web 前端”这个分类。注意：hexo 一篇文章只能属于一个分类，也就是说如果在“- web 前端”下方添加“-xxx”，hexo 不会产生两个分类，而是把分类嵌套（即该文章属于 “- web 前端”下的 “-xxx ”分类）。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 搭建博客</span><br><span class="line">categories:</span><br><span class="line"><span class="bullet">  -</span> web前端</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">  -</span> Hexo</span><br><span class="line"><span class="bullet">  -</span> 博客</span><br><span class="line"><span class="section">date: 2024-06-07 17:01:12</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>

<p>这里<code>categories</code>自己随意修改，但只能有一个，不需要再修改<code>categories</code>目录的 index 文件。</p>
<p>至此，成功给文章添加分类，点击首页的“分类”可以看到该分类下的所有文章。当然，只有添加了 categories: xxx 的文章才会被收录到首页的“分类”中。</p>
<h2 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h2><p>2.1 生成“标签”页并添加 tpye 属性<br>打开命令行，进入博客所在文件夹。执行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>

<p>默认内容</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line"><span class="section">date: 2017-05-27 14:22:08</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>

<p>修改后</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">layout: &quot;tags&quot;</span><br><span class="line"><span class="section">date: 2024-06-07 17:20:13</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>

<p>创建标签成功，保存并关闭文件。</p>
<p>2.2 给文章添加“tags”属性</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 搭建博客</span><br><span class="line">categories:</span><br><span class="line"><span class="bullet">  -</span> web前端</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">  -</span> hexo</span><br><span class="line"><span class="bullet">  -</span> 博客</span><br><span class="line"><span class="section">date: 2024-06-07 17:01:12</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>

<p>这里<code>tags</code>自己随意增加，不需要再修改<code>tags</code>目录的<code>index</code>文件。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://hexo.io/themes/">hexo themes</a><blockquote>
<p>主题商店</p>
</blockquote>
</li>
<li><a href="https://easyhexo.com/">easyhexo</a><blockquote>
<p>hexo 使用指南</p>
</blockquote>
</li>
<li><a href="https://github.com/pengwenwu/skill-tree/blob/master/Hexo/hexo%20%2B%20github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B.md">hexo + github 搭建个人博客教程</a><blockquote>
<p>搭建个人博客教程</p>
</blockquote>
</li>
<li><a href="https://linlif.github.io/2017/05/27/Hexo%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5-%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE/">Hexo 使用攻略-添加分类及标签</a><blockquote>
<p>如何添加分类和标签</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>001_Hello World</title>
    <url>/2024/06/07/001_hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>004_git连接github</title>
    <url>/2024/06/11/004_git%E8%BF%9E%E6%8E%A5github/</url>
    <content><![CDATA[<p>配置 git 来连接 GitHub</p>
<span id="more"></span>

<h2 id="配置-Git"><a href="#配置-Git" class="headerlink" title="配置 Git"></a>配置 Git</h2><h3 id="一、安装-Git"><a href="#一、安装-Git" class="headerlink" title="一、安装 Git"></a>一、安装 Git</h3><p>安装<a href="https://git-scm.com/download/win">git</a></p>
<h3 id="二、本地生成-SSH-keys"><a href="#二、本地生成-SSH-keys" class="headerlink" title="二、本地生成 SSH keys"></a>二、本地生成 SSH keys</h3><ol>
<li><p>打开 Git Bash</p>
</li>
<li><p>输入生成命令</p>
<p><code>ssh-keygen -t ed25519 -C &quot;&lt;your_email@example.com&gt;&quot;</code></p>
</li>
<li><p>一路回车, 保存 key 到默认位置(<code>/c/Users/Users/.ssh/</code>)</p>
<blockquote>
<p>目录下有两个 rsa 文件, id_rsa 和 id_rsa.pub</p>
</blockquote>
</li>
</ol>
<h3 id="三、使用-SSH-keys-连接到-GitHub"><a href="#三、使用-SSH-keys-连接到-GitHub" class="headerlink" title="三、使用 SSH keys 连接到 GitHub"></a>三、使用 SSH keys 连接到 GitHub</h3><ol>
<li>选择 <code>GitHub Settings -&gt; SSH and GPG keys -&gt; New SSH key</code></li>
<li>复制本地的公钥<code>id_rsa.pub</code>到<code>New SSH key</code>, 起一个名字, 保存</li>
</ol>
<h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><ul>
<li>可以安装 GitHub Desktop 桌面端, 直接用图形化界面管理 GitHub 仓库</li>
</ul>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>005_云访问博客</title>
    <url>/2024/06/12/005_%E4%BA%91%E8%AE%BF%E9%97%AE%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>使用 GitHub Pages 作为博客的云服务器，实现云访问博客</p>
<span id="more"></span>

<h2 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h2><p>新建仓库，填写内容如下，<strong>特别注意红框位置</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/image-20240520143122990.png" alt="image-20240520143122990"></p>
<p>保证仓库<strong>public</strong>，名称填写正确<strong>用户名.github.io</strong>，系统自动变更为<strong>Pages</strong></p>
<p>在仓库设置中找到<strong>Pages</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/image-20240520143142668.png" alt="image-20240520143142668"></p>
<p>记住仓库地址，我们会将本地的文件上传到仓库</p>
<h2 id="配置-Git"><a href="#配置-Git" class="headerlink" title="配置 Git"></a>配置 Git</h2><h2 id="Hexo-中配置-GitHub"><a href="#Hexo-中配置-GitHub" class="headerlink" title="Hexo 中配置 GitHub"></a>Hexo 中配置 GitHub</h2><p>在 Hexo 项目主目录中修改<code>_config.yml</code></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> url: https://hmmmmmya.github.io</span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">type: git # 不要使用 github, 没有双引号</span><br><span class="line">repo: git@github.com:hmmmmmya/hmmmmmya.github.io.git # 使用 ssh 连接</span><br><span class="line">branch: main # 分支</span><br><span class="line">message: add new blog # 自动部署 commit 备注，可不填</span><br></pre></td></tr></table></figure>

<p>注意 url 不能直接拷贝仓库地址<code>https://github.com/hmmmmmya/hmmmmmya.github.io</code>, 否则显示会有问题</p>
<p>url 要写成<code>https://hmmmmmya.github.io</code></p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>007_windows下搭建C++编译环境</title>
    <url>/2024/06/17/007_windows%E4%B8%8B%E6%90%AD%E5%BB%BACpp%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>windows 环境下编译并调试 C++ 项目</p>
<span id="more"></span>

<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><ul>
<li>windows 11</li>
<li>vscode&#x2F;cursor<ul>
<li>插件: C&#x2F;C++、CMake、CMake Tools</li>
<li>CMake 插件: CMake 语法高亮、自动补全</li>
<li>CMake Tools: 生成 CMake 项目、构建、调试 CMake 项目等。</li>
</ul>
</li>
<li>cmake: 跨平台的编译(Build)工具, 通过 CMakeLists.txt 生成 Makefile 文件</li>
<li>mingw: 编译器(Compiler), 生成可执行文件</li>
</ul>
<ol>
<li><p>配置 VSCode 终端<br><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240614104906.png" alt="配置VSCode终端"></p>
</li>
<li><p>安装 CMake</p>
<p>下载地址：<a href="https://cmake.org/download/">https://cmake.org/download/</a></p>
<p>下载 zip 版本“cmake-3.xx-win64-x64.zip”，下载完成解压到指定目录并添加 bin 所在目录到环境变量。</p>
<p>在终端输入“cmake –help”或 “cmake –version”查看是否配置成功。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240614105048.png" alt="查看cmake是否配置成功"></p>
</li>
<li><p>安装编译器 MinGW</p>
<ul>
<li><p>MSVC 即 Microsoft Visual C++ Compiler，即微软自己的编译器。</p>
</li>
<li><p>MinGW 则是指 Minimalist GNU for Windows 的缩写它是将 GNU 开发工具移植到 Win32 平台下的产物，即一套 Windows 上的 GNU 工具集。能够跨平台，能够在 linux、arm 等平台使用，这些平台使用的编译器都是 g++、gcc。</p>
</li>
<li><p>跨平台开发的话，用的库基本上一定是 Linux 能用的库，而 Linux 能用的库一定是在 mingw 下支持会比较好。</p>
</li>
<li><p>MinGW-w64</p>
<p>下载地址：<a href="https://sourceforge.net/projects/mingw-w64/files/mingw-w64/mingw-w64-release/">https://sourceforge.net/projects/mingw-w64/files/mingw-w64/mingw-w64-release/</a></p>
<p>页面往下滑，选择 MinGW-W64 Online Installer 下面的最新版本，现在是 MinGW-W64 GCC-8.1.0</p>
<p>推荐下载 离线版本“x86_64-posix-seh”</p>
<p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240614110612.png" alt="选择mingw版本"></p>
<p>下载完成解压到指定目录并添加 bin 所在目录到环境变量。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240614111327.png" alt="添加到环境变量"></p>
<p>将 mingw64\bin 目录下的“mingw32-make.exe”复制一份并改名为 “make.exe”，就可以在终端直接使用 “make”指令而不必使用“mingw32-make”指令。</p>
<p>在终端输入 “gcc -v”（或输入“make -v”查看版本信息）</p>
<p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240614111656.png" alt="make -v"></p>
</li>
</ul>
</li>
</ol>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ol>
<li><a href="https://code.visualstudio.com/docs/cpp/CMake-linux">CMake Tools for VSCode documentation</a></li>
<li><a href="https://vector-of-bool.github.io/docs/vscode-cmake-tools/getting_started.html#">vscode-cmake-tools getting started</a></li>
<li><a href="https://blog.csdn.net/dcrmg/article/details/103918543">windows 下 CMake+MinGW 搭建 C&#x2F;C++编译环境</a></li>
</ol>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>006_云访问图片</title>
    <url>/2024/06/12/006_%E4%BA%91%E8%AE%BF%E9%97%AE%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<p>使用 PicGo + GitHub + Typora 来搭建图床，实现云访问图片</p>
<span id="more"></span>

<p>图床简介:</p>
<p>如果没有图床，markdown 插入图片的保存位置是本地，例如 c 盘某个位置，发布到网上后是找不到对应图片的。</p>
<p>图床将图片存储在云服务器，markdown 插入图片在云服务器内的链接地址，这样任何人都可以访问到了。</p>
<h2 id="一、配置-GitHub"><a href="#一、配置-GitHub" class="headerlink" title="一、配置 GitHub"></a>一、配置 GitHub</h2><h3 id="1-1-创建一个新的仓库-用于存放图片"><a href="#1-1-创建一个新的仓库-用于存放图片" class="headerlink" title="1.1 创建一个新的仓库, 用于存放图片"></a>1.1 创建一个新的仓库, 用于存放图片</h3><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/image-20240612120448018.png" alt="image-20240612120448018"></p>
<p>填写仓库名称和描述，且仓库必须是 public 的，否则存储的图片不能正常访问。</p>
<h3 id="2-2-生成一个-token，用于-picGo-访问-github"><a href="#2-2-生成一个-token，用于-picGo-访问-github" class="headerlink" title="2.2 生成一个 token，用于 picGo 访问 github"></a>2.2 生成一个 token，用于 picGo 访问 github</h3><p>仓库 -&gt; settings</p>
<p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/image-20240612120807226.png" alt="image-20240612120807226"></p>
<p>选择 Developer settings</p>
<p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/image-20240612120845815.png" alt="image-20240612120845815"></p>
<p>选择 Personal access tokens</p>
<p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/image-20240612121032553.png" alt="image-20240612121032553"></p>
<p>点击右侧的 Generate new token</p>
<p>把 repo 的勾打上即可。然后翻到页面最底部，点击<code>Generate token</code>的绿色按钮生成 token。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/image-20240612121746408.png" alt="image-20240612121746408"></p>
<p><strong>注意:</strong> 这个 token 生成后只会显示一次！你要把这个 token 复制一下存到其他地方以备以后要用。</p>
<h2 id="二、配置-PicGo"><a href="#二、配置-PicGo" class="headerlink" title="二、配置 PicGo"></a>二、配置 PicGo</h2><h3 id="2-1-下载-PicGo"><a href="#2-1-下载-PicGo" class="headerlink" title="2.1 下载 PicGo"></a>2.1 下载 PicGo</h3><p><a href="https://github.com/Molunerfinn/PicGo/releases">GitHub 链接</a></p>
<h3 id="2-2-设置-GitHub-图床"><a href="#2-2-设置-GitHub-图床" class="headerlink" title="2.2 设置 GitHub 图床"></a>2.2 设置 GitHub 图床</h3><p>打开 PicGo 桌面应用，选择图床设置 -&gt; GitHub</p>
<p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/image-20240612122325497.png" alt="image-20240612122325497"></p>
<p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/image-20240612141946042.png" alt="image-20240612141946042"></p>
<p><strong>注意:</strong></p>
<ul>
<li>仓库名的格式是<code>用户名/仓库</code>，比如我创建了一个叫做<code>test</code>的仓库，在 PicGo 里我要设定的仓库名就是<code>Molunerfinn/test</code>。</li>
<li>分支: 一般我们选择<code>main</code>分支即可。</li>
<li>设定 Token: 将刚才保存的 Token 粘贴到这里</li>
<li>存储路径是 GitHub 仓库里面的指定目录</li>
<li>点击确定以生效，然后可以点击<code>设为默认图床</code>来确保上传的图床是 GitHub。</li>
</ul>
<h3 id="2-3-使用-cdn-加速"><a href="#2-3-使用-cdn-加速" class="headerlink" title="2.3 使用 cdn 加速"></a>2.3 使用 cdn 加速</h3><h4 id="2-3-1-cdn-简介"><a href="#2-3-1-cdn-简介" class="headerlink" title="2.3.1 cdn 简介"></a>2.3.1 cdn 简介</h4><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240612151908.png" alt="cdn分发原理图"></p>
<ul>
<li><p>CDN 全称 Content Delivery Network 即内容分发网络，是一组分布在多个不同地方的 WEB 服务器，会根据用户距离的远近来选择最近的服务器 。</p>
</li>
<li><p>是一个免费、快速和可信赖的 CDN 加速服务，声称它每个月可以支撑 680 亿次的请求。服务在 Github 上是开源的。</p>
</li>
<li><p>只要我们的项目中用到了第三方的静态资源，譬如 JavaScript 脚本，css 样式表，图片，图标，Flash 等静态资源文件都应该考虑接入到 CDN 中</p>
</li>
<li><p>jsDelivr + Github 便是免费且好用的 CDN，非常适合博客网站使用</p>
</li>
</ul>
<h4 id="2-3-2-cdn-使用"><a href="#2-3-2-cdn-使用" class="headerlink" title="2.3.2 cdn 使用"></a>2.3.2 cdn 使用</h4><p>通过如下地址应用资源</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径</span><br></pre></td></tr></table></figure>

<p>举个栗子,获取 source&#x2F;bgimg 路径下的 back-rain.png</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">https://cdn.jsdelivr.net/gh/xiezhr/mycdn/source/bgimg/back-rain.png       ## 获取最新资源</span><br><span class="line">https://cdn.jsdelivr.net/gh/xiezhr/mycdn@1.0/source/bgimg/back-rain.png   ## 获取1.0版本的资源</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong> 版本号不是必需的，是为了区分新旧资源</p>
<h4 id="2-3-3-使用-cdn-加速-PicGo-中的静态资源"><a href="#2-3-3-使用-cdn-加速-PicGo-中的静态资源" class="headerlink" title="2.3.3 使用 cdn 加速 PicGo 中的静态资源"></a>2.3.3 使用 cdn 加速 PicGo 中的静态资源</h4><p>PicGo -&gt; 设置自定义域名</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main</span><br></pre></td></tr></table></figure>

<h3 id="2-4-上传图片"><a href="#2-4-上传图片" class="headerlink" title="2.4 上传图片"></a>2.4 上传图片</h3><p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/image-20240612122804700.png" alt="image-20240612122804700"></p>
<p>至此配置完毕，已经可以使用了。当你上传的时候，你会发现你的仓库里也会增加新的图片了</p>
<h3 id="2-5-编辑相册的图片信息"><a href="#2-5-编辑相册的图片信息" class="headerlink" title="2.5 编辑相册的图片信息"></a>2.5 编辑相册的图片信息</h3><p>选择相册</p>
<p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/image-20240612122946564.png" alt="image-20240612122946564"></p>
<p>选择复制的链接格式</p>
<p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/image-20240612123028558.png" alt="image-20240612123028558"></p>
<h2 id="三、配置-Typora"><a href="#三、配置-Typora" class="headerlink" title="三、配置 Typora"></a>三、配置 Typora</h2><p>Typora 偏好设置 -&gt; 图像</p>
<ol>
<li>插入图片时，选择上传图片，对本地图片应用上述规则</li>
<li>上传服务: 选择 PicGo（app）</li>
<li>PicGo 路径: 选择安装路径</li>
<li>验证: 验证图片上传选项</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/image-20240612140917028.png" alt="image-20240612140917028"></p>
<p>总结: github+picGo+typora 他们三个是好基友</p>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><ul>
<li><a href="https://picgo.github.io/PicGo-Doc/zh/guide/config.html">PicGo 配置手册</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/489236769">使用 Github+picGo 搭建图床，保姆级教程</a></li>
<li><a href="https://www.cnblogs.com/xiezhr/p/17343616.html">如何使用 jsDelivr+Github 实现免费 CDN 加速?</a></li>
</ul>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>图床</tag>
      </tags>
  </entry>
  <entry>
    <title>008_vscode插件推荐</title>
    <url>/2024/06/17/008_vscode%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/</url>
    <content><![CDATA[<p>自用 vscode 插件推荐</p>
<span id="more"></span>

<table>
<thead>
<tr>
<th>类别</th>
<th>插件名称</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><strong>开发语言与框架</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>C&#x2F;C++</td>
<td>C&#x2F;C++ Extension Pack</td>
<td>包含 C&#x2F;C++, C&#x2F;C++ Themes, CMake, CMake Tools</td>
</tr>
<tr>
<td></td>
<td>C&#x2F;C++</td>
<td>C++ 编译、调试 (需提前安装编译器, 如 MinGW)</td>
</tr>
<tr>
<td></td>
<td>CMake</td>
<td>语法高亮, 代码补全</td>
</tr>
<tr>
<td></td>
<td>CMake Tools</td>
<td>CMake 工具包</td>
</tr>
<tr>
<td>Rust</td>
<td>rust-analyzer</td>
<td>Rust 语言支持</td>
</tr>
<tr>
<td><strong>开发工具</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>路径智能提示</td>
<td>Path Intellisense</td>
<td>文件路径自动补全</td>
</tr>
<tr>
<td>文档编辑</td>
<td>Markdown All in One</td>
<td>Markdown 全功能支持</td>
</tr>
<tr>
<td>版本控制</td>
<td>GitLens</td>
<td>增强的 Git 功能，查看修改历史，Git blame</td>
</tr>
<tr>
<td></td>
<td>SVN</td>
<td>Subversion 版本控制支持</td>
</tr>
<tr>
<td></td>
<td>SVN Lens</td>
<td>SVN blame 功能</td>
</tr>
<tr>
<td>远程开发</td>
<td>Remote - SSH</td>
<td>通过 SSH 进行远程开发</td>
</tr>
<tr>
<td>容器化</td>
<td>Docker</td>
<td>Docker 容器支持</td>
</tr>
<tr>
<td>虚拟化</td>
<td>WSL</td>
<td>Windows Subsystem for Linux 支持</td>
</tr>
<tr>
<td>数据库</td>
<td>SQLite</td>
<td>SQLite 数据库支持</td>
</tr>
<tr>
<td><strong>效率工具</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>项目管理</td>
<td>Project Manager</td>
<td>快速切换项目，支持标签</td>
</tr>
<tr>
<td>AI IDE</td>
<td>Cursor</td>
<td>智能 IDE</td>
</tr>
<tr>
<td>AI 代码补全</td>
<td>Codeium</td>
<td>智能代码补全</td>
</tr>
<tr>
<td>代码运行</td>
<td>Code Runner</td>
<td>快速运行各种语言的代码片段</td>
</tr>
<tr>
<td><strong>界面美化</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>本地化</td>
<td>Chinese (Simplified)</td>
<td>简体中文界面</td>
</tr>
<tr>
<td>图标主题</td>
<td>Material Icon Theme</td>
<td>美化文件图标</td>
</tr>
<tr>
<td>颜色主题</td>
<td>Night Owl</td>
<td>深色主题</td>
</tr>
<tr>
<td></td>
<td>One Dark Pro</td>
<td>另一款流行的深色主题</td>
</tr>
<tr>
<td><strong>代码质量</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>代码格式化</td>
<td>Prettier</td>
<td>支持多种语言的代码格式化</td>
</tr>
<tr>
<td></td>
<td>markdownlint</td>
<td>Markdown 语法检查和格式化</td>
</tr>
<tr>
<td><strong>可视化工具</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>JSON 可视化</td>
<td>JSON Crack</td>
<td>JSON 数据可视化工具</td>
</tr>
<tr>
<td>思维导图</td>
<td>markmap</td>
<td>将 Markdown 转换为思维导图</td>
</tr>
<tr>
<td>PDF 阅读</td>
<td>vscode-pdf</td>
<td>PDF 阅读工具</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>009_使用vscode调试rust项目</title>
    <url>/2024/06/20/009_%E4%BD%BF%E7%94%A8vscode%E8%B0%83%E8%AF%95rust%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p>windows 下, 使用 vscode 调试 rust 项目</p>
<p>工具: vscode, rust-analyzer 插件, rust 环境</p>
<span id="more"></span>

<ul>
<li><p>安装 vscode 插件: rust-analyzer</p>
</li>
<li><p>创建 rust 项目</p>
<ul>
<li>终端输入命令 <code>cargo new ProjectName</code></li>
</ul>
</li>
<li><p>使用<code>cargo run</code>或者<code>cargo build</code>命令编译项目, 生成可执行文件<code>target/debug/ProjectName.exe</code></p>
<p>注意: 必须编译通过生成可执行文件后才能进行 debug</p>
</li>
<li><p>创建 launch.json 文件</p>
<ul>
<li><p>debug 点击创建 launch.json 文件<br><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240620164934.png" alt="创建 launch.json文件"></p>
</li>
<li><p>调试器选择 LLDB (rust 调试器为 LLDB)</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240620165044.png" alt="调试器选择LLDB"></p>
<ul>
<li>选择 yes, 调试环境会自动配置好</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240620165225.png" alt="选择yes"></p>
</li>
<li><p>设置断点</p>
</li>
<li><p>F5 或者 运行-&gt;终端-&gt;开启调试</p>
</li>
<li><p>在左侧查看 debug 的变量和堆栈<br><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240620150545.png" alt="debug结果"></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>vscode</tag>
        <tag>rust</tag>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title>011_Linux配置依赖环境</title>
    <url>/2024/06/25/011_Linux%E9%85%8D%E7%BD%AE%E4%BE%9D%E8%B5%96%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>Linux 依赖各种库，有的是项目文件夹 lib 里面已经有了，有的需要安装。本文介绍了在 WSL2 编译一个项目遇到的环境问题。在一天半的时间尝试下，终于解决了，记录下解决的过程。</p>
<span id="more"></span>

<h2 id="配置-Linux-依赖"><a href="#配置-Linux-依赖" class="headerlink" title="配置 Linux 依赖"></a>配置 Linux 依赖</h2><h3 id="查找库或依赖"><a href="#查找库或依赖" class="headerlink" title="查找库或依赖"></a>查找库或依赖</h3><ol>
<li><p><strong>使用包管理工具</strong>：</p>
<ul>
<li><p>在 Debian 或 Ubuntu 系统上，可以使用<code>apt-cache search</code>命令查找库。例如，要查找包含“mat”关键字的库：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apt-cache search mat</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 CentOS 或 Red Hat 系统上，可以使用<code>yum search</code>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum search mat</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>使用<code>ldconfig</code>命令</strong>：</p>
<ul>
<li><p><code>ldconfig</code>命令用于配置和管理共享库的符号链接和缓存。</p>
</li>
<li><p>可以使用<code>ldconfig -p | grep libmat</code>命令查看系统中已知的库：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ldconfig -p | grep libmat</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>手动查找</strong>：</p>
<ul>
<li><p>使用<code>find</code>或<code>locate</code>命令在系统中搜索特定的库文件。例如，查找<code>libmat.so</code>：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">find / -name libmat.so 2&gt;/dev/null</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">locate libmat</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="设置路径"><a href="#设置路径" class="headerlink" title="设置路径"></a>设置路径</h3><ol>
<li><p><strong>编译时设置库路径</strong>：</p>
<ul>
<li><p>使用<code>-L</code>选项指定库文件所在的目录。例如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gcc -o your_program your_program.c -L/path/to/library -lmat</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>运行时设置库路径</strong>：</p>
<ul>
<li><p>设置<code>LD_LIBRARY_PATH</code>环境变量以包括库文件所在的目录。例如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/path/to/library:<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将上述命令添加到<code>.bashrc</code>或<code>.bash_profile</code>文件中以使其在每次终端启动时生效：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export LD_LIBRARY_PATH=/path/to/library:$LD_LIBRARY_PATH&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>使用<code>ldconfig</code>配置共享库</strong>：</p>
<ul>
<li><p>将库文件路径添加到系统的共享库配置中。编辑或创建文件<code>/etc/ld.so.conf.d/custom_libs.conf</code>，添加库路径：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/path/to/library</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后运行<code>ldconfig</code>命令更新缓存：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>假设你在<code>/home/user/libs</code>目录下有<code>libmat.so</code>和<code>libmx.so</code>库文件，并且需要在编译和运行时使用这些库。</p>
<ol>
<li><p><strong>编译时设置路径</strong>：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gcc -o my_program my_program.c -L/home/user/libs -lmat -lmx</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>运行时设置路径</strong>：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/home/user/libs:<span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line">./my_program</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>永久设置路径</strong>：<br>编辑<code>~/.bashrc</code>文件，添加以下行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/home/user/libs:<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure>

<p>然后运行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure></li>
</ol>
<p>通过以上步骤，你可以查找和配置所需的库路径，确保程序能够正确链接和运行。</p>
<h2 id="安装的库版本不匹配"><a href="#安装的库版本不匹配" class="headerlink" title="安装的库版本不匹配"></a>安装的库版本不匹配</h2><p>根据您提供的信息，链接器无法找到<code>libjsoncpp.so.1</code>，而是找到了其他版本的<code>libjsoncpp.so</code>。这是因为系统上安装的<code>libjsoncpp</code>库版本不匹配。您可以通过以下步骤解决这个问题：</p>
<h3 id="解决方案-1：使用-rpath或-rpath-link"><a href="#解决方案-1：使用-rpath或-rpath-link" class="headerlink" title="解决方案 1：使用-rpath或-rpath-link"></a>解决方案 1：使用<code>-rpath</code>或<code>-rpath-link</code></h3><p>您可以在链接时使用<code>-rpath</code>或<code>-rpath-link</code>选项来指定库的路径。</p>
<p>假设您的库文件在<code>/usr/lib/x86_64-Linux-gnu</code>目录下，可以这样做：</p>
<ol>
<li><p>修改您的编译命令以包含<code>-Wl,-rpath,/usr/lib/x86_64-Linux-gnu</code></p>
</li>
<li><p>或者在 CMakeLists.txt 文件中设置链接器路径：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_INSTALL_RPATH <span class="string">&quot;/usr/lib/x86_64-Linux-gnu&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="解决方案-2：创建符号链接"><a href="#解决方案-2：创建符号链接" class="headerlink" title="解决方案 2：创建符号链接"></a>解决方案 2：创建符号链接</h3><p>如果您需要的<code>libjsoncpp.so.1</code>确实存在于不同的位置，可以创建一个符号链接以便系统能够找到它。</p>
<ol>
<li><p>创建符号链接：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">ln</span> -s /usr/lib/x86_64-Linux-gnu/libjsoncpp.so.1.9.5 /usr/lib/x86_64-Linux-gnu/libjsoncpp.so.1</span><br></pre></td></tr></table></figure>

<p>如果使用<code>locate</code>定位不到新建的包, 更新 locate 数据库运行以下命令来更新 locate 数据库：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo updatedb</span><br></pre></td></tr></table></figure>

<p>然后再次运行 locate 命令</p>
</li>
</ol>
<h3 id="解决方案-3：安装正确版本的库"><a href="#解决方案-3：安装正确版本的库" class="headerlink" title="解决方案 3：安装正确版本的库"></a>解决方案 3：安装正确版本的库</h3><p>如果库的版本不匹配，您可以尝试安装正确版本的<code>libjsoncpp</code>。</p>
<ol>
<li><p>更新包管理器并安装正确的版本：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install libjsoncpp1</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="解决方案-4：指定库路径"><a href="#解决方案-4：指定库路径" class="headerlink" title="解决方案 4：指定库路径"></a>解决方案 4：指定库路径</h3><p>确保在链接器中指定正确的库路径。在编译时添加正确的路径：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">g++ -o your_program your_program.cpp -L/usr/lib/x86_64-Linux-gnu -ljsoncpp</span><br></pre></td></tr></table></figure>

<h3 id="解决方案-5：环境变量"><a href="#解决方案-5：环境变量" class="headerlink" title="解决方案 5：环境变量"></a>解决方案 5：环境变量</h3><p>通过设置环境变量<code>LD_LIBRARY_PATH</code>来指定库的路径：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/usr/lib/x86_64-Linux-gnu:<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure>

<p>将上述命令添加到<code>.bashrc</code>文件中，以便每次启动终端时都生效：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export LD_LIBRARY_PATH=/usr/lib/x86_64-Linux-gnu:$LD_LIBRARY_PATH&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>通过这些步骤，您应该能够解决链接器找不到<code>libjsoncpp.so.1</code>的问题并成功编译您的程序。</p>
<h2 id="Q-A"><a href="#Q-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ol>
<li><p>shell 脚本文件没有可执行权限</p>
<p>matlab.sh 负责将 matlab 所用的库拷贝到&#x2F;build&#x2F;lib 文件夹, 这里发现 matlab.sh 并没有执行, 增加可执行权限后正常执行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">root@DESKTOP-S5NII96:/home/guo/code/WT328/api<span class="comment"># ./matlab.sh</span></span><br><span class="line">bash: ./matlab.sh: Permission denied</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装的软件版本不匹配</p>
<p>手动复制一份并重命名为所需软件(不行)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> /usr/lib/x86_64-Linux-gnu/libjsoncpp.so.1.9.5 /usr/lib/x86_64-Linux-gnu/libjsoncpp.so.1</span><br></pre></td></tr></table></figure>

<p>增加软链接(手动增加软连接无效)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">root@DESKTOP-S5NII96:/home/guo/code/WT328/source<span class="comment"># ls -l /usr/lib/x86_64-Linux-gnu/libjson*</span></span><br><span class="line">lrwxrwxrwx 1 root root     18 Aug 24  2023 /usr/lib/x86_64-Linux-gnu/libjson-c.so.5 -&gt; libjson-c.so.5.1.0</span><br><span class="line">-rw-r--r-- 1 root root  72080 Aug 24  2023 /usr/lib/x86_64-Linux-gnu/libjson-c.so.5.1.0</span><br><span class="line">lrwxrwxrwx 1 root root     16 Jan 30  2022 /usr/lib/x86_64-Linux-gnu/libjsoncpp.so -&gt; libjsoncpp.so.25</span><br><span class="line">-rwxrwxrwx 1 root root 215792 Jun 24 15:57 /usr/lib/x86_64-Linux-gnu/libjsoncpp.so.1</span><br><span class="line">-rw-r--r-- 1 root root 215792 Jan 30  2022 /usr/lib/x86_64-Linux-gnu/libjsoncpp.so.1.9.5</span><br><span class="line">lrwxrwxrwx 1 root root     19 Jan 30  2022 /usr/lib/x86_64-Linux-gnu/libjsoncpp.so.25 -&gt; libjsoncpp.so.1.9.5</span><br></pre></td></tr></table></figure>

<p>检查报错地方的依赖，能找到啊！！！怎么还报错呢</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">root@DESKTOP-S5NII96:/home/guo/code/WT328/source<span class="comment"># ldd /home/guo/code/WT328/source/../extlib/lib/libwt-calibration.so</span></span><br><span class="line"></span><br><span class="line">Linux-vdso.so.1 (0x00007fffab961000)</span><br><span class="line">libjsoncpp.so.1 =&gt; /lib/x86_64-Linux-gnu/libjsoncpp.so.1 (0x00007f466786a000)</span><br><span class="line">libstdc++.so.6 =&gt; /lib/x86_64-Linux-gnu/libstdc++.so.6 (0x00007f466763e000)</span><br><span class="line">libgcc_s.so.1 =&gt; /lib/x86_64-Linux-gnu/libgcc_s.so.1 (0x00007f466761e000)</span><br><span class="line">libpthread.so.0 =&gt; /lib/x86_64-Linux-gnu/libpthread.so.0 (0x00007f4667619000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-Linux-gnu/libc.so.6 (0x00007f46673f0000)</span><br><span class="line">libm.so.6 =&gt; /lib/x86_64-Linux-gnu/libm.so.6 (0x00007f4667309000)</span><br><span class="line">/lib64/ld-Linux-x86-64.so.2 (0x00007f4667922000)</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">root@DESKTOP-S5NII96:/home/guo/code/WT328/source<span class="comment"># locate libjsoncpp</span></span><br><span class="line"></span><br><span class="line">/usr/lib/x86_64-Linux-gnu/libjsoncpp.so</span><br><span class="line">/usr/lib/x86_64-Linux-gnu/libjsoncpp.so.1</span><br><span class="line">/usr/lib/x86_64-Linux-gnu/libjsoncpp.so.1.9.5</span><br><span class="line">/usr/lib/x86_64-Linux-gnu/libjsoncpp.so.25</span><br><span class="line">/usr/share/doc/libjsoncpp-dev</span><br><span class="line">/usr/share/doc/libjsoncpp25</span><br><span class="line">/usr/share/doc/libjsoncpp-dev/changelog.Debian.gz</span><br><span class="line">/usr/share/doc/libjsoncpp-dev/copyright</span><br><span class="line">/usr/share/doc/libjsoncpp25/README.Debian</span><br><span class="line">/usr/share/doc/libjsoncpp25/README.md</span><br><span class="line">/usr/share/doc/libjsoncpp25/changelog.Debian.gz</span><br><span class="line">/usr/share/doc/libjsoncpp25/copyright</span><br><span class="line">/var/lib/dpkg/info/libjsoncpp-dev:amd64.list</span><br><span class="line">/var/lib/dpkg/info/libjsoncpp-dev:amd64.md5sums</span><br><span class="line">/var/lib/dpkg/info/libjsoncpp25:amd64.list</span><br><span class="line">/var/lib/dpkg/info/libjsoncpp25:amd64.md5sums</span><br><span class="line">/var/lib/dpkg/info/libjsoncpp25:amd64.shlibs</span><br><span class="line">/var/lib/dpkg/info/libjsoncpp25:amd64.triggers</span><br><span class="line">root@DESKTOP-S5NII96:/home/guo/code/WT328/source<span class="comment"># ^C</span></span><br><span class="line">root@DESKTOP-S5NII96:/home/guo/code/WT328/source<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/usr/bin/ld: /home/guo/code/WT328/source/../extlib/lib/libwt-calibration.so: undefined reference to  Json::Value::operator=(Json::Value)</span><br><span class="line">collect2: error: ld returned 1 <span class="built_in">exit</span> status</span><br><span class="line">make[1]: ***[/home/guo/code/WT328/source/base.mk:15: /home/guo/code/WT328/source/bin/WT-Manager] Error 1</span><br><span class="line">make[1]: Leaving directory /home/guo/code/WT328/source/manager</span><br><span class="line">make:*** [Makefile:85: all] Error 1</span><br></pre></td></tr></table></figure>

<p>可能是库有问题，这个版本的没有<code>Json::Value::operator=(Json::Value)</code></p>
<p>明天试试装 1.7.4 的版本</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">// 卸载1.9.5版本</span><br><span class="line">dpkg --list</span><br><span class="line"></span><br><span class="line">sudo apt-get remove software</span><br><span class="line"></span><br><span class="line">// qinghua下载指定版本deb包</span><br><span class="line">// libjsoncpp1_1.7.4-3_amd64.deb 和 libjsoncpp-dev_1.7.4-3_amd64.deb</span><br><span class="line"></span><br><span class="line">// 安装</span><br><span class="line">root@DESKTOP-S5NII96:/home/guo/code<span class="comment"># dpkg -i libjsoncpp1_1.7.4-3_amd64.deb</span></span><br><span class="line"></span><br><span class="line">Selecting previously unselected package libjsoncpp1:amd64.</span><br><span class="line">(Reading database ... 49184 files and directories currently installed.)</span><br><span class="line">Preparing to unpack libjsoncpp1_1.7.4-3_amd64.deb ...</span><br><span class="line">Unpacking libjsoncpp1:amd64 (1.7.4-3) ...</span><br><span class="line">Setting up libjsoncpp1:amd64 (1.7.4-3) ...</span><br><span class="line">Processing triggers <span class="keyword">for</span> libc-bin (2.35-0ubuntu3.4) ...</span><br><span class="line">root@DESKTOP-S5NII96:/home/guo/code<span class="comment"># dpkg -i libjsoncpp-dev_1.7.4-3_amd64.deb</span></span><br><span class="line">Selecting previously unselected package libjsoncpp-dev:amd64.</span><br><span class="line">(Reading database ... 49193 files and directories currently installed.)</span><br><span class="line">Preparing to unpack libjsoncpp-dev_1.7.4-3_amd64.deb ...</span><br><span class="line">Unpacking libjsoncpp-dev:amd64 (1.7.4-3) ...</span><br><span class="line">Setting up libjsoncpp-dev:amd64 (1.7.4-3) ...</span><br><span class="line"></span><br><span class="line">// 查看效果</span><br><span class="line">root@DESKTOP-S5NII96:/usr/lib/x86_64-Linux-gnu<span class="comment"># ls -l |grep libjsonc</span></span><br><span class="line"></span><br><span class="line">-rw-r--r--  1 root root   372584 Aug 23  2016 libjsoncpp.a</span><br><span class="line">lrwxrwxrwx  1 root root       15 Aug 23  2016 libjsoncpp.so -&gt; libjsoncpp.so.1</span><br><span class="line">lrwxrwxrwx  1 root root       19 Aug 23  2016 libjsoncpp.so.1 -&gt; libjsoncpp.so.1.7.4</span><br><span class="line">-rw-r--r--  1 root root   203464 Aug 23  2016 libjsoncpp.so.1.7.4</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">// 编译服务器里面的依赖</span><br><span class="line">root@wt400:/home/j00503/Code/WT328/source/bin<span class="comment"># ldd libgeneral.so</span></span><br><span class="line"></span><br><span class="line">Linux-vdso.so.1 (0x00007ffe8c14c000)</span><br><span class="line">libjsoncpp.so.1 =&gt; /lib/x86_64-Linux-gnu/libjsoncpp.so.1 (0x00007f7cfb129000)</span><br><span class="line">libwt-calibration.so =&gt; not found</span><br><span class="line">libwt-crypto.so =&gt; not found</span><br><span class="line">libft4222.so =&gt; not found</span><br><span class="line">libAlg3gppVsa.so =&gt; not found</span><br><span class="line">libAlg3gppVsg.so =&gt; not found</span><br><span class="line">libAlgVsa.so =&gt; not found</span><br><span class="line">libAlgVsaGle.so =&gt; not found</span><br><span class="line">libAlgVsaSlb.so =&gt; not found</span><br><span class="line">libAlgVsaWifi11az.so =&gt; not found</span><br><span class="line">libAlgVsg.so =&gt; not found</span><br><span class="line">libAlgVsgGle.so =&gt; not found</span><br><span class="line">libAlgVsgSlb.so =&gt; not found</span><br><span class="line">libAlgVsgWifi11ah.so =&gt; not found</span><br><span class="line">libWT-Debug-Mem.so =&gt; not found</span><br><span class="line">libsqlite3.so.0 =&gt; /lib/x86_64-Linux-gnu/libsqlite3.so.0 (0x00007f7cfaffc000)</span><br><span class="line">libstdc++.so.6 =&gt; /lib/x86_64-Linux-gnu/libstdc++.so.6 (0x00007f7cfae1a000)</span><br><span class="line">libm.so.6 =&gt; /lib/x86_64-Linux-gnu/libm.so.6 (0x00007f7cfaccb000)</span><br><span class="line">libgcc_s.so.1 =&gt; /lib/x86_64-Linux-gnu/libgcc_s.so.1 (0x00007f7cfacae000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-Linux-gnu/libc.so.6 (0x00007f7cfaabc000)</span><br><span class="line">/lib64/ld-Linux-x86-64.so.2 (0x00007f7cfb806000)</span><br><span class="line">libpthread.so.0 =&gt; /lib/x86_64-Linux-gnu/libpthread.so.0 (0x00007f7cfaa99000)</span><br><span class="line">libdl.so.2 =&gt; /lib/x86_64-Linux-gnu/libdl.so.2 (0x00007f7cfaa93000)</span><br><span class="line"></span><br><span class="line">root@wt400:/home/j00503/Code/WT328/source/bin<span class="comment"># ldd /lib/x86_64-Linux-gnu/libjsoncpp.so.1</span></span><br><span class="line">Linux-vdso.so.1 (0x00007ffce2ad4000)</span><br><span class="line">libstdc++.so.6 =&gt; /lib/x86_64-Linux-gnu/libstdc++.so.6 (0x00007f3dde1ae000)</span><br><span class="line">libm.so.6 =&gt; /lib/x86_64-Linux-gnu/libm.so.6 (0x00007f3dde05f000)</span><br><span class="line">libgcc_s.so.1 =&gt; /lib/x86_64-Linux-gnu/libgcc_s.so.1 (0x00007f3dde044000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-Linux-gnu/libc.so.6 (0x00007f3ddde52000)</span><br><span class="line">/lib64/ld-Linux-x86-64.so.2 (0x00007f3dde3db000)</span><br><span class="line"></span><br><span class="line">root@wt400:/home/j00503/Code/WT328/source/bin<span class="comment"># ls -l /lib/x86_64-Linux-gnu/libjsoncpp*</span></span><br><span class="line">-rw-r--r-- 1 root root 436438 3月  21  2020 /lib/x86_64-Linux-gnu/libjsoncpp.a</span><br><span class="line">lrwxrwxrwx 1 root root     15 3月  21  2020 /lib/x86_64-Linux-gnu/libjsoncpp.so -&gt; libjsoncpp.so.1</span><br><span class="line">lrwxrwxrwx 1 root root     19 3月  21  2020 /lib/x86_64-Linux-gnu/libjsoncpp.so.1 -&gt; libjsoncpp.so.1.7.4</span><br><span class="line">-rw-r--r-- 1 root root 215840 3月  21  2020 /lib/x86_64-Linux-gnu/libjsoncpp.so.1.7.4</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240625095531.png" alt="WSL2"></p>
<p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240625095607.png" alt="编译服务器"></p>
<p>又发现了 cmake 失效</p>
<p>cmake 依赖于<code>libjsoncpp.so.25</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">// 手动安装 libjsoncpp25 并使用 1.9.5-3 版本</span><br><span class="line">root@DESKTOP-S5NII96:/home/guo<span class="comment"># dpkg -i ./libjsoncpp25_1.9.5-3_amd64.deb</span></span><br><span class="line">(Reading database ... 49218 files and directories currently installed.)</span><br><span class="line">Preparing to unpack .../libjsoncpp25_1.9.5-3_amd64.deb ...</span><br><span class="line">Unpacking libjsoncpp25:amd64 (1.9.5-3) over (1.9.5-3) ...</span><br><span class="line">Setting up libjsoncpp25:amd64 (1.9.5-3) ...</span><br><span class="line">Processing triggers <span class="keyword">for</span> libc-bin (2.35-0ubuntu3.8) ...</span><br><span class="line"></span><br><span class="line">// cmake正常使用</span><br><span class="line">root@DESKTOP-S5NII96:/home/guo<span class="comment"># cmake</span></span><br><span class="line">Usage</span><br><span class="line">cmake [options] &lt;path-to-source&gt;</span><br><span class="line">cmake [options] &lt;path-to-existing-build&gt;</span><br><span class="line">cmake [options] -S &lt;path-to-source&gt; -B &lt;path-to-build&gt;</span><br><span class="line">Specify a <span class="built_in">source</span> directory to (re-)generate a build system <span class="keyword">for</span> it <span class="keyword">in</span> the</span><br><span class="line">current working directory.  Specify an existing build directory to</span><br><span class="line">re-generate its build system.</span><br><span class="line">Run <span class="string">&#x27;cmake --help&#x27;</span> <span class="keyword">for</span> more information.</span><br><span class="line"></span><br><span class="line">// 先安装 libjsoncpp.so.1.9.5 和 libjsoncpp25，cmake正常使用</span><br><span class="line">// <span class="built_in">source</span>编译还是报找不到libjsoncpp.so.1的错误</span><br><span class="line">root@DESKTOP-S5NII96:/usr/lib/x86_64-Linux-gnu<span class="comment"># ls -l libjsoncpp*</span></span><br><span class="line">lrwxrwxrwx 1 root root     16 Jan 30  2022 libjsoncpp.so -&gt; libjsoncpp.so.25</span><br><span class="line">-rw-r--r-- 1 root root 215792 Jan 30  2022 libjsoncpp.so.1.9.5</span><br><span class="line">lrwxrwxrwx 1 root root     19 Jan 30  2022 libjsoncpp.so.25 -&gt; libjsoncpp.so.1.9.5</span><br></pre></td></tr></table></figure>

<p>再次安装<code>libjsoncpp1_1.7.4-3_amd64.deb</code>, 编译 source 正常</p>
<p>总结:</p>
<ol>
<li><p>需要安装 3 个软件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">libjsoncpp-dev // 当前最新是 1.9.5 版本</span><br><span class="line">libjsoncpp25_1.9.5-3_amd64.deb // 对应上面的最新版本</span><br><span class="line">libjsoncpp1_1.7.4-3_amd64.deb // 安装 libjsoncpp1，安装1.7.4版本，后面没有更新了</span><br><span class="line"></span><br><span class="line">// 当前效果</span><br><span class="line">root@DESKTOP-S5NII96:/usr/lib/x86_64-Linux-gnu<span class="comment"># ls -l libjsoncpp*</span></span><br><span class="line"></span><br><span class="line">lrwxrwxrwx 1 root root     16 Jan 30  2022 libjsoncpp.so -&gt; libjsoncpp.so.25</span><br><span class="line">lrwxrwxrwx 1 root root     19 Aug 23  2016 libjsoncpp.so.1 -&gt; libjsoncpp.so.1.7.4</span><br><span class="line">-rw-r--r-- 1 root root 203464 Aug 23  2016 libjsoncpp.so.1.7.4</span><br><span class="line">-rw-r--r-- 1 root root 215792 Jan 30  2022 libjsoncpp.so.1.9.5</span><br><span class="line">lrwxrwxrwx 1 root root     19 Jan 30  2022 libjsoncpp.so.25 -&gt; libjsoncpp.so.1.9.5</span><br></pre></td></tr></table></figure>
</li>
<li><p>手动设置软连接是无效的, 本因是需要装三个软件</p>
</li>
<li><p>手动安装软件包。在清华源里面查找对应包，下载下来，使用<code>dpkg -i a.deb</code>来安装 &#x2F;&#x2F; 假设 a 为软件包名</p>
</li>
<li><p>卸载软件包 <code>sudo apt remove a</code></p>
</li>
<li><p>定位软件包 <code>locate a</code></p>
</li>
<li><p>更新<code>locate</code>用 <code>updatedb</code></p>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>012_修改wsl环境下的docker container 端口</title>
    <url>/2024/09/19/012_%E4%BF%AE%E6%94%B9wsl%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84docker%20container%20%E7%AB%AF%E5%8F%A3/</url>
    <content><![CDATA[<p>wsl 下, 修改已创建容器的端口</p>
<p>工具: wsl, docker</p>
<span id="more"></span>

<p>路径: <code>\\wsl.localhost\docker-desktop-data\data\docker\containers\</code></p>
<p>容器文件名参考 <code>docker desktop</code> 的容器名下的序列号</p>
<p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240919100031.png" alt="容器文件名"></p>
<p>修改文件: <code>hostconfig.json</code> 中的 <code>PortBindings</code> 的 <code>HostPort</code></p>
<p>重启 <code>docker desktop</code>, 注意需要退出后再开启, 不能仅 restart docker, 否则修改被抹除</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>010_wsl2使用介绍</title>
    <url>/2024/06/21/010_wsl2%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>适用于 Linux 的 Windows 子系统 (WSL) 是 Windows 的一项功能，可用于在 Windows 计算机上运行 Linux 环境，而无需单独的虚拟机或双引导。 WSL 旨在为希望同时使用 Windows 和 Linux 的开发人员提供无缝高效的体验。比 VMWare 或 Virtual Box 等虚拟机更轻量, 最主要是 Windows 原生支持。</p>
<span id="more"></span>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>开发人员可以在 Windows 计算机上同时访问 Windows 和 Linux 的强大功能。</p>
<ul>
<li><a href="https://learn.microsoft.com/zh-cn/windows/wsl/install#step-1---enable-the-windows-subsystem-for-linux">安装 WSL2</a></li>
</ul>
<h2 id="管理-Linux"><a href="#管理-Linux" class="headerlink" title="管理 Linux"></a>管理 Linux</h2><p><a href="https://learn.microsoft.com/zh-cn/windows/wsl/basic-commands">WSL 的基本命令</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">安装</span><br><span class="line">将目录更改为主页</span><br><span class="line">Help 命令</span><br><span class="line">以特定用户的身份运行</span><br><span class="line">更改发行版的默认用户</span><br><span class="line">标识 IP 地址</span><br><span class="line">导出分发版</span><br><span class="line">导入分发版</span><br><span class="line">就地导入发行版</span><br><span class="line">装载磁盘或设备</span><br><span class="line">卸载磁盘</span><br><span class="line">已弃用的 WSL 命令</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>功能</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>列出可用(可在线安装)的 Linux 发行版</td>
<td><code>wsl --list --online</code></td>
</tr>
<tr>
<td>列出已安装的 Linux 发行版</td>
<td><code>wsl --list --verbose</code></td>
</tr>
<tr>
<td>安装指定 Linux 发行版</td>
<td><code>wsl --install &lt;Distribution Name&gt;</code></td>
</tr>
<tr>
<td>检查正在运行的 WSL 版本</td>
<td><code>wsl -l -v</code></td>
</tr>
<tr>
<td>将 WSL 版本设置为 1 或 2</td>
<td><code>wsl --set-version &lt;distribution name&gt; &lt;versionNumber&gt;</code></td>
</tr>
<tr>
<td>检查 WSL 版本</td>
<td><code>wsl --version</code></td>
</tr>
<tr>
<td>设置默认版本为 WSL 1 或 WSL 2</td>
<td><code>wsl --set-default-version &lt;Version#&gt;</code>，将 <code>Version#</code> 替换为 1 或 2</td>
</tr>
<tr>
<td>检查 WSL 状态</td>
<td><code>wsl --status</code></td>
</tr>
<tr>
<td>更新 WSL</td>
<td><code>wsl --update</code></td>
</tr>
<tr>
<td>设置默认 Linux 发行版</td>
<td><code>wsl --set-default &lt;Distribution Name&gt;</code></td>
</tr>
<tr>
<td>通过 PowerShell 或 CMD 运行特定的 Linux 发行版</td>
<td><code>wsl --distribution &lt;Distribution Name&gt; --user &lt;User Name&gt;</code></td>
</tr>
<tr>
<td>关闭</td>
<td><code>wsl --shutdown</code></td>
</tr>
<tr>
<td>Terminate</td>
<td><code>wsl --terminate &lt;Distribution Name&gt;</code></td>
</tr>
<tr>
<td>注销或卸载 Linux 发行版</td>
<td><code>wsl --unregister &lt;DistributionName&gt;</code></td>
</tr>
</tbody></table>
<h3 id="设置-Linux-用户名和密码"><a href="#设置-Linux-用户名和密码" class="headerlink" title="设置 Linux 用户名和密码"></a>设置 Linux 用户名和密码</h3><p>参考: <a href="https://learn.microsoft.com/zh-cn/windows/wsl/setup/environment#set-up-your-linux-username-and-password">https://learn.microsoft.com/zh-cn/windows/wsl/setup/environment#set-up-your-linux-username-and-password</a></p>
<h3 id="vscode-中连接-wsl"><a href="#vscode-中连接-wsl" class="headerlink" title="vscode 中连接 wsl"></a>vscode 中连接 wsl</h3><ul>
<li><p>安装 WSL 插件</p>
</li>
<li><p>安装 Remote - SSH 插件</p>
</li>
<li><p>F9 输入<code>WSL</code>, 选择<code>WSL:Connect to WSL using Distro</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240621145853.png" alt="命名面板输入WSL"></p>
</li>
<li><p>选择已安装的版本</p>
<p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240621145749.png" alt="选择已安装的版本"></p>
</li>
<li><p>连接成功后, 打开 wsl 文件夹</p>
<p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240621150828.png" alt="打开wsl文件夹"></p>
</li>
</ul>
<h2 id="Q-A"><a href="#Q-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ul>
<li><p>wsl: 检测到 localhost 代理配置，但未镜像到 WSL。NAT 模式下的 WSL 不支持 localhost 代理。</p>
<ul>
<li><code>wsl.exe --update</code></li>
</ul>
</li>
<li><p>进入不了 root</p>
<ul>
<li>使用 sudo su 进入 root, 账号密码都是创建时的, 即管理员账号</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240621143616.png" alt="使用sudo su进入root"></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>wsl2</tag>
      </tags>
  </entry>
  <entry>
    <title>013_内网穿透工具</title>
    <url>/2024/09/21/013_%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>localtunnel 和 Cloudflare Tunnels 都是内网穿透工具，可以方便快捷的将本地 Localhost 暴露给全世界，无需修改 DNS 和防火墙设置</p>
<span id="more"></span>

<h2 id="localtunnel"><a href="#localtunnel" class="headerlink" title="localtunnel"></a>localtunnel</h2><p>localtunnel 是一款基于 node.js 的内网穿透工具，非常流行，可以方便快捷的将本地 Localhost 暴露给全世界，无需修改 DNS 和防火墙设置</p>
<p>github 地址: <code>https://github.com/localtunnel/localtunnel</code></p>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><ol>
<li><p>安装: <code>npm install -g localtunnel</code></p>
</li>
<li><p>绑定端口: <code>lt --port 8000</code>, 绑定要访问内网服务的端口, 即本地访问该服务的端口</p>
</li>
<li><p>公网 ip:之后会生成一个 https 的公网 ip 地址, 通过该地址可以访问内网</p>
</li>
<li><p>访问密码: 本地访问该 ip, 点击查看密码, 即可看到。从外网访问 ip，并输出密码即可</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20240921095753.png" alt="获取并输入密码"></p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol>
<li>服务关闭后, 外网不可访问, 再次开启后会分配新的 ip</li>
</ol>
<h2 id="Cloudflare-Tunnels"><a href="#Cloudflare-Tunnels" class="headerlink" title="Cloudflare Tunnels"></a>Cloudflare Tunnels</h2><p>Tunnels：如果你想在外网访问家里的设备，又很难申请到公网 IP，就可以使用 Cloudflare Tunnels 实现的免费内网穿透服务，这种方案配置简单，无数量限制、无流量限制</p>
<h2 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h2><p>通过地址转换的方式访问内网，通常涉及使用<strong>网络地址转换（NAT）</strong>和<strong>端口映射</strong>。以下是一些常见的方法：</p>
<h3 id="1-NAT（网络地址转换）"><a href="#1-NAT（网络地址转换）" class="headerlink" title="1. NAT（网络地址转换）"></a>1. <strong>NAT（网络地址转换）</strong></h3><p>NAT 是一种技术，允许多个设备共享一个公共 IP 地址。通过 NAT，内网设备可以通过公网 IP 地址与外部网络通信。NAT 会将内网设备的 IP 地址和端口号转换为公网 IP 地址和端口号。</p>
<h3 id="2-端口映射"><a href="#2-端口映射" class="headerlink" title="2. 端口映射"></a>2. <strong>端口映射</strong></h3><p>端口映射是一种特定的 NAT 类型，它将内网中的特定端口映射到公网 IP 地址的特定端口。这样，外部设备可以通过公网 IP 地址和映射的端口访问内网设备。</p>
<h3 id="3-VPN（虚拟专用网络）"><a href="#3-VPN（虚拟专用网络）" class="headerlink" title="3. VPN（虚拟专用网络）"></a>3. <strong>VPN（虚拟专用网络）</strong></h3><p>VPN 允许远程用户通过安全的方式访问内网。VPN 会创建一个加密的隧道，通过公网将远程用户的连接转发到内网。这种方式不仅提供了访问内网的能力，还增加了安全性。</p>
<h3 id="4-代理服务器"><a href="#4-代理服务器" class="headerlink" title="4. 代理服务器"></a>4. <strong>代理服务器</strong></h3><p>代理服务器可以作为中介，接收外部请求并将其转发到内网设备。这种方式常用于访问内网中的特定服务，如 Web 服务器、数据库等。</p>
<h3 id="5-云服务"><a href="#5-云服务" class="headerlink" title="5. 云服务"></a>5. <strong>云服务</strong></h3><p>使用云服务提供商提供的 NAT 和端口映射功能，可以方便地将内网设备暴露到公网。例如，AWS 提供的 NAT Gateway 和端口映射功能。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>假设你有一个内网中的 Web 服务器，IP 地址为 192.168.1.10，端口号为 8080。你希望通过公网访问这个 Web 服务器，可以通过以下步骤：</p>
<ol>
<li><strong>配置 NAT 和端口映射</strong>：在路由器上配置 NAT 和端口映射，将内网 IP 地址 192.168.1.10 和端口 8080 映射到公网 IP 地址（例如公网 IP 地址为 203.0.113.1）和端口号（例如 8080）。</li>
<li><strong>访问 Web 服务器</strong>：通过公网 IP 地址和端口号访问 Web 服务器，地址为 <code>http://203.0.113.1:8080</code>。</li>
</ol>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>014_rss订阅</title>
    <url>/2024/10/12/014_rss%E8%AE%A2%E9%98%85%20copy/</url>
    <content><![CDATA[<p>rss 可以绕过算法推荐, 并且不遗漏地接收关注的动态, 重新成为订阅的主人</p>
<span id="more"></span>

<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ol>
<li><a href="https://www.inoreader.com/">Inoreader</a></li>
<li><a href="https://github.com/DIYgod/RSSHub">RssHub</a></li>
<li><a href="https://vercel.com/">Vercel</a></li>
</ol>
<h3 id="Inoreader"><a href="#Inoreader" class="headerlink" title="Inoreader"></a>Inoreader</h3><p>多端同步的 rss 阅读器, 亲测是最方便, 最容易同步, 加载源最容易成功的 rss 服务器, 页面也很高大上</p>
<p>包含了网页端、浏览器插件、app</p>
<h3 id="RssHub"><a href="#RssHub" class="headerlink" title="RssHub"></a>RssHub</h3><p>集成了最新的 rss 订阅源, 号称是让每一个网站都能做成 rss 订阅。当前绝大部分的网站都不主动公开 rss 订阅的方式了, RssHub 可以弥补这一点。</p>
<h3 id="Vercel"><a href="#Vercel" class="headerlink" title="Vercel"></a>Vercel</h3><p>很多网站对爬虫源进行了屏蔽, RssHub 也是一种网络爬虫的方式。将 RssHub 部署到自己的服务器, 有了新的域名, 便可以绕过这一层。Vercel 可以部署 RssHub 项目, 从而省去了购买服务器的花销。</p>
<p>Vercel 部署 RssHub 的教程可以参考: <a href="https://cloud.tencent.com/developer/article/2432561">手把手教你用 Vercel 免费部署 RSSHub</a></p>
]]></content>
      <tags>
        <tag>rss</tag>
      </tags>
  </entry>
  <entry>
    <title>015_windows实用工具推荐</title>
    <url>/2024/10/23/015_windows%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/</url>
    <content><![CDATA[<p>windows 实用工具推荐</p>
<span id="more"></span>

<h3 id="Windows-实用工具推荐"><a href="#Windows-实用工具推荐" class="headerlink" title="Windows 实用工具推荐"></a>Windows 实用工具推荐</h3><table>
<thead>
<tr>
<th>分类</th>
<th>工具名称</th>
<th>功能描述</th>
<th>网址</th>
</tr>
</thead>
<tbody><tr>
<td>截图工具</td>
<td>Snipaste</td>
<td>支持截图后贴图，贴图后可继续截图</td>
<td><a href="https://zh.snipaste.com/download.html">https://zh.snipaste.com/download.html</a></td>
</tr>
<tr>
<td>文件管理</td>
<td>Everything</td>
<td>快速文件搜索工具，比 Windows 自带搜索更快</td>
<td><a href="https://www.voidtools.com/zh-cn/downloads/">https://www.voidtools.com/zh-cn/downloads/</a></td>
</tr>
<tr>
<td>系统维护</td>
<td>Geek Uninstaller</td>
<td>卸载软件工具，可彻底清理残留文件</td>
<td></td>
</tr>
<tr>
<td>桌面管理</td>
<td>DeskPins</td>
<td>桌面置顶工具，可置顶任何窗口</td>
<td></td>
</tr>
<tr>
<td>翻译工具</td>
<td>网易有道翻译</td>
<td>多语言翻译工具</td>
<td></td>
</tr>
<tr>
<td>网盘</td>
<td>百度网盘</td>
<td>文件存储与下载</td>
<td></td>
</tr>
<tr>
<td>聊天工具</td>
<td>CleanMyWechat</td>
<td>微信清理工具</td>
<td></td>
</tr>
</tbody></table>
<p>这些工具可以大大提高 Windows 系统的使用效率和体验。根据个人需求，选择合适的工具来优化您的工作流程。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>016_笔记工具推荐</title>
    <url>/2024/10/23/016_%E7%AC%94%E8%AE%B0%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/</url>
    <content><![CDATA[<p>笔记工具推荐</p>
<span id="more"></span>

<h3 id="笔记工具推荐"><a href="#笔记工具推荐" class="headerlink" title="笔记工具推荐"></a>笔记工具推荐</h3><table>
<thead>
<tr>
<th>平台</th>
<th>工具名称</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>windows</td>
<td>vscode</td>
<td>编辑功能强大, 代码管控</td>
</tr>
<tr>
<td>windows</td>
<td>typora</td>
<td>界面优雅, pin 目录后可以快速切换</td>
</tr>
<tr>
<td>windows</td>
<td><del>vnote</del></td>
<td>快速切换, 快速修改, 不够优雅, 配置麻烦</td>
</tr>
<tr>
<td>windows</td>
<td>heynote</td>
<td>程序员笔记</td>
</tr>
<tr>
<td>windows</td>
<td>navicat</td>
<td>数据库</td>
</tr>
<tr>
<td>跨平台</td>
<td>wps</td>
<td>表格</td>
</tr>
<tr>
<td>跨平台</td>
<td>flomo</td>
<td>简短, 方便同步</td>
</tr>
<tr>
<td>跨平台</td>
<td>幕布</td>
<td>思维导图</td>
</tr>
<tr>
<td>跨平台</td>
<td>github</td>
<td>笔记托管</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>017_开发工具推荐</title>
    <url>/2024/10/23/017_%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/</url>
    <content><![CDATA[<p>开发工具推荐</p>
<span id="more"></span>

<h3 id="开发工具推荐"><a href="#开发工具推荐" class="headerlink" title="开发工具推荐"></a>开发工具推荐</h3><table>
<thead>
<tr>
<th>平台</th>
<th>工具名称</th>
<th>功能描述</th>
<th>网址</th>
</tr>
</thead>
<tbody><tr>
<td><strong>IDE</strong></td>
<td>cursor</td>
<td>内置大模型, 完美兼容 vscode</td>
<td></td>
</tr>
<tr>
<td></td>
<td>vscode</td>
<td>插件丰富</td>
<td></td>
</tr>
<tr>
<td><strong>LLM</strong></td>
<td>ChatGPT</td>
<td>客户端</td>
<td></td>
</tr>
<tr>
<td><strong>Git</strong></td>
<td>git</td>
<td>版本控制</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Github Desktop</td>
<td>github 桌面客户端</td>
<td></td>
</tr>
<tr>
<td><strong>比较</strong></td>
<td>Beyond Compare</td>
<td>文件对比</td>
<td></td>
</tr>
<tr>
<td><strong>远程</strong></td>
<td>MobaXterm</td>
<td>远程连接</td>
<td></td>
</tr>
<tr>
<td><strong>数据库</strong></td>
<td>Navicat Premium Lite</td>
<td>数据库管理</td>
<td><a href="https://www.navicat.com.cn/download/navicat-premium-lite">https://www.navicat.com.cn/download/navicat-premium-lite</a></td>
</tr>
<tr>
<td><strong>容器</strong></td>
<td>Docker Desktop</td>
<td>容器化</td>
<td></td>
</tr>
<tr>
<td><strong>代理</strong></td>
<td>clash</td>
<td>代理工具</td>
<td></td>
</tr>
<tr>
<td><strong>抓包</strong></td>
<td>wireshark</td>
<td>抓包工具</td>
<td></td>
</tr>
</tbody></table>
<h3 id="windows-c-环境"><a href="#windows-c-环境" class="headerlink" title="windows c++环境"></a>windows c++环境</h3><ul>
<li>CMake</li>
<li>MinGw</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>018_为什么我们常见的 IP 都是 192.168 开头的</title>
    <url>/2024/10/29/018_%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E5%B8%B8%E8%A7%81%E7%9A%84%20IP%20%E9%83%BD%E6%98%AF%20192.168%20%E5%BC%80%E5%A4%B4%E7%9A%84/</url>
    <content><![CDATA[<p>为什么我们常见的 IP 都是 192.168 开头的</p>
<span id="more"></span>

<h2 id="ip-地址划分"><a href="#ip-地址划分" class="headerlink" title="ip 地址划分"></a>ip 地址划分</h2><p>参考：<a href="https://xiaolincoding.com/network/4_ip/ip_base.html#ip-%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%86%E7%B1%BB">IP 地址的分类</a></p>
<p>互联网诞生之初，IP 地址显得很充裕，于是计算机科学家们设计了分类地址。</p>
<p>IP 地址分类成了 5 种类型，分别是 A 类、B 类、C 类、D 类、E 类。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20241029151149.png" alt="IP 地址的分类"></p>
<p>上图中黄色部分为分类号，用以区分 IP 地址类别。</p>
<h2 id="私网地址划分"><a href="#私网地址划分" class="headerlink" title="私网地址划分"></a>私网地址划分</h2><blockquote>
<p>10.0.0.0–10.255.255.255</p>
<p>172.16.0.0–172.31.255.255</p>
<p>192.168.0.0–192.168.255.255</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/image-20241029144309499.png" alt="私网地址"></p>
<p>除了这三个 ip 地址段为私有 ip 地址外，其它的都为公网 ip。</p>
<p>这些地址已被声明私有化，任何内网中的设备可以任意使用这些地址，但是在这三个范围内的 IP 地址不允许出现在 Internet（外网）上。所以我们平台在内部组网时用的比较多，比如监控项目与公司内部电脑 ip 设置，用的多的就是 192.168.xx。</p>
<p>通常情况下，按照需要容纳的主机数选择私有地址段。家庭网络规模比较小，一个 C 类地址，192.168.1.x 可以容纳 254 个终端，足够使用。</p>
<p>学校或者大型企业可能使用 B 类甚至 A 类作为内部网络的地址段。比如手机上网很可能获取的也是一个 10 开头的内网地址，而不是公网地址。</p>
<h2 id="NAT-地址转换"><a href="#NAT-地址转换" class="headerlink" title="NAT 地址转换"></a>NAT 地址转换</h2><p>私网地址只能在局域网中使用，不同的局域网可以使用同样的私网地址，私网地址是不能出现在互联网上的。那么私网地址如何访问互联网呢？这就需要用到 NAT 地址转换，将内网地址映射到外网地址。</p>
<p>而<strong>NAT 地址转换</strong>它实现内网的 IP 地址与公网的地址之间的相互转换，将大量的内网 IP 地址转换为一个或少量的公网 IP 地址，减少对公网 IP 地址的占用。</p>
<p>家庭网络普遍使用端口映射的方式，NAT 的核心是一张映射表（源 IP 地址，源端口，目的 IP 地址，目的端口），将内网源 IP 地址和端口映射到同一个公网地址的不同端口，如下图所示。</p>
<table>
<thead>
<tr>
<th>内网 IP（源地址:端口）</th>
<th>外网 IP（目标地址:端口）</th>
</tr>
</thead>
<tbody><tr>
<td>192.168.1.55:5566</td>
<td>219.152.168.222:9200</td>
</tr>
<tr>
<td>192.168.1.59:80</td>
<td>219.152.168.222:9201</td>
</tr>
<tr>
<td>192.168.1.59:4465</td>
<td>219.152.168.222:9202</td>
</tr>
</tbody></table>
<p>总之，家庭网络由于网络规模比较小，通常使用了 192.168 开头的私网地址，光猫拨号获取了一个公网地址（或者运营商私网地址），通过 NAT 方式的映射到这个公网地址的不同端口，访问互联网。主要注意的 NAT 模式和路由模式是不同的。</p>
<h2 id="无分类地址-CIDR"><a href="#无分类地址-CIDR" class="headerlink" title="无分类地址 CIDR"></a>无分类地址 CIDR</h2><p>正因为 IP 分类存在许多缺点，所以后面提出了无分类地址的方案，即 CIDR。</p>
<p>这种方式不再有分类地址的概念，32 比特的 IP 地址被划分为两部分，前面是网络号，后面是主机号。</p>
<p>怎么划分网络号和主机号的呢？</p>
<p>表示形式 a.b.c.d&#x2F;x，其中 &#x2F;x 表示前 x 位属于网络号， x 的范围是 0 ~ 32，这就使得 IP 地址更加具有灵活性。</p>
<p>比如 10.100.122.2&#x2F;24，这种地址表示形式就是 CIDR，&#x2F;24 表示前 24 位是网络号，剩余的 8 位是主机号。</p>
<h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><p>子网掩码和 CIDR 是配套使用的，CIDR 表示网络号，子网掩码表示主机号。掩码的意思就是掩盖掉主机号，剩余的就是网络号。</p>
<p>子网掩码和 IP 地址一样，也是 32 比特，左边是网络号，右边是主机号。</p>
<h2 id="网络号和主机号"><a href="#网络号和主机号" class="headerlink" title="网络号和主机号"></a>网络号和主机号</h2><p>网络号和主机号在 IP 地址中有着各自重要的作用，帮助计算机网络有效地传输数据和管理地址。具体来说：</p>
<h3 id="网络号-Network-Part"><a href="#网络号-Network-Part" class="headerlink" title="网络号 (Network Part)"></a>网络号 (Network Part)</h3><ul>
<li><p>定义：网络号是 IP 地址的前一部分，用于标识一个特定的网络。</p>
</li>
<li><p>作用：</p>
<ul>
<li><p>路由：网络设备（如路由器）利用网络号将数据包发送到正确的子网或网络。只需要检查数据包的网络号，就可以决定将其转发到哪个子网。</p>
</li>
<li><p>网络管理：网络号有助于网络管理员管理和组织不同的子网。通过网络号，管理员可以轻松地分配和控制 IP 地址资源。</p>
</li>
</ul>
</li>
</ul>
<h3 id="主机号-Host-Part"><a href="#主机号-Host-Part" class="headerlink" title="主机号 (Host Part)"></a>主机号 (Host Part)</h3><ul>
<li><p>定义：主机号是 IP 地址的后一部分，用于标识网络中的特定设备或节点。</p>
</li>
<li><p>作用：</p>
<ul>
<li><p>设备标识：主机号唯一标识网络中的每一个设备，确保数据包能准确地到达目标设备。</p>
</li>
<li><p>地址分配：在同一子网内，主机号确保每一个设备都有一个独一无二的地址，以避免地址冲突。</p>
</li>
</ul>
</li>
</ul>
<p>例如：<br>对于 IP 地址 192.168.1.1 和 子网掩码 255.255.255.0（C 类地址）：</p>
<ul>
<li><p>网络号：192.168.1（前 24 位）</p>
</li>
<li><p>主机号：1（后 8 位）</p>
</li>
</ul>
<p>这个地址划分方式确保了不同网络可以通过网络号来区分，同时在同一网络内的每个设备通过主机号来区分，从而实现高效的网络管理和数据传输。</p>
<h2 id="192-168"><a href="#192-168" class="headerlink" title="192.168"></a>192.168</h2><p>192.168.x.x 是 ipv4 的 c 类地址划分的一部分</p>
<p>C 类网络地址划分: 110 开头，21 位网络号，8 位主机号。C 类网络地址的 192.168 号段才是私有地址，其他号段是公有地址。</p>
<img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/image-20241029144154815.png" alt="image-20241029144154815" style="zoom: 67%;" />

<p>C 类网络中，192.168 划分为私有地址，从 192.168.0.0 到 192.168.255.255。</p>
<h2 id="192-168-11-63"><a href="#192-168-11-63" class="headerlink" title="192.168.11.63"></a>192.168.11.63</h2><p>inet: 192.168.11.63<br>netmask: 255.255.248.0&#x2F;21</p>
<p>192.168.11.63 是 C 类网络地址，192.168 是网络号，11 是子网号，63 是主机号。</p>
<p>192.168.11.63 的二进制表示：</p>
<p>11000000.10101000.00001011.01111111</p>
<p>网络号：11000000.10101000.00001, 21 位网络号, 用于标识同一子网。</p>
<p>主机号：011 11111, 8 位主机号, 用于标识同一子网内的不同设备。</p>
<p>255.255.248.0 的二进制表示：</p>
<p>11111111.11111111.11111000.00000000</p>
<h3 id="同一子网"><a href="#同一子网" class="headerlink" title="同一子网"></a>同一子网</h3><p>从 11000000.10101000.00001000.00000000 到 11000000.10101000.00001111.11111111</p>
<p>即: 192.168.8.0 到 192.168.15.255</p>
<p>可用设备数: 2^8 - 2 &#x3D; 254</p>
<p>特殊地址:</p>
<ul>
<li><p>192.168.8.0: 网络地址, 不能分配给设备, 用于标识子网</p>
</li>
<li><p>192.168.15.255: 广播地址</p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>019_Linux 查看库中是否包含指定函数</title>
    <url>/2024/10/29/019_Linux%20%E6%9F%A5%E7%9C%8B%E5%BA%93%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E6%8C%87%E5%AE%9A%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>在 Linux 系统中，我们经常需要确认某个函数是否在特定的库文件中。以下是几种常用的查找方法。</p>
<span id="more"></span>

<h2 id="1-nm-命令（最常用）"><a href="#1-nm-命令（最常用）" class="headerlink" title="1. nm 命令（最常用）"></a>1. nm 命令（最常用）</h2><p><code>nm</code> 命令用于查看库文件中的符号表，是最直接的方法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基本语法</span></span><br><span class="line">nm -D /path/to/library.so | grep <span class="string">&#x27;function_name&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际示例</span></span><br><span class="line">nm -D /usr/lib/libc.so.6 | grep <span class="string">&#x27;printf&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-objdump-命令（详细信息）"><a href="#2-objdump-命令（详细信息）" class="headerlink" title="2. objdump 命令（详细信息）"></a>2. objdump 命令（详细信息）</h2><p><code>objdump</code> 提供了更详细的库文件信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基本语法</span></span><br><span class="line">objdump -T /path/to/library.so | grep <span class="string">&#x27;function_name&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际示例</span></span><br><span class="line">objdump -T /usr/lib/libc.so.6 | grep <span class="string">&#x27;printf&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-readelf-命令（ELF-文件专用）"><a href="#3-readelf-命令（ELF-文件专用）" class="headerlink" title="3. readelf 命令（ELF 文件专用）"></a>3. readelf 命令（ELF 文件专用）</h2><p>专门用于分析 ELF 格式文件的工具。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基本语法</span></span><br><span class="line">readelf -Ws /path/to/library.so | grep <span class="string">&#x27;function_name&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际示例</span></span><br><span class="line">readelf -Ws /usr/lib/libc.so.6 | grep <span class="string">&#x27;printf&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="4-批量查找方法"><a href="#4-批量查找方法" class="headerlink" title="4. 批量查找方法"></a>4. 批量查找方法</h2><h3 id="使用-find-配合-nm-命令"><a href="#使用-find-配合-nm-命令" class="headerlink" title="使用 find 配合 nm 命令"></a>使用 find 配合 nm 命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在指定目录下查找所有.so文件中的特定函数</span></span><br><span class="line">find /usr/lib -name <span class="string">&quot;*.so&quot;</span> -<span class="built_in">exec</span> nm -D &#123;&#125; \; | grep <span class="string">&#x27;function_name&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="使用-grep-直接搜索"><a href="#使用-grep-直接搜索" class="headerlink" title="使用 grep 直接搜索"></a>使用 grep 直接搜索</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在库目录中搜索函数名</span></span><br><span class="line">grep -R <span class="string">&#x27;function_name&#x27;</span> /usr/lib/</span><br></pre></td></tr></table></figure>

<h2 id="5-依赖关系查看（ldd）"><a href="#5-依赖关系查看（ldd）" class="headerlink" title="5. 依赖关系查看（ldd）"></a>5. 依赖关系查看（ldd）</h2><p>虽然不能直接查看函数，但可以查看库的依赖关系。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看可执行文件的库依赖</span></span><br><span class="line">ldd /path/to/executable</span><br></pre></td></tr></table></figure>

<h2 id="常见参数说明"><a href="#常见参数说明" class="headerlink" title="常见参数说明"></a>常见参数说明</h2><table>
<thead>
<tr>
<th>命令</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>nm</td>
<td>-D</td>
<td>只显示动态符号</td>
</tr>
<tr>
<td>objdump</td>
<td>-T</td>
<td>显示动态符号表</td>
</tr>
<tr>
<td>readelf</td>
<td>-W</td>
<td>使用宽格式显示</td>
</tr>
<tr>
<td></td>
<td>-s</td>
<td>显示符号表</td>
</tr>
</tbody></table>
<h2 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h2><ol>
<li><strong>快速查找</strong>：优先使用 <code>nm -D</code> 命令</li>
<li><strong>详细分析</strong>：需要更多信息时使用 <code>objdump</code> 或 <code>readelf</code></li>
<li><strong>批量查找</strong>：使用 <code>find</code> 配合 <code>nm</code> 命令</li>
<li><strong>依赖确认</strong>：使用 <code>ldd</code> 确认库是否正确链接</li>
</ol>
<h2 id="常见问题排查"><a href="#常见问题排查" class="headerlink" title="常见问题排查"></a>常见问题排查</h2><p>如果找到函数但链接失败，请检查：</p>
<ul>
<li>库文件的链接路径是否正确</li>
<li>库版本是否兼容</li>
<li>符号修饰（symbol mangling）是否匹配</li>
<li>编译器选项是否正确</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>020_如何修改 Linux 栈区大小</title>
    <url>/2024/10/29/020_%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%20Linux%20%E6%A0%88%E5%8C%BA%E5%A4%A7%E5%B0%8F/</url>
    <content><![CDATA[<p>栈，就是那些由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区。里面的变量通常是局部变量、函数参数等。和堆相比，栈通常很小。<br>在 Linux 系统中，栈区的大小是固定的，通常为 8 MB。然而，在某些情况下，我们可能需要修改栈区的大小。本文将介绍如何修改 Linux 栈区大小。</p>
<span id="more"></span>

<h2 id="1-查看当前栈区大小"><a href="#1-查看当前栈区大小" class="headerlink" title="1. 查看当前栈区大小"></a>1. 查看当前栈区大小</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -s // 一般为8192KB, 即8MB</span><br></pre></td></tr></table></figure>

<p>注：线程栈大小默认为 8M，8192 KB。</p>
<h2 id="2-修改栈区大小"><a href="#2-修改栈区大小" class="headerlink" title="2. 修改栈区大小"></a>2. 修改栈区大小</h2><h3 id="临时修改"><a href="#临时修改" class="headerlink" title="临时修改"></a>临时修改</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -s 102400 // 改为100MB</span><br></pre></td></tr></table></figure>

<p>注：ulimit -s ulimited 不限制。</p>
<h3 id="永久修改"><a href="#永久修改" class="headerlink" title="永久修改"></a>永久修改</h3><p>有两种方法：</p>
<ul>
<li><p>方法一：可以在&#x2F;etc&#x2F;rc.local 内加入 ulimit -s 102400 则可以开机就设置栈空间大小，任何用户启动的时候都会调用</p>
</li>
<li><p>方法二：修改配置文件&#x2F;etc&#x2F;security&#x2F;limits.conf</p>
</li>
</ul>
<p>手动添加：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">* soft stack 102400</span><br></pre></td></tr></table></figure>

<p>自动添加：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -ne <span class="string">&quot;* soft stack 102400\n&quot;</span> &gt;&gt; /etc/security/limits.conf</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>021_主题皮肤推荐</title>
    <url>/2024/10/30/021_%E4%B8%BB%E9%A2%98%E7%9A%AE%E8%82%A4%E6%8E%A8%E8%8D%90/</url>
    <content><![CDATA[<p>好用的主题皮肤推荐</p>
<span id="more"></span>

<table>
<thead>
<tr>
<th>工具</th>
<th>主题皮肤</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><strong>vscode</strong></td>
<td><em>Night Owl</em></td>
<td>fav</td>
</tr>
<tr>
<td></td>
<td>One Dark Pro</td>
<td>foggy</td>
</tr>
<tr>
<td><strong>typora</strong></td>
<td><em>Vue</em></td>
<td>fav</td>
</tr>
<tr>
<td></td>
<td>Github</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Juejin</td>
<td></td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>022_c++结构化绑定</title>
    <url>/2024/10/31/022_cpp%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<p>介绍下 c++ 的结构化绑定</p>
<span id="more"></span>

<p>结构化绑定(Structured Binding)是 C++17 引入的新特性,允许我们将结构体、数组或元组中的多个元素同时绑定到多个变量上。</p>
<p>以下是几个常见的使用场景:</p>
<ol>
<li>绑定 tuple:</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::tuple&lt;<span class="type">int</span>, std::string, <span class="type">double</span>&gt; tuple&#123;<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>, <span class="number">3.14</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> [id, name, value] = tuple;  <span class="comment">// 自动解包到三个变量</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>绑定 pair:</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt; map&#123;&#123;<span class="string">&quot;one&quot;</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [key, value] : map) &#123;  <span class="comment">// 遍历map时直接获取键值</span></span><br><span class="line">    std::cout &lt;&lt; key &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>绑定结构体:</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line">Point p&#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> [x, y] = p;  <span class="comment">// 直接获取结构体的成员</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>绑定数组:</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> array[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> [a, b, c] = array;  <span class="comment">// 解包固定大小的数组</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在函数返回多个值时使用:</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::tuple&lt;<span class="type">bool</span>, std::string&gt; <span class="title">ValidateUser</span><span class="params">(<span class="type">const</span> std::string&amp; user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="literal">true</span>, <span class="string">&quot;验证成功&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用时</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> [success, message] = <span class="built_in">ValidateUser</span>(<span class="string">&quot;admin&quot;</span>); success) &#123;</span><br><span class="line">    std::cout &lt;&lt; message &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在之前的代码中的应用:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原来的写法</span></span><br><span class="line">std::vector&lt;std::tuple&lt;T, T, T&gt;&gt; &amp;params;</span><br><span class="line">T min = std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(params.<span class="built_in">at</span>(i));</span><br><span class="line">T max = std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(params.<span class="built_in">at</span>(i));</span><br><span class="line">std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(params.<span class="built_in">at</span>(i)) = value;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用结构化绑定的写法</span></span><br><span class="line"><span class="keyword">auto</span>&amp; [value, min, max] = params[i];  <span class="comment">// 一次性获取所有值</span></span><br></pre></td></tr></table></figure>

<p>优点:</p>
<ol>
<li>代码更简洁易读</li>
<li>避免重复访问容器元素</li>
<li>减少了使用 std::get 的繁琐语法</li>
<li>变量名更有意义,提高代码可维护性</li>
</ol>
<p>注意事项:</p>
<ol>
<li>需要 C++17 或更高版本</li>
<li>绑定的变量数量必须与结构中的元素数量完全匹配</li>
<li>使用 auto 关键字声明</li>
<li>可以使用引用(&amp;)来避免拷贝</li>
</ol>
<p>结构化绑定是现代 C++中非常实用的特性,能让代码更加简洁优雅。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>c++17</tag>
        <tag>现代c++</tag>
      </tags>
  </entry>
  <entry>
    <title>023_c++折叠表达式</title>
    <url>/2024/10/31/023_cpp%E6%8A%98%E5%8F%A0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>C++中的折叠表达式（Fold Expressions）是一种简化变参模板函数编写的语法，从 C++17 开始引入。折叠表达式可以对可变参数模板进行自动折叠，从而简化代码。</p>
<span id="more"></span>

<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>折叠表达式可以将可变参数模板中的所有参数，通过特定的运算符折叠为一个结果。常见的运算符包括加法<code>+</code>、乘法<code>*</code>、逻辑与<code>&amp;&amp;</code>、逻辑或<code>||</code>等。折叠表达式主要有四种形式：</p>
<ol>
<li><strong>一元左折叠</strong>：从左到右依次折叠，例如：<code>(args + ...)</code></li>
<li><strong>一元右折叠</strong>：从右到左依次折叠，例如：<code>(... + args)</code></li>
<li><strong>二元左折叠</strong>：用于指定初始值，从左到右依次折叠，例如：<code>(init + ... + args)</code></li>
<li><strong>二元右折叠</strong>：用于指定初始值，从右到左依次折叠，例如：<code>(args + ... + init)</code></li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>以下是每种折叠表达式的代码示例：</p>
<h4 id="1-一元左折叠"><a href="#1-一元左折叠" class="headerlink" title="1. 一元左折叠"></a>1. 一元左折叠</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args + ...);  <span class="comment">// 将参数依次相加</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);  <span class="comment">// 返回 1 + 2 + 3 + 4 = 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-一元右折叠"><a href="#2-一元右折叠" class="headerlink" title="2. 一元右折叠"></a>2. 一元右折叠</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (... + args);  <span class="comment">// 从右到左依次相加</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-二元左折叠"><a href="#3-二元左折叠" class="headerlink" title="3. 二元左折叠"></a>3. 二元左折叠</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span> + ... + args);  <span class="comment">// 从0开始，依次相加</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);  <span class="comment">// 返回 0 + 1 + 2 + 3 + 4 = 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-二元右折叠"><a href="#4-二元右折叠" class="headerlink" title="4. 二元右折叠"></a>4. 二元右折叠</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args + ... + <span class="number">0</span>);  <span class="comment">// 从右到左依次相加，最终加0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常见应用场景"><a href="#常见应用场景" class="headerlink" title="常见应用场景"></a>常见应用场景</h3><p>折叠表达式在编写模板时非常有用，常见的应用场景包括：</p>
<ol>
<li><strong>累加求和</strong>：将参数列表中的所有值求和。</li>
<li><strong>逻辑判断</strong>：可以通过折叠表达式实现<code>&amp;&amp;</code>和<code>||</code>运算来检查所有参数是否满足某个条件。</li>
<li><strong>打印参数</strong>：配合<code>std::cout</code>可以实现简单的参数打印。</li>
</ol>
<h4 id="逻辑判断的示例"><a href="#逻辑判断的示例" class="headerlink" title="逻辑判断的示例"></a>逻辑判断的示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">allTrue</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args &amp;&amp; ...);  <span class="comment">// 如果所有参数都为true，则返回true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">anyTrue</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args || ...);  <span class="comment">// 如果任意一个参数为true，则返回true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>折叠表达式大大减少了变参模板代码的复杂性，是编写简洁、高效代码的重要工具。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>c++17</tag>
        <tag>现代c++</tag>
      </tags>
  </entry>
  <entry>
    <title>024_cpp初始化</title>
    <url>/2024/10/31/024_cpp%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<p>介绍下 c++ 的初始化</p>
<span id="more"></span>

<h2 id="一-自动初始化为-0-的情况"><a href="#一-自动初始化为-0-的情况" class="headerlink" title="一. 自动初始化为 0 的情况"></a>一. 自动初始化为 0 的情况</h2><p>在 C++中，初始化为 0 的情况取决于变量的类型、存储位置和初始化方式。以下是 C++中会自动初始化为 0 的几种情况：</p>
<h3 id="1-全局变量和静态变量"><a href="#1-全局变量和静态变量" class="headerlink" title="1. 全局变量和静态变量"></a>1. <strong>全局变量和静态变量</strong></h3><ul>
<li><p><strong>全局变量</strong>（包括命名空间作用域的变量）和<strong>静态变量</strong>（<code>static</code>）在定义时会被自动初始化为 0。</p>
</li>
<li><p>这种自动初始化包括整型初始化为 0，浮点型初始化为 0.0，指针初始化为<code>nullptr</code>，类对象会调用默认构造函数。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> globalVar;          <span class="comment">// 自动初始化为0</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> staticVar;    <span class="comment">// 静态变量自动初始化为0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> funcStaticVar;  <span class="comment">// 函数内部的静态变量自动初始化为0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-类中的非静态成员变量（使用值初始化）"><a href="#2-类中的非静态成员变量（使用值初始化）" class="headerlink" title="2. 类中的非静态成员变量（使用值初始化）"></a>2. <strong>类中的非静态成员变量（使用值初始化）</strong></h3><ul>
<li><p>如果对象的非静态成员变量没有显式初始化，在值初始化时这些成员变量会被自动初始化为 0。</p>
</li>
<li><p>值初始化通常发生在使用花括号初始化或默认初始化的情况下。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">double</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj&#123;&#125;;  <span class="comment">// obj.a 和 obj.b 都会被初始化为0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-数组的值初始化"><a href="#3-数组的值初始化" class="headerlink" title="3. 数组的值初始化"></a>3. <strong>数组的值初始化</strong></h3><ul>
<li><p>如果数组通过值初始化进行初始化，数组中的元素会被初始化为 0。</p>
</li>
<li><p>通常使用花括号初始化或空花括号初始化的方式触发此行为。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr1[<span class="number">5</span>] = &#123;&#125;;   <span class="comment">// 所有元素初始化为0</span></span><br><span class="line"><span class="type">int</span> arr2[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">// 所有元素初始化为0</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-动态分配的内存初始化"><a href="#4-动态分配的内存初始化" class="headerlink" title="4. 动态分配的内存初始化"></a>4. <strong>动态分配的内存初始化</strong></h3><ul>
<li><p>使用<code>new</code>时，如果使用了带括号的方式，会将分配的内存初始化为 0。</p>
</li>
<li><p>不加括号的<code>new</code>不会自动初始化（需要手动赋值）。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* p1 = <span class="keyword">new</span> <span class="built_in">int</span>();       <span class="comment">// *p1 被初始化为0</span></span><br><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>]();   <span class="comment">// arr数组的每个元素都初始化为0</span></span><br><span class="line"><span class="keyword">delete</span> p1;</span><br><span class="line"><span class="keyword">delete</span>[] arr;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-内置类型的局部变量不会自动初始化"><a href="#5-内置类型的局部变量不会自动初始化" class="headerlink" title="5. 内置类型的局部变量不会自动初始化"></a>5. <strong>内置类型的局部变量不会自动初始化</strong></h3><ul>
<li><p>如果是局部变量且不属于静态存储期的内置类型变量（如局部整型、浮点型或指针），则它们不会自动初始化为 0，值是未定义的，需手动初始化。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> localVar;    <span class="comment">// 未初始化，值未定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>C++中会自动初始化为 0 的主要情形包括全局&#x2F;静态变量、类中的非静态成员变量（在值初始化时）、使用值初始化的数组和使用括号初始化的动态内存。</p>
<h3 id="1-vector-初始化"><a href="#1-vector-初始化" class="headerlink" title="1. vector 初始化"></a>1. vector 初始化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>是的,使用这种方式定义 vector 时,编译器会自动将所有元素初始化为 0。</p>
<p>具体来说:</p>
<ol>
<li>对于内置类型(如 int, double 等),会被初始化为 0</li>
<li>对于类类型,会调用默认构造函数</li>
</ol>
<p>举例说明:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下定义方式都会将元素初始化为0</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">5</span>)</span></span>;           <span class="comment">// &#123;0,0,0,0,0&#125;</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">double</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">3</span>)</span></span>;        <span class="comment">// &#123;0.0,0.0,0.0&#125;</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">2</span>)</span></span>;          <span class="comment">// &#123;false,false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类类型会调用默认构造函数</span></span><br><span class="line"><span class="function">std::vector&lt;std::string&gt; <span class="title">v4</span><span class="params">(<span class="number">2</span>)</span></span>;   <span class="comment">// &#123;&quot;&quot;,&quot;&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<p>所以 vector 中的所有 int 元素已经被初始化为 0 了。</p>
<h2 id="二-存放内置类型的容器初始化"><a href="#二-存放内置类型的容器初始化" class="headerlink" title="二. 存放内置类型的容器初始化"></a>二. 存放内置类型的容器初始化</h2><p>在 C++中，存放内置类型的容器（如<code>std::vector&lt;int&gt;</code>）中的值是否会被初始化，取决于容器的构造和初始化方式。默认情况下，内置类型的元素不会自动初始化为 0，需要显式设置或采用某些特定的构造方式。以下是不同情况下的初始化行为：</p>
<h3 id="1-默认构造的容器"><a href="#1-默认构造的容器" class="headerlink" title="1. 默认构造的容器"></a>1. <strong>默认构造的容器</strong></h3><ul>
<li><p>如果使用默认构造的容器（即没有指定大小或初始值），则容器的内容为空。</p>
</li>
<li><p>例如，<code>std::vector&lt;int&gt; v;</code>会创建一个空的<code>vector</code>，没有任何元素，因此不存在初始化的问题。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;  <span class="comment">// 空容器，没有元素，因此没有初始化</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-指定大小的构造方式"><a href="#2-指定大小的构造方式" class="headerlink" title="2. 指定大小的构造方式"></a>2. <strong>指定大小的构造方式</strong></h3><ul>
<li><p>如果通过指定大小来构造容器，例如<code>std::vector&lt;int&gt; v(5);</code>，容器会分配出对应数量的元素。</p>
</li>
<li><p>对于内置类型的元素，使用此方式初始化时，值是未定义的，不会自动初始化为 0。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">5</span>)</span></span>;  <span class="comment">// 分配5个int元素，值未定义</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-指定大小和初始值的构造方式"><a href="#3-指定大小和初始值的构造方式" class="headerlink" title="3. 指定大小和初始值的构造方式"></a>3. <strong>指定大小和初始值的构造方式</strong></h3><ul>
<li><p>使用<code>std::vector&lt;int&gt; v(5, 0);</code>指定大小并提供初始值时，所有元素都会被初始化为指定的值（此处为 0）。</p>
</li>
<li><p>这种方式适用于确保容器中所有元素的初始值。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">5</span>, <span class="number">0</span>)</span></span>;  <span class="comment">// 分配5个元素，全部初始化为0</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-使用std-array"><a href="#4-使用std-array" class="headerlink" title="4. 使用std::array"></a>4. <strong>使用<code>std::array</code></strong></h3><ul>
<li><p><code>std::array</code>的大小是固定的，初始化时如果没有提供所有元素的初始值，未指定的元素会被自动初始化为 0。</p>
</li>
<li><p>例如，<code>std::array&lt;int, 5&gt; arr = &#123;1&#125;;</code>会将第一个元素初始化为 1，其他元素初始化为 0。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::array&lt;<span class="type">int</span>, 5&gt; arr = &#123;<span class="number">1</span>&#125;;  <span class="comment">// arr = &#123;1, 0, 0, 0, 0&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-使用std-vector的resize方法"><a href="#5-使用std-vector的resize方法" class="headerlink" title="5. 使用std::vector的resize方法"></a>5. <strong>使用<code>std::vector</code>的<code>resize</code>方法</strong></h3><ul>
<li><p>使用<code>resize</code>调整大小时，如果提供初始值参数（如<code>v.resize(5, 0);</code>），所有新元素会被初始化为指定值（这里是 0）。</p>
</li>
<li><p>如果不提供初始值，则新元素的值未定义。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">resize</span>(<span class="number">5</span>, <span class="number">0</span>);  <span class="comment">// 将容器扩展为5个元素，全部初始化为0</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li>**默认构造或仅指定大小的<code>vector</code>**：元素不会被初始化，值未定义。</li>
<li>**指定大小和初始值的<code>vector</code>**：元素会被初始化为指定值。</li>
<li><strong><code>std::array</code>初始化不完全填充</strong>：剩余元素会被初始化为 0。</li>
<li><strong><code>resize</code>时提供初始值</strong>：新元素会被初始化为该值。</li>
</ul>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>025_PR和MR的区别</title>
    <url>/2024/11/04/025_PR%E5%92%8CMR%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>PR（Pull Request）和 MR（Merge Request）是代码版本控制系统中的两个概念，它们主要用于在多人协作开发项目时合并代码变更。这两个术语在功能上非常相似，但在不同的代码托管平台上有不同的称呼。</p>
<span id="more"></span>

<h2 id="PR（Pull-Request）"><a href="#PR（Pull-Request）" class="headerlink" title="PR（Pull Request）"></a>PR（Pull Request）</h2><ul>
<li><strong>定义</strong>: Pull Request 是 GitHub、Bitbucket、GitLab 等平台上用于代码合并的一种请求机制。当开发者在自己的分支上完成了一组代码更改后，他们可以创建一个 Pull Request 请求，将这些更改合并到主分支（例如 <code>main</code> 或 <code>master</code>）或者其他目标分支。</li>
<li><strong>使用场景</strong>:<ul>
<li>开发者完成功能或修复后，创建 PR 并向代码库的维护者或团队成员发出请求，要求对这些更改进行审查。</li>
<li>审查通过后，维护者可以批准并合并 PR，将这些更改合并到目标分支中。</li>
</ul>
</li>
<li><strong>平台</strong>: PR 这个术语主要用于 GitHub 和 Bitbucket 等平台。</li>
</ul>
<h2 id="MR（Merge-Request）"><a href="#MR（Merge-Request）" class="headerlink" title="MR（Merge Request）"></a>MR（Merge Request）</h2><ul>
<li><p><strong>定义</strong>: Merge Request 是 GitLab 上使用的术语，功能上与 Pull Request 类似。MR 用于向项目中的其他开发者或团队发出合并代码更改的请求。</p>
</li>
<li><p><strong>使用场景</strong>:</p>
<ul>
<li>在开发者完成某个功能或修复后，他们提交 MR 请求，将代码合并到主分支或其他目标分支。</li>
<li>代码库的维护者或团队成员审查 MR，并决定是否合并这些更改。</li>
</ul>
</li>
<li><p><strong>平台</strong>: MR 主要在 GitLab 上使用。</p>
</li>
</ul>
<h2 id="PR-和-MR-的区别"><a href="#PR-和-MR-的区别" class="headerlink" title="PR 和 MR 的区别"></a>PR 和 MR 的区别</h2><ul>
<li><strong>平台不同</strong>: PR 主要用于 GitHub 和 Bitbucket，MR 主要用于 GitLab。</li>
<li><strong>功能相同</strong>: 尽管名称不同，PR 和 MR 的核心功能都是相同的，即允许开发者在合并代码之前发起请求进行代码审查。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>无论是 PR 还是 MR，它们的主要目的是通过让代码库的维护者或团队成员审查代码，确保在代码合并到主分支之前能够发现并解决潜在的问题。这种机制有助于提高代码质量，减少引入的错误，同时也便于多人协作开发。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>026_gitignore</title>
    <url>/2024/11/04/026_gitignore/</url>
    <content><![CDATA[<p>Git 忽略文件的规则</p>
<span id="more"></span>

<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><code>.gitignore</code> 文件是用来告诉 Git 哪些文件或目录在版本控制中应该被忽略的。这对于排除编译生成的文件、临时文件、日志文件以及敏感数据等非常有用。下面是一些编写 <code>.gitignore</code> 文件的基本规则和示例：</p>
<ol>
<li><p><strong>文件名匹配规则</strong>：</p>
<ul>
<li><code>*</code>：匹配零个或多个字符。</li>
<li><code>?</code>：匹配任意一个字符。</li>
<li><code>[]</code>：匹配方括号内的任意一个字符。</li>
<li><code>!</code>：在模式前加上感叹号表示取反，即排除匹配的文件或目录。</li>
</ul>
</li>
<li><p><strong>注释</strong>：以 <code>#</code> 开头的行表示注释，Git 会忽略这些行。</p>
</li>
<li><p><strong>示例</strong>：</p>
<ul>
<li><p>忽略所有 <code>.a</code> 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*.a</span><br></pre></td></tr></table></figure>
</li>
<li><p>但是跟踪 <code>lib.a</code>，即使在忽略 <code>.a</code> 文件的规则下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">!lib.a</span><br></pre></td></tr></table></figure>
</li>
<li><p>忽略所有以 <code>.o</code> 结尾的文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*.o</span><br></pre></td></tr></table></figure>
</li>
<li><p>忽略所有以 <code>~</code> 结尾的临时文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*~</span><br></pre></td></tr></table></figure>
</li>
<li><p>忽略 <code>TODO</code> 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TODO</span><br></pre></td></tr></table></figure>
</li>
<li><p>忽略 <code>build/</code> 目录下的所有文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">build/</span><br></pre></td></tr></table></figure>
</li>
<li><p>忽略 <code>doc/notes.txt</code> 文件，但不包括 <code>doc/server/arch.txt</code> 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">doc/notes.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>忽略 <code>doc/</code> 目录下的 <code>.pdf</code> 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">doc/*.pdf</span><br></pre></td></tr></table></figure>
</li>
<li><p>忽略 <code>doc/</code> 目录下的所有 <code>.pdf</code> 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="取消忽略后无效果"><a href="#取消忽略后无效果" class="headerlink" title="取消忽略后无效果"></a>取消忽略后无效果</h3><p>如果上述 <code>.gitignore</code> 规则没有达到预期效果，可以尝试更具体的忽略和取消忽略规则。在 <code>.gitignore</code> 文件中，顺序和具体路径可能会影响规则的应用。以下是调整后的版本，确保首先取消忽略特定的文件夹，然后忽略一般的文件夹：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 取消忽略以 hexo-theme- 开头的文件夹</span><br><span class="line">!node_modules/hexo-theme-*/</span><br><span class="line"></span><br><span class="line"># 忽略 node_modules 文件夹及其所有内容</span><br><span class="line">node_modules/</span><br><span class="line"></span><br><span class="line"># 忽略 node_modules 文件夹下的 hexo-theme-landscape 文件夹</span><br><span class="line">node_modules/hexo-theme-landscape/</span><br></pre></td></tr></table></figure>

<p>另外，请确保这些文件夹已经被 Git 跟踪（即它们之前没有被忽略）。如果这些文件夹之前已经被忽略，需要先将它们从缓存中移除，然后重新添加它们。可以按照以下步骤操作：</p>
<ol>
<li><p>从 Git 缓存中移除 <code>node_modules</code> 文件夹（但保留本地文件）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">rm</span> -r --cached node_modules</span><br></pre></td></tr></table></figure>
</li>
<li><p>确认 <code>.gitignore</code> 文件中的规则。</p>
</li>
<li><p>重新添加 <code>node_modules</code> 文件夹：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git add node_modules</span><br></pre></td></tr></table></figure>
</li>
<li><p>提交更改：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;Update .gitignore rules&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>通过这些步骤，Git 将正确应用 <code>.gitignore</code> 文件中的规则。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>027_GOF设计模式分类</title>
    <url>/2024/11/07/027_GOF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<p>GOF 设计模式是经过总结、优化的代码设计经验，用于解决软件设计中的特定问题。设计模式通常分为三大类：<strong>创建型模式</strong>、<strong>结构型模式</strong>和<strong>行为型模式</strong>。以下是每个分类中的常见设计模式：</p>
<span id="more"></span>

<h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h3><p>这些模式处理对象的创建问题，并提供更灵活、可复用的创建机制。</p>
<ol>
<li><strong>单例模式（Singleton Pattern）</strong>: 确保一个类只有一个实例，并提供全局访问点。</li>
<li><strong>工厂方法模式（Factory Method Pattern）</strong>: 定义一个创建对象的接口，但由子类决定要实例化的类。</li>
<li><strong>抽象工厂模式（Abstract Factory Pattern）</strong>: 提供一个创建一系列相关或依赖对象的接口，而无需指定具体类。</li>
<li><strong>生成器模式（Builder Pattern）</strong>: 将对象的构建过程与表示分离，使得同样的构建过程可以创建不同的表示。</li>
<li><strong>原型模式（Prototype Pattern）</strong>: 通过复制现有对象来创建新对象，避免了对象的重复初始化。</li>
</ol>
<h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><p>这些模式关注类和对象的组合关系，解决系统的结构问题。</p>
<ol>
<li><strong>适配器模式（Adapter Pattern）</strong>: 使得原本由于接口不兼容而不能一起工作的类可以一起工作。</li>
<li><strong>桥接模式（Bridge Pattern）</strong>: 将抽象部分与它的实现部分分离，使它们都可以独立地变化。</li>
<li><strong>组合模式（Composite Pattern）</strong>: 将对象组合成树形结构以表示”部分-整体”的层次结构，使得客户端可以统一地处理单个对象和组合对象。</li>
<li><strong>装饰者模式（Decorator Pattern）</strong>: 动态地给对象增加额外的职责。</li>
<li><strong>外观模式（Facade Pattern）</strong>: 提供一个统一的接口，用来访问子系统中的一群接口。</li>
<li><strong>享元模式（Flyweight Pattern）</strong>: 运用共享技术来支持大量细粒度的对象。</li>
<li><strong>代理模式（Proxy Pattern）</strong>: 为其他对象提供一种代理，以控制对这个对象的访问。</li>
</ol>
<h3 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h3><p>这些模式关注对象之间的职责划分和相互协作。</p>
<ol>
<li><strong>策略模式（Strategy Pattern）</strong>: 定义一系列算法，将每一个算法封装起来，并且使它们可以互换。</li>
<li><strong>模板方法模式（Template Method Pattern）</strong>: 在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。</li>
<li><strong>观察者模式（Observer Pattern）</strong>: 定义对象之间的一种一对多的依赖关系。</li>
<li><strong>迭代器模式（Iterator Pattern）</strong>: 提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。</li>
<li><strong>职责链模式（Chain of Responsibility Pattern）</strong>: 为请求创建一个接收者对象的链。</li>
<li><strong>命令模式（Command Pattern）</strong>: 将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。</li>
<li><strong>备忘录模式（Memento Pattern）</strong>: 在不破坏封装性的前提下，捕获并外部化一个对象的内部状态。</li>
<li><strong>状态模式（State Pattern）</strong>: 允许对象在内部状态改变时改变它的行为。</li>
<li><strong>中介者模式（Mediator Pattern）</strong>: 用一个中介对象来封装一系列对象的交互。</li>
<li><strong>解释器模式（Interpreter Pattern）</strong>: 给定一种语言，定义它的文法表示，并定义一个解释器来处理这个文法。</li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>028_计算机网络传输层</title>
    <url>/2024/11/11/028_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    <content><![CDATA[<p>在计算机网络中，传输层（Transport Layer）负责在网络端点之间传输数据。它是 OSI 模型中的第四层，提供了关键的功能，以确保数据在网络中能够有效、可靠地传输。以下是传输层的一些主要功能和作用：</p>
<span id="more"></span>

<h2 id="传输层的主要功能"><a href="#传输层的主要功能" class="headerlink" title="传输层的主要功能"></a>传输层的主要功能</h2><h3 id="1-数据分段和重组"><a href="#1-数据分段和重组" class="headerlink" title="1. 数据分段和重组"></a>1. <strong>数据分段和重组</strong></h3><p>传输层将应用层传递下来的数据分割成更小的段（segments），每个段包含必要的控制信息。接收方传输层会将这些段重组成原始的数据流。</p>
<h3 id="2-传输控制"><a href="#2-传输控制" class="headerlink" title="2. 传输控制"></a>2. <strong>传输控制</strong></h3><p>传输层确保数据可靠传输。常见协议如 TCP（传输控制协议）提供了数据包的确认（acknowledgment）、序号（sequence numbering）、超时重传（retransmission）、流控制（flow control）和拥塞控制（congestion control）等机制。</p>
<h3 id="3-端到端通信"><a href="#3-端到端通信" class="headerlink" title="3. 端到端通信"></a>3. <strong>端到端通信</strong></h3><p>传输层建立并管理端到端的通信连接。TCP 协议通过三次握手（three-way handshake）建立连接，确保通信双方准备就绪，而 UDP（用户数据报协议）则是不可靠的连接，通常用于实时应用如视频流和在线游戏。</p>
<h3 id="4-数据完整性"><a href="#4-数据完整性" class="headerlink" title="4. 数据完整性"></a>4. <strong>数据完整性</strong></h3><p>传输层通过校验和（checksum）等技术，确保数据在传输过程中没有被篡改或损坏。TCP 协议在接收数据时会计算并验证校验和，以检测传输中的错误。</p>
<h3 id="5-多路复用和解复用"><a href="#5-多路复用和解复用" class="headerlink" title="5. 多路复用和解复用"></a>5. <strong>多路复用和解复用</strong></h3><p>传输层允许多个应用程序同时使用网络连接，通过使用端口号（port numbers）来区分不同的应用流。多路复用（multiplexing）指的是将多个应用数据流合并到一个物理网络连接上，而解复用（demultiplexing）则是将收到的数据分配给正确的应用程序。</p>
<h3 id="6-流控制"><a href="#6-流控制" class="headerlink" title="6. 流控制"></a>6. <strong>流控制</strong></h3><p>传输层可以管理发送方和接收方的速率，避免网络拥塞和数据丢失。流控制机制确保发送方不会过快地发送数据，以至于接收方来不及处理。</p>
<h3 id="7-拥塞控制"><a href="#7-拥塞控制" class="headerlink" title="7. 拥塞控制"></a>7. <strong>拥塞控制</strong></h3><p>在 TCP 协议中，传输层负责监控网络的拥塞状态，并动态调整数据发送速率，以避免网络过载。常见的拥塞控制算法包括慢启动（slow start）、拥塞避免（congestion avoidance）等。</p>
<p>通过提供上述功能，传输层在确保数据可靠、有效传输方面发挥了关键作用。</p>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><p>Socket 通信主要涉及传输层和应用层。具体来说：</p>
<ol>
<li><p><strong>传输层</strong>：在传输层，Socket 与 TCP（传输控制协议）和 UDP（用户数据报协议）一起工作。TCP 提供可靠的、面向连接的通信，而 UDP 提供无连接的、不可靠的通信。Socket 用于建立和管理这些传输层连接。</p>
</li>
<li><p><strong>应用层</strong>：应用层通过 Socket 接口与传输层进行交互，发送和接收数据。例如，HTTP、FTP、SMTP 等应用层协议都是通过 Socket 来进行数据传输的。</p>
</li>
</ol>
<p>Socket 可以看作是传输层与应用层之间的桥梁，使得应用程序能够方便地使用网络传输功能。</p>
<p>socket 是传输层提供给应用层的编程接口。</p>
<p>socket 是应用层与传输层之间的抽象，socket 不止是 TCP 才有，UDP 也有 socket。</p>
<p>socket 是基于文件描述符的，socket 是文件描述符的一种。</p>
<h3 id="传输层的信息要发送到哪里"><a href="#传输层的信息要发送到哪里" class="headerlink" title="传输层的信息要发送到哪里"></a>传输层的信息要发送到哪里</h3><p>传输层的信息会发送到传输层协议所指定的端口，这些端口是与应用层的特定服务或应用程序关联的。例如，当你在浏览器中访问一个网站时，HTTP 协议会在传输层使用 TCP 端口 80 或者 HTTPS 的 443 端口来发送和接收数据。</p>
<p>具体过程如下：</p>
<ol>
<li><p><strong>发送端</strong>：传输层将应用层的数据封装成数据段，并添加头部信息（例如源端口号和目标端口号）。然后，它将这些数据段传递给网络层。</p>
</li>
<li><p><strong>网络层</strong>：网络层会根据 IP 地址将数据包路由到目标计算机。</p>
</li>
<li><p><strong>接收端</strong>：在目标计算机上，网络层接收到数据包后，会将其传递给传输层。传输层根据数据包中的端口号，将数据转发给对应的应用程序。</p>
</li>
</ol>
<p>因此，传输层的信息最终会交给运行在指定端口上的应用程序或服务。</p>
<h3 id="使用传输层所需的信息"><a href="#使用传输层所需的信息" class="headerlink" title="使用传输层所需的信息"></a>使用传输层所需的信息</h3><p>要使用传输层进行通信，通常需要以下信息：</p>
<ol>
<li><strong>源端口号</strong>：发送方传输层使用的端口号，用于标识发送方的应用程序或服务。</li>
<li><strong>目标端口号</strong>：接收方传输层使用的端口号，用于标识接收方的应用程序或服务。例如，HTTP 使用端口 80，HTTPS 使用端口 443。</li>
<li><strong>源 IP 地址</strong>：发送方设备的 IP 地址，用于标识发送数据包的设备。</li>
<li><strong>目标 IP 地址</strong>：接收方设备的 IP 地址，用于标识接收数据包的设备。</li>
<li><strong>传输协议</strong>：例如 TCP 或 UDP，用于定义数据传输的方式。TCP 提供可靠的传输，而 UDP 则是无连接的、不保证可靠性的传输方式。</li>
<li><strong>序号和确认号</strong>（对于 TCP）：用于确保数据包按顺序到达并确认接收，防止数据丢失或重复。每个数据段都有一个序号，接收方确认收到的数据段时会返回一个确认号。</li>
<li><strong>控制信息</strong>：包括各种标志位（如 SYN、ACK、FIN 等），用于控制数据传输的状态和流程。例如，SYN 和 ACK 用于 TCP 连接的建立和确认。</li>
<li><strong>校验和</strong>：用于数据完整性校验，确保传输过程中数据未被篡改或损坏。</li>
<li><strong>窗口大小</strong>：流控制信息，指示接收方可接受的最大数据量，用于控制发送方的发送速率，防止网络拥塞。</li>
</ol>
<p>通过提供这些信息，传输层能够在发送方和接收方之间建立可靠的数据传输通道，确保数据能够正确、有效地到达目标。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>029_计算机网络网络层</title>
    <url>/2024/11/11/029_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    <content><![CDATA[<p>网络层（Network Layer）在计算机网络中扮演着关键的角色，负责数据在网络中的传输路径选择和数据包的路由。以下是网络层的主要功能：</p>
<span id="more"></span>

<h2 id="网络层的主要功能"><a href="#网络层的主要功能" class="headerlink" title="网络层的主要功能"></a>网络层的主要功能</h2><h3 id="1-路由选择"><a href="#1-路由选择" class="headerlink" title="1. 路由选择"></a>1. 路由选择</h3><p>网络层负责确定数据包从源地址到目标地址的最佳路径。路由器（Routers）使用路由协议（如 OSPF、BGP）来动态更新和维护路由表，并根据网络拓扑的变化调整路径。</p>
<h3 id="2-数据包转发"><a href="#2-数据包转发" class="headerlink" title="2. 数据包转发"></a>2. 数据包转发</h3><p>网络层将数据包从一个网络节点转发到下一个节点，直到数据包到达目标地址。这个过程涉及查找路由表，并根据表中的信息确定数据包的下一跳地址。</p>
<h3 id="3-IP-地址编址"><a href="#3-IP-地址编址" class="headerlink" title="3. IP 地址编址"></a>3. IP 地址编址</h3><p>网络层使用 IP 地址来唯一标识网络中的每个设备。IP 地址分为 IPv4 和 IPv6 两种格式，网络层通过 IP 地址来确定数据包的源和目的地。</p>
<h3 id="4-分段与重组"><a href="#4-分段与重组" class="headerlink" title="4. 分段与重组"></a>4. 分段与重组</h3><p>网络层将较大的数据包分割成适合传输的较小片段（分段），并在到达目标后重新组装（重组）这些片段。这对于跨越不同网络的传输尤为重要，因为不同网络可能对数据包大小有不同的限制。</p>
<h3 id="5-差错处理与流量控制"><a href="#5-差错处理与流量控制" class="headerlink" title="5. 差错处理与流量控制"></a>5. 差错处理与流量控制</h3><p>虽然主要的差错检测和流量控制功能在传输层，但网络层也具备一定的错误检测机制。例如，IPv4 报头包含一个校验和字段，用于检查数据包头部的完整性。此外，ICMP 协议（如 Ping）用于报告网络层错误和提供诊断功能。</p>
<h3 id="6-拥塞控制"><a href="#6-拥塞控制" class="headerlink" title="6. 拥塞控制"></a>6. 拥塞控制</h3><p>网络层协议需要处理网络拥塞问题，确保数据包能够高效传输。例如，通过减少数据包的转发速率，或丢弃低优先级的数据包，来缓解网络拥塞。</p>
<h3 id="7-安全性"><a href="#7-安全性" class="headerlink" title="7. 安全性"></a>7. 安全性</h3><p>网络层的某些协议（如 IPSec）提供了数据加密和验证功能，确保数据在传输过程中不被窃取或篡改，提高数据传输的安全性。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>网络层的主要功能是管理数据包的传输和路由，确保数据能从源地址正确、安全地传递到目标地址。这些功能对于网络的正常运行和数据的有效传输至关重要。</p>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="网络层协议"><a href="#网络层协议" class="headerlink" title="网络层协议"></a>网络层协议</h3><ul>
<li>IP 协议</li>
<li>ICMP 协议</li>
<li>ARP 协议</li>
<li>RARP 协议</li>
</ul>
<h3 id="网络模型各层的作用"><a href="#网络模型各层的作用" class="headerlink" title="网络模型各层的作用"></a>网络模型各层的作用</h3><p>应用层相当于用户，负责处理应用层的逻辑。</p>
<p>运输层相当于快递员，负责将数据从源地址传递到目标地址。</p>
<p>网络层相当于邮局，负责将数据从源地址传递到目标地址。</p>
<p>网络接口层相当于邮局分拣员，负责将数据分拣到不同的邮局。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>030_计算机网络应用层</title>
    <url>/2024/11/11/030_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    <content><![CDATA[<p>应用层是 OSI 模型中的第七层，直接面向用户和应用程序。它主要负责提供网络服务的接口和实现数据交换。以下是应用层的主要功能：</p>
<span id="more"></span>

<h2 id="应用层的主要功能"><a href="#应用层的主要功能" class="headerlink" title="应用层的主要功能"></a>应用层的主要功能</h2><h3 id="1-提供网络服务接口"><a href="#1-提供网络服务接口" class="headerlink" title="1. 提供网络服务接口"></a>1. 提供网络服务接口</h3><p>应用层为各种应用程序提供网络服务接口，使得用户可以通过这些应用程序进行通信和数据交换。例如，Web 浏览器、电子邮件客户端和文件传输应用都通过应用层协议与网络进行交互。</p>
<h3 id="2-数据表示和转换"><a href="#2-数据表示和转换" class="headerlink" title="2. 数据表示和转换"></a>2. 数据表示和转换</h3><p>应用层负责数据的表示和转换，确保不同系统之间的数据可以正确理解和处理。这包括字符编码、数据格式转换和数据压缩等功能。例如，HTTP 协议在传输 HTML 文件时，需要将字符数据编码为网络传输格式。</p>
<h3 id="3-数据加密和安全性"><a href="#3-数据加密和安全性" class="headerlink" title="3. 数据加密和安全性"></a>3. 数据加密和安全性</h3><p>应用层提供数据加密和解密功能，确保数据在传输过程中的机密性和完整性。例如，HTTPS 协议通过 SSL&#x2F;TLS 加密数据，保护用户的敏感信息。</p>
<h3 id="4-资源共享和远程访问"><a href="#4-资源共享和远程访问" class="headerlink" title="4. 资源共享和远程访问"></a>4. 资源共享和远程访问</h3><p>应用层支持资源共享和远程访问功能，使得用户可以访问远程服务器的资源。例如，FTP 协议允许用户上传和下载远程服务器上的文件，Telnet 协议允许用户远程登录到另一台计算机。</p>
<h3 id="5-消息传递和电子邮件"><a href="#5-消息传递和电子邮件" class="headerlink" title="5. 消息传递和电子邮件"></a>5. 消息传递和电子邮件</h3><p>应用层支持消息传递和电子邮件服务，例如 SMTP、POP3 和 IMAP 协议，用于发送、接收和管理电子邮件。</p>
<h3 id="6-文件传输和访问"><a href="#6-文件传输和访问" class="headerlink" title="6. 文件传输和访问"></a>6. 文件传输和访问</h3><p>应用层提供文件传输和访问功能，使得用户可以在网络中传输和访问文件。常见的应用层协议包括 FTP 和 HTTP，用于文件上传、下载和网页访问。</p>
<h3 id="7-会话管理"><a href="#7-会话管理" class="headerlink" title="7. 会话管理"></a>7. 会话管理</h3><p>应用层管理通信会话的建立、维护和终止，确保通信的有效性和可靠性。例如，SIP 协议用于管理 VoIP（互联网语音）通信会话。</p>
<p>通过上述功能，应用层确保用户和应用程序能够方便地使用网络资源，实现高效的数据交换和通信。</p>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><p>Socket 通信主要涉及传输层和应用层。具体来说：</p>
<ul>
<li><p>传输层：在传输层，Socket 与 TCP（传输控制协议）和 UDP（用户数据报协议）一起工作。TCP 提供可靠的、面向连接的通信，而 UDP 提供无连接的、不可靠的通信。Socket 用于建立和管理这些传输层连接。</p>
</li>
<li><p>应用层：应用层通过 Socket 接口与传输层进行交互，发送和接收数据。例如，HTTP、FTP、SMTP 等应用层协议都是通过 Socket 来进行数据传输的。</p>
</li>
</ul>
<p>Socket 可以看作是传输层与应用层之间的桥梁，使得应用程序能够方便地使用网络传输功能。</p>
<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>DNS（域名系统）是应用层的协议。它的主要功能是将人类可读的域名（如 <code>www.example.com</code>）转换为计算机可读的 IP 地址（如 <code>192.0.2.1</code>）。这一转换过程被称为域名解析。</p>
<p>在 OSI 模型中，DNS 位于应用层，并通过 UDP 或 TCP 协议在传输层上传输数据。通常情况下，DNS 查询使用 UDP 端口 53 进行通信，但也可以在某些情况下使用 TCP 端口 53，例如当返回的数据包大小超过 UDP 协议的限制时。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>031_DHCP的作用</title>
    <url>/2024/11/11/031_DHCP%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<p>DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）的主要作用是自动为网络上的设备分配 IP 地址和其他网络配置参数，如子网掩码、默认网关和 DNS 服务器。这样做的目的是简化网络管理，避免手动配置每个设备的网络设置。以下是 DHCP 的具体功能：</p>
<span id="more"></span>

<h3 id="1-自动-IP-地址分配"><a href="#1-自动-IP-地址分配" class="headerlink" title="1. 自动 IP 地址分配"></a>1. <strong>自动 IP 地址分配</strong></h3><p>DHCP 服务器可以自动分配 IP 地址给网络中的设备，确保每个设备都有一个唯一的 IP 地址，避免地址冲突。</p>
<h3 id="2-分配网络配置参数"><a href="#2-分配网络配置参数" class="headerlink" title="2. 分配网络配置参数"></a>2. <strong>分配网络配置参数</strong></h3><p>除了 IP 地址，DHCP 还可以分配其他重要的网络配置参数，如：</p>
<ul>
<li><strong>子网掩码</strong>：用于确定 IP 地址的网络部分和主机部分。</li>
<li><strong>默认网关</strong>：用于设备访问外部网络。</li>
<li><strong>DNS 服务器</strong>：用于将域名解析为 IP 地址。</li>
</ul>
<h3 id="3-IP-地址租赁"><a href="#3-IP-地址租赁" class="headerlink" title="3. IP 地址租赁"></a>3. <strong>IP 地址租赁</strong></h3><p>DHCP 使用租赁机制，IP 地址的分配是有时间限制的。设备在租期到期之前，可以向 DHCP 服务器请求续租以继续使用当前的 IP 地址。</p>
<h3 id="4-网络管理简化"><a href="#4-网络管理简化" class="headerlink" title="4. 网络管理简化"></a>4. <strong>网络管理简化</strong></h3><p>通过 DHCP，网络管理员不需要手动为每个设备配置网络设置，简化了网络管理工作，尤其是在有大量设备的网络环境中。</p>
<h3 id="5-移动设备支持"><a href="#5-移动设备支持" class="headerlink" title="5. 移动设备支持"></a>5. <strong>移动设备支持</strong></h3><p>对于移动设备，如笔记本电脑、智能手机等，当它们从一个网络移动到另一个网络时，DHCP 可以自动为它们分配新的 IP 地址和配置参数，确保设备可以无缝连接到新网络。</p>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>DHCP 的工作流程通常包括以下几个步骤：</p>
<ol>
<li><strong>DHCP Discover</strong>：客户端广播一个 DHCP 发现报文，寻找 DHCP 服务器。</li>
<li><strong>DHCP Offer</strong>：DHCP 服务器响应发现报文，提供一个 IP 地址和配置参数。</li>
<li><strong>DHCP Request</strong>：客户端选择一个提供的 IP 地址，并向服务器发送请求报文。</li>
<li><strong>DHCP Acknowledgment</strong>：服务器确认请求，并正式分配 IP 地址及其他配置参数。</li>
</ol>
<p>通过这些功能，DHCP 大大简化了网络配置和管理过程，使得网络设备可以更容易地连接和通信。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>032_报文结构</title>
    <url>/2024/11/11/032_%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>报文结构是指在网络通信中，各种协议规定的数据报文格式。不同的协议会有不同的报文结构，以下是一些常见协议的报文结构示例。</p>
<span id="more"></span>

<h3 id="TCP-报文结构"><a href="#TCP-报文结构" class="headerlink" title="TCP 报文结构"></a>TCP 报文结构</h3><p>TCP（传输控制协议）的报文结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-------------------------+</span><br><span class="line">|       源端口号 (16位)      |</span><br><span class="line">+-------------------------+</span><br><span class="line">|       目的端口号 (16位)     |</span><br><span class="line">+-------------------------+</span><br><span class="line">|       序列号 (32位)       |</span><br><span class="line">+-------------------------+</span><br><span class="line">|      确认号 (32位)       |</span><br><span class="line">+-------------------------+</span><br><span class="line">| 数据偏移 (4位) | 保留 (6位) | 标志位 (6位) | 窗口大小 (16位) |</span><br><span class="line">+-------------------------+</span><br><span class="line">|     校验和 (16位)        |</span><br><span class="line">+-------------------------+</span><br><span class="line">|     紧急指针 (16位)       |</span><br><span class="line">+-------------------------+</span><br><span class="line">|     选项 (可变)          |</span><br><span class="line">+-------------------------+</span><br><span class="line">|     数据 (可变)          |</span><br><span class="line">+-------------------------+</span><br></pre></td></tr></table></figure>

<h3 id="UDP-报文结构"><a href="#UDP-报文结构" class="headerlink" title="UDP 报文结构"></a>UDP 报文结构</h3><p>UDP（用户数据报协议）的报文结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-------------------------+</span><br><span class="line">|       源端口号 (16位)      |</span><br><span class="line">+-------------------------+</span><br><span class="line">|       目的端口号 (16位)     |</span><br><span class="line">+-------------------------+</span><br><span class="line">|    数据报长度 (16位)     |</span><br><span class="line">+-------------------------+</span><br><span class="line">|       校验和 (16位)       |</span><br><span class="line">+-------------------------+</span><br><span class="line">|     数据 (可变)          |</span><br><span class="line">+-------------------------+</span><br></pre></td></tr></table></figure>

<h3 id="IP-报文结构"><a href="#IP-报文结构" class="headerlink" title="IP 报文结构"></a>IP 报文结构</h3><p>IP（Internet 协议）分为 IPv4 和 IPv6，这里以 IPv4 为例，其报文结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-------------------------------+</span><br><span class="line">| 版本 (4位) | 头部长度 (4位)   |</span><br><span class="line">+-------------------------------+</span><br><span class="line">|      服务类型 (8位)             |</span><br><span class="line">+-------------------------------+</span><br><span class="line">|     总长度 (16位)              |</span><br><span class="line">+-------------------------------+</span><br><span class="line">|     标识 (16位)               |</span><br><span class="line">+-------------------------------+</span><br><span class="line">| 标志 (3位) | 片偏移 (13位)     |</span><br><span class="line">+-------------------------------+</span><br><span class="line">|   生存时间 (8位) | 协议 (8位)   |</span><br><span class="line">+-------------------------------+</span><br><span class="line">|     头部校验和 (16位)          |</span><br><span class="line">+-------------------------------+</span><br><span class="line">|     源IP地址 (32位)            |</span><br><span class="line">+-------------------------------+</span><br><span class="line">|     目的IP地址 (32位)          |</span><br><span class="line">+-------------------------------+</span><br><span class="line">|     选项 (可变)                |</span><br><span class="line">+-------------------------------+</span><br><span class="line">|     数据 (可变)                |</span><br><span class="line">+-------------------------------+</span><br></pre></td></tr></table></figure>

<h3 id="HTTP-报文结构"><a href="#HTTP-报文结构" class="headerlink" title="HTTP 报文结构"></a>HTTP 报文结构</h3><p>HTTP（超文本传输协议）的报文结构相对简单，以 HTTP 请求报文为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请求行:</span><br><span class="line">  GET /path/resource HTTP/1.1</span><br><span class="line"></span><br><span class="line">头部字段:</span><br><span class="line">  Host: www.example.com</span><br><span class="line">  User-Agent: Mozilla/5.0</span><br><span class="line">  Accept: text/html,application/xhtml+xml</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">空行:</span><br><span class="line">  （头部与数据之间的空行）</span><br><span class="line"></span><br><span class="line">数据:</span><br><span class="line">  （可选，例如POST请求的数据）</span><br></pre></td></tr></table></figure>

<p>这些报文结构定义了通信双方在传输数据时必须遵循的格式，确保数据可以正确地传输和解析。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>033_集线器_交换机_路由器_光猫的区别</title>
    <url>/2024/11/12/033-%E9%9B%86%E7%BA%BF%E5%99%A8-%E4%BA%A4%E6%8D%A2%E6%9C%BA-%E8%B7%AF%E7%94%B1%E5%99%A8-%E5%85%89%E7%8C%AB%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h3 id="路由器和交换机的主要区别"><a href="#路由器和交换机的主要区别" class="headerlink" title="路由器和交换机的主要区别"></a>路由器和交换机的主要区别</h3><h4 id="路由器和交换机不同点在于，它的每个网口下，都有一个-MAC-地址和-IP-地址"><a href="#路由器和交换机不同点在于，它的每个网口下，都有一个-MAC-地址和-IP-地址" class="headerlink" title="路由器和交换机不同点在于，它的每个网口下，都有一个 MAC 地址和 IP 地址"></a>路由器和交换机不同点在于，它的每个网口下，都有一个 MAC 地址和 IP 地址</h4><p>前面提到交换机，是不具备 MAC 地址的，而 MAC 报头是需要填上目的 MAC 地址的。因此交换机从来都不是数据的目的地，它只简单转发数据帧到目的地。</p>
<p>但路由器，是有 MAC 地址的，因此 MAC 报头就可以写上，下一站目的地就是 xx 路由。</p>
<p>到了路由器后，路由器可以再次组装下一站的目的 MAC 地址是再下一个路由，通过这一点，让数据在路由和路由之间传输。</p>
<p>而同时因为交换机不具有 MAC 地址，因此也不会校验收到的数据帧的 MAC 地址是不是自己的，全部收下做转发。而路由器则会校验数据帧的 MAC 报头里的目的 MAC 地址是不是自己，是的话才会收入内存缓冲区，否则丢弃。</p>
<h4 id="找不到转发目的地时的处理方式有区别"><a href="#找不到转发目的地时的处理方式有区别" class="headerlink" title="找不到转发目的地时的处理方式有区别"></a>找不到转发目的地时的处理方式有区别</h4><p>如果在路由表中无法找到匹配的记录，路由器会丢弃这个包，并通过 ICMP 消息告知发送方。</p>
<p>而交换机在 MAC 地址表里找不到转发端口时会选择广播。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>两台电脑可以通过一根网线直接连接，进行通信。</li>
<li>机器一多，可以把网线都接到集线器（物理层）上，但是集线器会不管三七二十一进行广播。</li>
<li>不想广播，可以用（二层）交换机（数据链路层），又叫多端口网桥，它比较聪明，会自我学习生产 MAC 地址表，知道消息发到哪，那就不需要广播啦</li>
<li>互联网电脑这么多，交换机 MAC 地址表总不能全放下吧。改用路由器（网络层），也叫三层交换机，通过网段的方式定位要把消息转发到哪，就不需要像交换机那样苦哈哈一条一条记录 MAC 地址啦。</li>
<li>路由器和光猫之间是好搭档，光猫负责把光纤里的光信号转换成电信号给路由器。</li>
<li>现在一般情况下，家里已经不用集线器和交换机了，大部分路由器也支持交换机的功能。所以可以看到，家里的台式机电脑一般就连到一个路由器，再连个光猫就够能快乐上网了。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20241112165453.png" alt="网络连接模型"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>034_端口号的划分</title>
    <url>/2024/11/12/034-%E7%AB%AF%E5%8F%A3%E5%8F%B7%E7%9A%84%E5%88%92%E5%88%86/</url>
    <content><![CDATA[<p>端口号用于标识网络通信中的特定进程或服务，它们在 TCP&#x2F;IP 协议中有特定的划分方式。以下是端口号的分类：</p>
<span id="more"></span>

<h2 id="端口号的划分"><a href="#端口号的划分" class="headerlink" title="端口号的划分"></a>端口号的划分</h2><h3 id="1-系统端口-0-1023"><a href="#1-系统端口-0-1023" class="headerlink" title="1. 系统端口 (0-1023)"></a>1. <strong>系统端口 (0-1023)</strong></h3><p>这些端口号是为系统进程或特权服务预留的，只有超级用户或具有特定权限的用户才能使用。例如：</p>
<ul>
<li><strong>80</strong>: HTTP</li>
<li><strong>443</strong>: HTTPS</li>
<li><strong>21</strong>: FTP</li>
<li><strong>22</strong>: SSH</li>
</ul>
<h3 id="2-用户端口-1024-49151"><a href="#2-用户端口-1024-49151" class="headerlink" title="2. 用户端口 (1024-49151)"></a>2. <strong>用户端口 (1024-49151)</strong></h3><p>这些端口号通常用于用户进程或应用程序，普通用户可以使用。例如：</p>
<ul>
<li><strong>3306</strong>: MySQL 数据库</li>
<li><strong>8080</strong>: 通常用于 HTTP 备用端口或 Web 服务器端口</li>
</ul>
<h3 id="3-动态-私有端口-49152-65535"><a href="#3-动态-私有端口-49152-65535" class="headerlink" title="3. 动态&#x2F;私有端口 (49152-65535)"></a>3. <strong>动态&#x2F;私有端口 (49152-65535)</strong></h3><p>这些端口号通常用于临时或短期的通信，客户端在连接到服务器时常用这些端口。例如，临时打开的 Web 浏览器与服务器进行通信时使用的端口。</p>
<h3 id="详细示例"><a href="#详细示例" class="headerlink" title="详细示例"></a>详细示例</h3><p>假设你在浏览器中访问一个网站，过程可能涉及多个端口号：</p>
<ol>
<li><strong>浏览器</strong>（客户端）使用一个动态端口（如 49152）发送请求。</li>
<li><strong>服务器</strong>接收到请求，监听端口 80（HTTP）或 443（HTTPS）。</li>
<li><strong>服务器</strong>响应，发送数据回到客户端的动态端口（49152）。</li>
</ol>
<p>通过这种端口号划分，可以有效地管理和分配网络资源，确保不同服务和应用程序之间的通信不会互相干扰。</p>
<h2 id="访问一个网站要写上对应的端口号吗-什么时候用端口号"><a href="#访问一个网站要写上对应的端口号吗-什么时候用端口号" class="headerlink" title="访问一个网站要写上对应的端口号吗,什么时候用端口号"></a>访问一个网站要写上对应的端口号吗,什么时候用端口号</h2><p>通常情况下，当你访问一个网站时，不需要手动写上端口号，因为浏览器会默认使用标准端口号：</p>
<ul>
<li>HTTP 默认使用端口号 80</li>
<li>HTTPS 默认使用端口号 443</li>
</ul>
<h3 id="什么时候需要写上端口号"><a href="#什么时候需要写上端口号" class="headerlink" title="什么时候需要写上端口号"></a>什么时候需要写上端口号</h3><ol>
<li><p><strong>非标准端口</strong>：如果网站使用了非标准端口，你需要在域名后面手动指定端口号。例如，访问使用端口号 8080 的 HTTP 服务，地址可能是 <code>http://www.example.com:8080</code>。</p>
</li>
<li><p><strong>调试和开发</strong>：在进行网站开发和调试时，常常使用非标准端口来运行开发服务器或测试环境。例如，许多开发框架默认使用端口号 3000 或 5000。</p>
</li>
<li><p><strong>多服务部署</strong>：同一服务器上可能运行多个服务，每个服务使用不同的端口号。例如，一个服务器上运行多个 Web 应用程序，分别监听端口 8080 和 9090。</p>
</li>
<li><p><strong>特殊服务</strong>：某些特定服务可能会使用自定义端口，如数据库管理界面、管理控制台等。例如，Jenkins 通常在端口 8080 上运行，phpMyAdmin 可能在端口 8000 上运行。</p>
</li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ul>
<li>标准 HTTP 访问：<code>http://www.example.com</code></li>
<li>标准 HTTPS 访问：<code>https://www.example.com</code></li>
<li>非标准端口的 HTTP 访问：<code>http://www.example.com:8080</code></li>
<li>非标准端口的 HTTPS 访问：<code>https://www.example.com:8443</code></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>大多数情况下，你不需要手动写上端口号，但在使用非标准端口或访问特定服务时，需要明确指定端口号。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>035-lamda表达式的应用场景</title>
    <url>/2024/11/13/035-lamda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<p>Lambda 表达式在 C++中是一个非常强大且灵活的特性，它在以下场景中会特别有用：</p>
<span id="more"></span>

<h3 id="1-算法"><a href="#1-算法" class="headerlink" title="1. 算法"></a>1. 算法</h3><p>Lambda 表达式可以用来简化代码，特别是在需要定义短小的匿名函数时。例如，在 STL 算法（如<code>std::sort</code>）中传递自定义比较函数时：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = std::<span class="built_in">find_if</span>(m_servers.<span class="built_in">begin</span>(), m_servers.<span class="built_in">end</span>(),</span><br><span class="line">        [&amp;](<span class="type">const</span> VxiServerInfo&amp; server) &#123;</span><br><span class="line">            <span class="keyword">return</span> server.session_name == session_name;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="2-捕获局部变量"><a href="#2-捕获局部变量" class="headerlink" title="2. 捕获局部变量"></a>2. <strong>捕获局部变量</strong></h3><p>Lambda 表达式可以捕获所在作用域内的变量，这样可以在回调或处理函数中使用这些变量，而不需要传递额外的参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> add_x = [x](<span class="type">int</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">add_x</span>(<span class="number">5</span>) &lt;&lt; std::endl; <span class="comment">// 输出 15</span></span><br></pre></td></tr></table></figure>

<h3 id="3-并行和异步编程"><a href="#3-并行和异步编程" class="headerlink" title="3. 并行和异步编程"></a>3. <strong>并行和异步编程</strong></h3><p>在并行和异步编程中，lambda 表达式经常用于定义线程函数或异步任务的工作内容。例如，使用<code>std::async</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> future = std::<span class="built_in">async</span>([]() &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;等待结果...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;结果是: &quot;</span> &lt;&lt; future.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-事件处理"><a href="#4-事件处理" class="headerlink" title="4. 事件处理"></a>4. <strong>事件处理</strong></h3><p>在 GUI 编程或事件驱动的编程模型中，lambda 表达式可用于定义事件处理器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">button_click</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; callback)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">callback</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">button_click</span>([]() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;按钮被点击了！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-通用编程"><a href="#5-通用编程" class="headerlink" title="5. 通用编程"></a>5. <strong>通用编程</strong></h3><p>在模板编程中，lambda 表达式可以用作函数对象，特别是在需要高效、内联的函数对象时：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Func&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(Func func)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">func</span>(<span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">apply</span>([](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x * x; &#125;); <span class="comment">// 输出25</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过使用 lambda 表达式，你可以写出更简洁、高效和易于维护的代码。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>036-std::funtion</title>
    <url>/2024/11/13/036-std-funtion/</url>
    <content><![CDATA[<p><code>std::function</code> 是 C++11 引入的标准库组件，用于包装任意可调用的目标。它可以用来存储、传递和调用各种类型的可调用对象，如普通函数、Lambda 表达式、函数对象和成员函数等。下面是 <code>std::function</code> 的一些关键特点和用法：</p>
<span id="more"></span>

<h3 id="1-定义和用法"><a href="#1-定义和用法" class="headerlink" title="1. 定义和用法"></a>1. <strong>定义和用法</strong></h3><p><code>std::function</code> 模板类定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::function&lt;返回类型(参数类型...)&gt; 函数对象;</span><br></pre></td></tr></table></figure>

<p>例如，定义一个接收两个 <code>int</code> 参数并返回 <code>int</code> 的函数对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func;</span><br></pre></td></tr></table></figure>

<h3 id="2-存储和调用不同类型的可调用对象"><a href="#2-存储和调用不同类型的可调用对象" class="headerlink" title="2. 存储和调用不同类型的可调用对象"></a>2. <strong>存储和调用不同类型的可调用对象</strong></h3><h4 id="存储普通函数"><a href="#存储普通函数" class="headerlink" title="存储普通函数"></a>存储普通函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func = add;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">func</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; std::endl; <span class="comment">// 输出 3</span></span><br></pre></td></tr></table></figure>

<h4 id="存储-Lambda-表达式"><a href="#存储-Lambda-表达式" class="headerlink" title="存储 Lambda 表达式"></a>存储 Lambda 表达式</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> lambda = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line">std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func = lambda;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">func</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; std::endl; <span class="comment">// 输出 3</span></span><br></pre></td></tr></table></figure>

<h4 id="存储函数对象"><a href="#存储函数对象" class="headerlink" title="存储函数对象"></a>存储函数对象</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Adder</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Adder adder;</span><br><span class="line">std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func = adder;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">func</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; std::endl; <span class="comment">// 输出 3</span></span><br></pre></td></tr></table></figure>

<h4 id="存储成员函数"><a href="#存储成员函数" class="headerlink" title="存储成员函数"></a>存储成员函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Calculator calc;</span><br><span class="line">std::function&lt;<span class="type">int</span>(<span class="type">const</span> Calculator&amp;, <span class="type">int</span>, <span class="type">int</span>)&gt; func = &amp;Calculator::add;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">func</span>(calc, <span class="number">1</span>, <span class="number">2</span>) &lt;&lt; std::endl; <span class="comment">// 输出 3</span></span><br></pre></td></tr></table></figure>

<h3 id="3-捕获上下文"><a href="#3-捕获上下文" class="headerlink" title="3. 捕获上下文"></a>3. <strong>捕获上下文</strong></h3><p><code>std::function</code> 允许存储并捕获上下文信息，例如 Lambda 表达式中捕获的外部变量：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> lambda = [x](<span class="type">int</span> a) &#123; <span class="keyword">return</span> a + x; &#125;;</span><br><span class="line">std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; func = lambda;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">func</span>(<span class="number">5</span>) &lt;&lt; std::endl; <span class="comment">// 输出 15</span></span><br></pre></td></tr></table></figure>

<h3 id="4-可变性和赋值"><a href="#4-可变性和赋值" class="headerlink" title="4. 可变性和赋值"></a>4. <strong>可变性和赋值</strong></h3><p><code>std::function</code> 可以动态改变所包装的可调用目标：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">func</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; std::endl; <span class="comment">// 输出 3</span></span><br><span class="line"></span><br><span class="line">func = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a * b; &#125;;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">func</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; std::endl; <span class="comment">// 输出 2</span></span><br></pre></td></tr></table></figure>

<p>通过 <code>std::function</code>，C++ 提供了一种灵活的方法来处理各种可调用对象，使得编写高效、易读和维护的代码变得更加容易。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>037-服务器的分类</title>
    <url>/2024/11/13/037-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<p>服务器可以根据用途、性能、架构等多种因素进行分类。下面是一些常见的服务器分类：</p>
<span id="more"></span>

<h3 id="1-按用途分类"><a href="#1-按用途分类" class="headerlink" title="1. 按用途分类"></a>1. 按用途分类</h3><ul>
<li><strong>Web 服务器</strong>: 用于存储和提供网页内容，例如 Apache HTTP Server、Nginx 等。Web 服务器就是这一类。</li>
<li><strong>应用服务器</strong>: 用于运行应用程序的服务器，例如 JBoss、WebLogic 等。</li>
<li><strong>数据库服务器</strong>: 用于存储和管理数据库的服务器，例如 MySQL、Oracle Database 等。</li>
<li><strong>文件服务器</strong>: 用于存储和管理文件的服务器，例如 Windows File Server、Samba 等。</li>
<li><strong>邮件服务器</strong>: 用于处理电子邮件的服务器，例如 Microsoft Exchange、Postfix 等。</li>
<li><strong>DNS 服务器</strong>: 用于域名解析的服务器，例如 BIND、Microsoft DNS 等。</li>
<li><strong>FTP 服务器</strong>: 用于文件传输的服务器，例如 vsftpd、FileZilla Server 等。</li>
</ul>
<h3 id="2-按性能分类"><a href="#2-按性能分类" class="headerlink" title="2. 按性能分类"></a>2. 按性能分类</h3><ul>
<li><strong>高性能服务器</strong>: 配置高端硬件，处理大量并发请求和数据处理任务，例如大数据处理服务器、企业级数据库服务器等。</li>
<li><strong>中性能服务器</strong>: 用于中小型企业，处理一般业务需求的服务器。</li>
<li><strong>低性能服务器</strong>: 用于处理简单任务或开发测试环境的服务器。</li>
</ul>
<h3 id="3-按架构分类"><a href="#3-按架构分类" class="headerlink" title="3. 按架构分类"></a>3. 按架构分类</h3><ul>
<li><strong>单机服务器</strong>: 单独一台计算机作为服务器，适用于小型企业或个人。</li>
<li><strong>集群服务器</strong>: 由多台服务器组成的集群，协同工作以提高性能和可靠性，常见于大企业和数据中心。</li>
<li><strong>虚拟服务器</strong>: 通过虚拟化技术在一台物理服务器上运行多个虚拟服务器，例如 VMware、Hyper-V 等。</li>
</ul>
<h3 id="4-按操作系统分类"><a href="#4-按操作系统分类" class="headerlink" title="4. 按操作系统分类"></a>4. 按操作系统分类</h3><ul>
<li><strong>Windows 服务器</strong>: 运行 Windows Server 操作系统。</li>
<li><strong>Linux 服务器</strong>: 运行各种 Linux 发行版，例如 Ubuntu Server、CentOS 等。</li>
<li><strong>Unix 服务器</strong>: 运行 Unix 或类似 Unix 的操作系统，例如 FreeBSD、AIX 等。</li>
</ul>
<h3 id="5-按部署方式分类"><a href="#5-按部署方式分类" class="headerlink" title="5. 按部署方式分类"></a>5. 按部署方式分类</h3><ul>
<li><strong>本地服务器</strong>: 部署在本地数据中心或机房的服务器。</li>
<li><strong>云服务器</strong>: 部署在云计算平台上的服务器，例如 AWS EC2、Microsoft Azure、Google Cloud 等。</li>
</ul>
<p>Web 服务器属于按用途分类中的一种，专门用于存储和提供网页内容。它们处理客户端（如浏览器）的 HTTP 请求，返回网页资源，如 HTML 文件、图像、样式表和脚本。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>038-网关</title>
    <url>/2024/11/13/038-%E7%BD%91%E5%85%B3/</url>
    <content><![CDATA[<p>网关（Gateway）是一种网络设备，充当不同网络之间的接口或连接点，允许不同网络协议或架构之间的通信。它不仅仅是数据的转发者，还可以进行数据的转换、协议的转换、地址转换和流量控制。以下是关于网关的一些详细信息：</p>
<span id="more"></span>

<h2 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h2><h3 id="1-基本功能"><a href="#1-基本功能" class="headerlink" title="1. 基本功能"></a>1. <strong>基本功能</strong></h3><p>网关在两个不同的网络之间进行数据包的传输和转换。它可以处理不同协议之间的通信，确保数据能够在异构网络之间正确传递。</p>
<h3 id="2-协议转换"><a href="#2-协议转换" class="headerlink" title="2. 协议转换"></a>2. <strong>协议转换</strong></h3><p>网关可以在两个不同协议的网络之间转换数据。例如，从 IPv4 网络到 IPv6 网络，或从 TCP&#x2F;IP 网络到另一种非 IP 网络。</p>
<h3 id="3-应用场景"><a href="#3-应用场景" class="headerlink" title="3. 应用场景"></a>3. <strong>应用场景</strong></h3><p>网关常用于以下场景：</p>
<ul>
<li><strong>企业网络</strong>：在企业内部网与外部互联网之间充当连接点。</li>
<li><strong>家庭网络</strong>：在家庭局域网和互联网之间进行数据传输，通常路由器具有网关功能。</li>
<li><strong>物联网</strong>：在物联网设备和传统网络之间进行数据转换。</li>
</ul>
<h3 id="4-类型"><a href="#4-类型" class="headerlink" title="4. 类型"></a>4. <strong>类型</strong></h3><p>根据功能和应用场景的不同，网关可以分为几种类型：</p>
<ul>
<li><strong>路由器网关</strong>：用于家庭和企业网络的路由器，经常充当网关，连接内部网络和互联网。</li>
<li><strong>防火墙网关</strong>：在网络安全方面起作用，控制内部网络和外部网络之间的通信，防止非法访问。</li>
<li><strong>应用层网关（ALG）</strong>：处理应用层协议，如 HTTP、FTP 等，进行协议转换和数据过滤。</li>
</ul>
<h3 id="5-示例"><a href="#5-示例" class="headerlink" title="5. 示例"></a>5. <strong>示例</strong></h3><ul>
<li><strong>家庭网络网关</strong>：家庭路由器通常作为网关，连接家庭的所有设备到互联网。</li>
<li><strong>企业网关</strong>：企业使用网关连接内部网络到外部网络（如互联网），并可能使用 VPN 网关来实现安全的远程连接。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>网关在现代网络架构中起到关键作用，通过连接和转换不同网络和协议，实现数据的无缝传输。</p>
<h2 id="网关和路由器"><a href="#网关和路由器" class="headerlink" title="网关和路由器"></a>网关和路由器</h2><p>网关和路由器虽然都有连接网络的功能，但它们在用途和功能上有显著的区别。以下是两者的主要区别：</p>
<h3 id="网关-1"><a href="#网关-1" class="headerlink" title="网关"></a>网关</h3><ol>
<li><strong>基本功能</strong>：网关主要用于连接不同类型的网络，负责协议转换和数据传输。它可以在不同协议或架构的网络之间进行通信，例如从 IPv4 到 IPv6 网络，或从 TCP&#x2F;IP 网络到非 IP 网络。</li>
<li><strong>使用场景</strong>：常用于连接两种不同类型的网络，如企业内部网和外部互联网、物联网设备与传统网络等。</li>
<li><strong>协议转换</strong>：网关能够转换不同协议的数据格式，使得不同网络中的设备能够互相通信。</li>
<li><strong>复杂度</strong>：通常比路由器更复杂，因为它需要处理不同协议之间的转换。</li>
</ol>
<h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><ol>
<li><strong>基本功能</strong>：路由器主要用于在同类型的网络之间传输数据包。它根据网络层协议（如 IP 协议）进行数据包的路由选择，确保数据包能够到达正确的目的地。</li>
<li><strong>使用场景</strong>：常用于连接同一类型的网络，如家庭网络和互联网之间的连接，或者企业内部不同子网之间的连接。</li>
<li><strong>数据转发</strong>：路由器主要关注数据包的转发和路由选择，使用路由表来决定数据包的最佳传输路径。</li>
<li><strong>简单性</strong>：相对网关，路由器的功能更简单，因为它主要处理相同协议的数据包转发。</li>
</ol>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>网关</strong>：主要用于连接不同类型的网络，执行协议转换和数据传输。</li>
<li><strong>路由器</strong>：主要用于在同类型的网络之间转发数据包，负责路由选择和数据包传输。</li>
</ul>
<p>通过这两种设备，网络能够实现灵活、高效的通信。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>039-linux-mv</title>
    <url>/2024/11/13/039-linux-mv/</url>
    <content><![CDATA[<p>以下是关于 <code>mv</code> 命令在不同情况下的用法：</p>
<span id="more"></span>

<h2 id="将文件夹移动到另一个文件夹内"><a href="#将文件夹移动到另一个文件夹内" class="headerlink" title="将文件夹移动到另一个文件夹内"></a>将文件夹移动到另一个文件夹内</h2><h3 id="1-将文件夹移动到另一个文件夹内"><a href="#1-将文件夹移动到另一个文件夹内" class="headerlink" title="1. 将文件夹移动到另一个文件夹内"></a>1. <strong>将文件夹移动到另一个文件夹内</strong></h3><p>假设要将文件夹 <code>source_folder</code> 移动到 <code>destination_folder</code> 内：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> source_folder destination_folder/</span><br></pre></td></tr></table></figure>

<p>这样会将 <code>source_folder</code> 以及其中的所有内容移动到 <code>destination_folder</code> 中。</p>
<h3 id="2-将文件夹内的文件移动到另一个文件夹"><a href="#2-将文件夹内的文件移动到另一个文件夹" class="headerlink" title="2. 将文件夹内的文件移动到另一个文件夹"></a>2. <strong>将文件夹内的文件移动到另一个文件夹</strong></h3><p>假设要将 <code>source_folder</code> 中的所有文件移动到 <code>destination_folder</code> 中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> source_folder/* destination_folder/</span><br></pre></td></tr></table></figure>

<p>这会将 <code>source_folder</code> 中的所有文件（不包含子文件夹）移动到 <code>destination_folder</code>。</p>
<p>如果希望同时移动子文件夹，可以使用 <code>-r</code> 选项：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> source_folder/* destination_folder/ -r</span><br></pre></td></tr></table></figure>

<h3 id="3-将文件夹覆盖为另一个文件夹"><a href="#3-将文件夹覆盖为另一个文件夹" class="headerlink" title="3. 将文件夹覆盖为另一个文件夹"></a>3. <strong>将文件夹覆盖为另一个文件夹</strong></h3><p>如果 <code>destination_folder</code> 已经存在，并希望用 <code>source_folder</code> 的内容替换它，可以先删除 <code>destination_folder</code>，再移动 <code>source_folder</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf destination_folder</span><br><span class="line"><span class="built_in">mv</span> source_folder destination_folder</span><br></pre></td></tr></table></figure>

<p>这会先删除 <code>destination_folder</code> 及其内容，然后将 <code>source_folder</code> 重命名为 <code>destination_folder</code>。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>使用 <code>rm -rf</code> 删除时要小心，这将永久删除指定文件夹及其中的所有内容。</li>
</ul>
<h2 id="T-和-t-选项"><a href="#T-和-t-选项" class="headerlink" title="-T 和 -t 选项"></a>-T 和 -t 选项</h2><p><strong>cp</strong>、<strong>install</strong>、<strong>ln</strong> 和 <strong>mv</strong> 命令在处理目录或符号链接到目录时：</p>
<ul>
<li><strong>避免特殊处理</strong>：使用 <strong>-T</strong> 选项可以避免将最后一个操作数作为目录处理，即视为普通文件，防止在共享区域操作时出现竞态条件。不是目录，而是普通文件。</li>
<li><strong>目标目录</strong>：使用 <strong>–target-directory (-t)</strong> 选项可以确保最后一个操作数被视为目录，并在与 <strong>xargs</strong> 配合使用时更加方便。是目录。</li>
<li><strong>处理特殊字符</strong>：结合 <strong>GNU find</strong> 和 <strong>GNU xargs</strong> 可以处理文件名中包含空格或特殊字符的情况。</li>
</ul>
<p>这些选项和方法可以帮助用户更灵活地控制文件操作，避免常见的错误和问题。</p>
<p>如果不加 <code>-T</code> 或 <code>-t</code> 选项，如果最后一个操作数是目录，并且该目录存在，<code>mv</code> 命令会将源目录移动到目标目录下。不加的话，操作效果无法保证。</p>
<h2 id="mv-原理"><a href="#mv-原理" class="headerlink" title="mv 原理"></a>mv 原理</h2><ul>
<li>如果移动一个文件，<code>mv</code> 命令会直接重命名目标文件。</li>
<li>如果移动一个目录，<code>mv</code> 命令会将源目录拷贝到目标目录下，并删除源目录。</li>
<li>如果拷贝失败，<code>mv</code> 命令会清理拷贝的文件，并保留源目录。</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>040-c++递归互斥锁、lock_guard和unique_lock</title>
    <url>/2024/11/14/040-cpp%E9%80%92%E5%BD%92%E4%BA%92%E6%96%A5%E9%94%81%E3%80%81lock_guard%E5%92%8Cunique_lock/</url>
    <content><![CDATA[<p><code>std::recursive_mutex</code>可以在同一个线程中嵌套使用。介绍了 lock_guard 和 mutex 是什么关系, lock_guard 和 unique_lock 的区别</p>
<span id="more"></span>

<p><code>std::recursive_mutex</code>是一种递归锁，它允许同一线程多次加锁而不会导致死锁。在使用普通的<code>std::mutex</code>时，同一线程如果多次尝试加锁会造成死锁；而<code>std::recursive_mutex</code>则不会。它会跟踪当前线程的加锁次数，并在解锁时，只有当解锁次数与加锁次数相同时，锁才会真正释放。</p>
<p>以下是一个简单的示例，展示了如何在同一线程中嵌套使用<code>std::recursive_mutex</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::recursive_mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recursiveFunction</span><span class="params">(<span class="type">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    mtx.<span class="built_in">lock</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Lock acquired, count = &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归调用</span></span><br><span class="line">    <span class="built_in">recursiveFunction</span>(count - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Releasing lock, count = &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">    mtx.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(recursiveFunction, <span class="number">3</span>)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>recursiveFunction</code>函数递归调用自己，每次调用时都会加锁，直到<code>count</code>为零时停止递归。由于使用了<code>std::recursive_mutex</code>，即使在同一线程中多次加锁，也不会发生死锁。</p>
<h2 id="lock-guard-和-mutex-是什么关系"><a href="#lock-guard-和-mutex-是什么关系" class="headerlink" title="lock_guard 和 mutex 是什么关系"></a>lock_guard 和 mutex 是什么关系</h2><p><code>std::lock_guard</code>和<code>std::mutex</code>在 C++中是协同使用的关系。<code>std::lock_guard</code>是一个用于管理<code>std::mutex</code>（或其他锁类型）的 RAII（资源获取即初始化）机制，旨在更安全和便捷地管理互斥锁的加锁和解锁过程。</p>
<h3 id="它们的关系"><a href="#它们的关系" class="headerlink" title="它们的关系"></a>它们的关系</h3><ul>
<li>**<code>std::mutex</code>**：是 C++标准库中提供的基础互斥锁类，用于在线程间保护共享资源，避免数据竞争。通过显式调用<code>lock()</code>和<code>unlock()</code>函数加锁和解锁来控制对共享资源的访问。</li>
<li>**<code>std::lock_guard</code>**：是一个模板类，用于自动管理<code>std::mutex</code>的加锁和解锁操作。它在构造时自动对传入的<code>std::mutex</code>对象加锁，在销毁时（通常是作用域结束时）自动解锁。因此，使用<code>std::lock_guard</code>可以确保即使在异常或函数提前返回时，锁也会被正确释放。</li>
</ul>
<h3 id="为什么要使用std-lock-guard"><a href="#为什么要使用std-lock-guard" class="headerlink" title="为什么要使用std::lock_guard"></a>为什么要使用<code>std::lock_guard</code></h3><p>如果手动控制<code>std::mutex</code>的加锁和解锁，很容易因漏掉解锁操作或在出现异常时未释放锁而导致死锁。<code>std::lock_guard</code>简化了这一过程，通过在其生命周期内自动加锁和解锁，确保了代码的安全性和可读性。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safeFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 lock_guard 管理 mtx 的加锁和解锁</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 临界区，安全访问共享资源</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; is in critical section.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock 离开作用域后会自动解锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(safeFunction)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(safeFunction)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>std::lock_guard</code>构造时会锁住<code>mtx</code>，在<code>safeFunction</code>结束时，<code>std::lock_guard</code>自动析构并解锁，从而避免了手动解锁可能带来的问题。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>std::lock_guard</code>和<code>std::mutex</code>是合作关系：<code>std::mutex</code>是互斥锁的实现，而<code>std::lock_guard</code>是用于自动管理<code>std::mutex</code>加锁和解锁的工具。</p>
<h2 id="lock-guard-和-unique-lock-的区别"><a href="#lock-guard-和-unique-lock-的区别" class="headerlink" title="lock_guard 和 unique_lock 的区别"></a>lock_guard 和 unique_lock 的区别</h2><p><code>std::lock_guard</code>和<code>std::unique_lock</code>都是用于管理<code>std::mutex</code>的 RAII 类型锁，但它们在功能和灵活性上有一些区别。下面详细解释它们的差异。</p>
<h3 id="1-锁的灵活性"><a href="#1-锁的灵活性" class="headerlink" title="1. 锁的灵活性"></a>1. 锁的灵活性</h3><ul>
<li>**<code>std::lock_guard</code>**：<code>std::lock_guard</code>非常简单，在构造时自动加锁，并且在析构时自动解锁。它没有提供其他任何锁管理的接口，因此无法手动解锁后再重新加锁。</li>
<li>**<code>std::unique_lock</code>**：<code>std::unique_lock</code>更灵活，它提供了加锁、解锁和重锁的功能。你可以在代码中选择性地调用<code>lock()</code>和<code>unlock()</code>来手动控制锁的状态。</li>
</ul>
<h3 id="2-延迟加锁和解锁"><a href="#2-延迟加锁和解锁" class="headerlink" title="2. 延迟加锁和解锁"></a>2. 延迟加锁和解锁</h3><ul>
<li>**<code>std::lock_guard</code>**：在创建<code>std::lock_guard</code>对象时必须立即加锁，没有延迟加锁的选项。</li>
<li>**<code>std::unique_lock</code>**：支持延迟加锁，即可以在构造时不加锁，稍后在需要的时候调用<code>lock()</code>来加锁。可以使用<code>std::defer_lock</code>标志来延迟加锁。</li>
</ul>
<h3 id="3-条件变量的支持"><a href="#3-条件变量的支持" class="headerlink" title="3. 条件变量的支持"></a>3. 条件变量的支持</h3><ul>
<li>**<code>std::lock_guard</code>**：无法与<code>std::condition_variable</code>配合使用，因为条件变量要求能够临时解锁和重新加锁，这需要更灵活的锁管理。</li>
<li>**<code>std::unique_lock</code>**：可以与<code>std::condition_variable</code>配合使用。在等待条件变量时，<code>std::unique_lock</code>可以暂时解锁互斥锁，以便其他线程获得锁，并在条件满足后重新加锁。</li>
</ul>
<h3 id="4-开销"><a href="#4-开销" class="headerlink" title="4. 开销"></a>4. 开销</h3><ul>
<li>**<code>std::lock_guard</code>**：轻量级，没有额外的状态信息，因为它一旦加锁，就保持锁定状态直到销毁。适用于简单的场景。</li>
<li>**<code>std::unique_lock</code>**：稍微重一些，因为它维护了更多的状态信息（比如是否锁定、是否延迟等），以便支持更多功能。适用于需要灵活控制锁的场景。</li>
</ul>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><h4 id="std-lock-guard"><a href="#std-lock-guard" class="headerlink" title="std::lock_guard"></a><code>std::lock_guard</code></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safeFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;  <span class="comment">// 构造时自动加锁</span></span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; is in critical section.\n&quot;</span>;</span><br><span class="line">&#125;  <span class="comment">// 作用域结束，自动解锁</span></span><br></pre></td></tr></table></figure>

<h4 id="std-unique-lock"><a href="#std-unique-lock" class="headerlink" title="std::unique_lock"></a><code>std::unique_lock</code></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">waitingThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;  <span class="comment">// 构造时加锁</span></span><br><span class="line">    cv.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> ready; &#125;);     <span class="comment">// 等待条件变量，期间自动解锁并在条件满足后重新加锁</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; finished waiting.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setReady</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    ready = <span class="literal">true</span>;</span><br><span class="line">    cv.<span class="built_in">notify_all</span>();  <span class="comment">// 唤醒所有等待的线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(waitingThread)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(setReady)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th>特性</th>
<th><code>std::lock_guard</code></th>
<th><code>std::unique_lock</code></th>
</tr>
</thead>
<tbody><tr>
<td>加锁和解锁灵活性</td>
<td>固定，只能自动加锁和解锁</td>
<td>灵活，支持手动加锁、解锁、重新加锁</td>
</tr>
<tr>
<td>延迟加锁</td>
<td>不支持</td>
<td>支持，通过<code>std::defer_lock</code>指定</td>
</tr>
<tr>
<td>条件变量支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>适用场景</td>
<td>简单加锁、解锁</td>
<td>需要更多锁管理控制的复杂场景</td>
</tr>
<tr>
<td>性能</td>
<td>更轻量级</td>
<td>较重，带有额外状态信息</td>
</tr>
</tbody></table>
<p>总体而言，如果只需要简单的加锁解锁，<code>std::lock_guard</code>更合适；如果需要更灵活的锁控制（如条件变量、延迟加锁等），则<code>std::unique_lock</code>是更好的选择。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>c++11</tag>
      </tags>
  </entry>
  <entry>
    <title>041-c++ learning</title>
    <url>/2024/11/14/041-cpp-learning/</url>
    <content><![CDATA[<p>自用 c++ 学习资料</p>
<span id="more"></span>

<h2 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h2><h3 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h3><ul>
<li>《c++ primer 5th》</li>
<li>《Effective c++》</li>
<li>《Effective modern c++》<a href="https://cntransgroup.github.io/EffectiveModernCppChinese/">中文</a></li>
<li>《Google c++ style guide》<a href="https://zh-google-styleguide.readthedocs.io/en/stable/google-cpp-styleguide/contents.html">中文</a>, <a href="https://google.github.io/styleguide/cppguide.html">英文</a></li>
<li>《C++ Concurrency in Action》</li>
</ul>
<h3 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h3><ul>
<li>cppreference <a href="https://zh.cppreference.com/w/">中文</a>, <a href="https://en.cppreference.com/w/">英文</a></li>
</ul>
<h3 id="c-库"><a href="#c-库" class="headerlink" title="c++库"></a>c++库</h3><ul>
<li><a href="https://www.boost.org/">boost</a></li>
<li><a href="https://github.com/fffaraz/awesome-cpp">awesome-cpp</a></li>
<li><a href="https://zh.cppreference.com/w/cpp/links/libs">开源 C++ 库- cppreference</a></li>
</ul>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ul>
<li><a href="https://pubs.opengroup.org/onlinepubs/7908799/index.html">header</a></li>
<li><a href="https://c.runoob.com/compile/12/">c++在线编译</a></li>
<li><a href="https://www.geeksforgeeks.org/cpp-data-types/?ref=shm">c++数据类型</a></li>
<li><a href="https://blog.csdn.net/rongrongyaofeiqi/article/details/52442169">c++数据类型转换</a></li>
</ul>
<h3 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h3><ul>
<li><a href="https://roadmap.sh/cpp">c++学习路线</a></li>
<li><a href="https://light-city.github.io/stories_things/">c++那些事-光城</a></li>
<li><a href="https://changkun.de/modern-cpp/zh-cn/00-preface/">现代 c++教程-changkun</a></li>
<li><a href="https://www.cnblogs.com/cate/cpp/">博客园-c++</a></li>
</ul>
<h3 id="常用-c-库"><a href="#常用-c-库" class="headerlink" title="常用 c++库"></a>常用 c++库</h3><ul>
<li>信息源:<ul>
<li><a href="https://github.com/fffaraz/awesome-cpp#readme">awesome-cpp</a></li>
<li><a href="https://github.com/sindresorhus/awesome?tab=readme-ov-file#readme">awesome</a></li>
</ul>
</li>
<li>日志:<ul>
<li><a href="https://github.com/gabime/spdlog">spdlog</a></li>
</ul>
</li>
<li>事件:<ul>
<li><a href="https://github.com/ithewei/libhv">libhv</a></li>
<li><a href="https://github.com/libevent/libevent">libevent</a></li>
</ul>
</li>
<li>JSON:<ul>
<li><a href="https://github.com/nlohmann/json">nlohmann-json</a></li>
</ul>
</li>
<li>CSV:<ul>
<li><a href="https://github.com/ben-strasser/fast-cpp-csv-parser">fast-cpp-csv-parser</a></li>
</ul>
</li>
<li>SCPI:<ul>
<li><a href="https://github.com/j123b567/scpi-parser">scpi-parser</a></li>
</ul>
</li>
<li>网络:<ul>
<li>socket:<ul>
<li><a href="https://github.com/yhirose/cpp-httplib">cpp-httplib</a></li>
</ul>
</li>
<li>webserver:<ul>
<li><a href="https://github.com/qinguoyi/TinyWebServer">TinyWebServer</a></li>
</ul>
</li>
</ul>
</li>
<li>并发:<ul>
<li>并发队列:<ul>
<li><a href="https://github.com/cameron314/concurrentqueue">concurrentqueue</a></li>
</ul>
</li>
<li>线程池:<ul>
<li><a href="https://github.com/progschj/ThreadPool">progschj thread-pool</a></li>
<li><a href="https://github.com/mtrebi/thread-pool">mtrebi thread-pool</a></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>learning</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>042-network-learning</title>
    <url>/2024/11/14/042-network-learning/</url>
    <content><![CDATA[<p>计算机网络学习资料</p>
<span id="more"></span>

<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h3><ul>
<li>《网络是怎样连接的》</li>
</ul>
<h3 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h3><ul>
<li><a href="https://xiaolincoding.com/network/">图解网络 - 小林 coding</a></li>
</ul>
]]></content>
      <categories>
        <category>learning</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>043-CMake和MinGW的关系</title>
    <url>/2024/11/15/043-CMake%E5%92%8CMinGW%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h2 id="CMake-和-MinGW-的关系"><a href="#CMake-和-MinGW-的关系" class="headerlink" title="CMake 和 MinGW 的关系"></a>CMake 和 MinGW 的关系</h2><p>让我为你解释 CMake 和 MinGW 的关系：</p>
<h3 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h3><ul>
<li>CMake 是一个<strong>跨平台的构建系统生成器</strong></li>
<li>它不直接编译代码，而是生成其他构建系统使用的文件，比如：<ul>
<li>Windows 上的 Visual Studio 项目文件</li>
<li>Unix 上的 Makefile</li>
<li>MinGW 的 Makefile</li>
</ul>
</li>
</ul>
<h3 id="MinGW"><a href="#MinGW" class="headerlink" title="MinGW"></a>MinGW</h3><ul>
<li>MinGW (Minimalist GNU for Windows) 是一个<strong>编译工具链</strong></li>
<li>包含以下核心组件：<ul>
<li>gcc (编译器)</li>
<li>g++ (C++编译器)</li>
<li>mingw32-make (Make 工具)</li>
<li>其他 GNU 工具</li>
</ul>
</li>
</ul>
<h3 id="它们的关系"><a href="#它们的关系" class="headerlink" title="它们的关系"></a>它们的关系</h3><ol>
<li><p><strong>配合使用</strong></p>
<ul>
<li>CMake 生成 Makefile</li>
<li>MinGW 的 mingw32-make 读取 Makefile 并调用 gcc&#x2F;g++ 进行实际的编译</li>
</ul>
</li>
<li><p><strong>工作流程</strong></p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CMakeLists.txt --[CMake生成]--&gt; Makefile --[MinGW执行]--&gt; 可执行文件</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>实际例子</strong>：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 CMake 生成 Makefile</span></span><br><span class="line">cmake -G <span class="string">&quot;MinGW Makefiles&quot;</span> .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 MinGW 的 make 工具编译</span></span><br><span class="line">mingw32-make</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>角色定位</strong></li>
</ol>
<ul>
<li>CMake: 项目构建配置工具</li>
<li>MinGW: 实际的编译工具链</li>
</ul>
<p>简单来说，CMake 是”设计图纸”，MinGW 是”建筑工具”，两者配合完成代码的构建过程。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>044-websocket和http的区别</title>
    <url>/2024/11/15/044-websocket%E5%92%8Chttp%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>WebSocket 和 HTTP 是两种不同的通信协议，它们各自有不同的特点和使用场景。以下是它们的主要区别：</p>
<span id="more"></span>

<ol>
<li><p><strong>连接方式</strong>：</p>
<ul>
<li><strong>HTTP</strong>：基于请求-响应模型，客户端发送请求，服务器响应后连接关闭。每次通信都需要重新建立连接。</li>
<li><strong>WebSocket</strong>：是一种全双工协议，在初始握手阶段通过 HTTP 连接建立。握手完成后，连接会升级为 WebSocket，保持长期连接，支持实时双向通信。</li>
</ul>
</li>
<li><p><strong>通信模式</strong>：</p>
<ul>
<li><strong>HTTP</strong>：基于无状态、单向的短连接通信。客户端只能主动向服务器发送请求，服务器只能被动响应。</li>
<li><strong>WebSocket</strong>：支持双向通信，允许客户端和服务器之间主动发送和接收数据，适合实时数据更新。</li>
</ul>
</li>
<li><p><strong>连接保持</strong>：</p>
<ul>
<li><strong>HTTP</strong>：默认短连接（除非使用 HTTP&#x2F;1.1 的 keep-alive），在一次请求-响应完成后会断开连接。</li>
<li><strong>WebSocket</strong>：连接一旦建立，将一直保持打开状态，直到客户端或服务器主动断开。</li>
</ul>
</li>
<li><p><strong>数据传输效率</strong>：</p>
<ul>
<li><strong>HTTP</strong>：每次请求都会发送完整的 HTTP 头部，增加了额外的带宽开销。</li>
<li><strong>WebSocket</strong>：一次握手后，后续通信只需发送少量的头部信息，数据传输更加高效，适合高频通信的场景。</li>
</ul>
</li>
<li><p><strong>适用场景</strong>：</p>
<ul>
<li><strong>HTTP</strong>：适用于请求-响应模式的应用场景，如网页加载、文件下载、API 请求等。</li>
<li><strong>WebSocket</strong>：适用于实时通信场景，如聊天室、在线游戏、股票行情推送、物联网数据传输等。</li>
</ul>
</li>
</ol>
<p>总结来说，HTTP 适合短连接和请求-响应式的数据交换，而 WebSocket 更适合实时性、双向通信的长连接需求。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>045-operate-system-learning</title>
    <url>/2024/11/15/045-operate-system-learning/</url>
    <content><![CDATA[<p>操作系统是计算机系统的核心软件，负责管理硬件资源、提供系统服务、支持应用程序运行，并协调多任务和多用户之间的交互。</p>
<span id="more"></span>

<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h3><ul>
<li>《现代操作系统:原理与实现》</li>
</ul>
]]></content>
      <categories>
        <category>learning</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>046-异常和中断的区别</title>
    <url>/2024/11/15/046-%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%AD%E6%96%AD%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>在程序设计和操作系统中，<strong>异常</strong>和<strong>中断</strong>都是用来处理异常情况或外部事件的机制，但它们的触发方式、目的以及处理机制有所不同。</p>
<h2 id="异常和中断的区别"><a href="#异常和中断的区别" class="headerlink" title="异常和中断的区别"></a>异常和中断的区别</h2><span id="more"></span>

<h3 id="1-触发方式"><a href="#1-触发方式" class="headerlink" title="1. 触发方式"></a>1. 触发方式</h3><ul>
<li><strong>异常</strong>：由程序内部的指令导致。例如除零、非法访问内存、无效的操作码等。异常通常是在指令执行过程中由 CPU 检测并报告给操作系统。</li>
<li><strong>中断</strong>：由外部设备或系统事件触发。例如定时器中断、I&#x2F;O 设备中断、外设请求等。中断信号通常来自硬件，告诉 CPU 有紧急事件需要处理。</li>
</ul>
<h3 id="2-目的"><a href="#2-目的" class="headerlink" title="2. 目的"></a>2. 目的</h3><ul>
<li><strong>异常</strong>：主要用于报告和处理程序运行中的错误或意外情况，以便让操作系统或程序决定如何应对。</li>
<li><strong>中断</strong>：用于响应硬件事件或定期执行某些任务，比如键盘输入、网络数据到达等，让操作系统能够及时处理硬件请求。</li>
</ul>
<h3 id="3-处理机制"><a href="#3-处理机制" class="headerlink" title="3. 处理机制"></a>3. 处理机制</h3><ul>
<li><strong>异常处理</strong>：异常通常会暂停当前指令执行，保存程序状态，并进入异常处理程序。异常处理程序可能会执行错误恢复、进程终止、日志记录等操作。</li>
<li><strong>中断处理</strong>：中断信号到达后，CPU 保存当前执行状态并跳转到对应的中断服务程序（ISR）。中断处理程序一般尽量短小高效，快速处理硬件请求后，返回继续执行被中断的程序。</li>
</ul>
<h3 id="4-程序与系统表现"><a href="#4-程序与系统表现" class="headerlink" title="4. 程序与系统表现"></a>4. 程序与系统表现</h3><ul>
<li><strong>异常</strong>：异常的出现意味着程序中存在错误或不正常的情况，它一般由 CPU 自动处理，可能导致程序中断或终止。</li>
<li><strong>中断</strong>：中断不一定表示程序错误，而是硬件请求 CPU 服务的正常信号。中断的处理不会导致程序终止，而是在处理完毕后恢复程序执行。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>简单来说，<strong>异常</strong>是程序运行过程中由 CPU 报告的内部问题，而<strong>中断</strong>是外部设备请求 CPU 处理的事件。异常通常代表程序的某种错误，而中断则是系统正常处理硬件和软件事件的一部分。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>047-操作系统上下文切换</title>
    <url>/2024/11/15/047-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/</url>
    <content><![CDATA[<p>在操作系统中，<strong>上下文切换</strong>（Context Switch）指的是将 CPU 从一个进程或线程切换到另一个进程或线程的过程。这一机制使得多任务操作系统可以在多个任务之间来回切换，实现“并发”运行。</p>
<span id="more"></span>

<h3 id="1-上下文切换的目的"><a href="#1-上下文切换的目的" class="headerlink" title="1. 上下文切换的目的"></a>1. 上下文切换的目的</h3><p>上下文切换是多任务操作系统的核心特性，使得多个进程或线程可以共享 CPU 时间，从而提升系统资源的利用率和用户的使用体验。通过快速切换，操作系统在表面上呈现出多个程序同时运行的效果（即并发）。</p>
<h3 id="2-上下文切换的过程"><a href="#2-上下文切换的过程" class="headerlink" title="2. 上下文切换的过程"></a>2. 上下文切换的过程</h3><p>上下文切换主要涉及三个步骤：</p>
<ul>
<li><p><strong>保存当前任务的上下文</strong>：将当前正在执行的任务的状态（称为<strong>上下文</strong>）保存到它的控制块（PCB 或 TCB）中。上下文信息包括 CPU 寄存器、程序计数器、堆栈指针等，它们表示当前任务的执行状态。</p>
</li>
<li><p><strong>加载新任务的上下文</strong>：从新的任务的控制块中读取其保存的上下文信息，恢复到 CPU 寄存器，以便新任务从中断点或挂起位置继续执行。</p>
</li>
<li><p><strong>执行调度策略</strong>：操作系统调度器决定下一个要运行的任务。它根据调度算法（例如时间片轮转、优先级调度等）选择下一个任务，并执行上下文恢复。</p>
</li>
</ul>
<h3 id="3-上下文切换的开销"><a href="#3-上下文切换的开销" class="headerlink" title="3. 上下文切换的开销"></a>3. 上下文切换的开销</h3><p>上下文切换涉及到大量寄存器信息的保存与恢复，同时还会导致 CPU 缓存失效（缓存污染），所以频繁的上下文切换会对系统性能产生负面影响。因此，设计良好的调度算法和合适的时间片分配是平衡系统响应速度和性能的重要策略。</p>
<h3 id="4-上下文切换的分类"><a href="#4-上下文切换的分类" class="headerlink" title="4. 上下文切换的分类"></a>4. 上下文切换的分类</h3><ul>
<li><strong>进程上下文切换</strong>：涉及到切换整个进程的上下文。由于进程之间的地址空间是隔离的，因此进程切换时需要刷新页表等资源。</li>
<li><strong>线程上下文切换</strong>：线程属于同一进程，可以共享同一地址空间，因此切换时不需要切换地址空间信息（如页表），开销相对较小。</li>
</ul>
<h3 id="5-上下文切换的触发条件"><a href="#5-上下文切换的触发条件" class="headerlink" title="5. 上下文切换的触发条件"></a>5. 上下文切换的触发条件</h3><p>上下文切换通常由以下事件触发：</p>
<ul>
<li><strong>时间片耗尽</strong>：线程执行的时间片结束，调度器强制切换。</li>
<li><strong>I&#x2F;O 或系统调用</strong>：任务在等待 I&#x2F;O 操作完成或进行系统调用时可能被挂起，CPU 调度给其他任务。</li>
<li><strong>优先级调度</strong>：一个更高优先级的任务需要执行，系统会进行上下文切换来执行高优先级任务。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上下文切换是多任务操作系统实现并发的重要机制，尽管开销不可避免，但有效的调度可以最小化对系统性能的影响。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>048-今天换页机制是否仍然有必要</title>
    <url>/2024/11/18/048-%E4%BB%8A%E5%A4%A9%E6%8D%A2%E9%A1%B5%E6%9C%BA%E5%88%B6%E6%98%AF%E5%90%A6%E4%BB%8D%E7%84%B6%E6%9C%89%E5%BF%85%E8%A6%81/</url>
    <content><![CDATA[<h2 id="在现代计算机内存容量和价格的变化下，是否还需要换页机制？"><a href="#在现代计算机内存容量和价格的变化下，是否还需要换页机制？" class="headerlink" title="在现代计算机内存容量和价格的变化下，是否还需要换页机制？"></a><strong>在现代计算机内存容量和价格的变化下，是否还需要换页机制？</strong></h2><span id="more"></span>

<p>回答：<br>换页机制依然非常重要，原因如下：</p>
<ol>
<li><p><strong>资源优化分配</strong><br>即使内存容量增大，但在多任务操作系统中，内存需求往往远大于物理内存。换页机制允许操作系统根据需要动态分配内存，保证资源分配更加灵活和高效。</p>
</li>
<li><p><strong>支持多进程运行</strong><br>换页机制通过虚拟内存的方式，为每个进程提供独立的地址空间，使得多个程序可以同时运行，而不必受物理内存大小的严格限制。</p>
</li>
<li><p><strong>减少程序约束</strong><br>换页机制使得开发者无需关注物理内存的实际大小，可以编写超出物理内存限制的大型程序，而不必担心内存不足的问题。</p>
</li>
<li><p><strong>成本与扩展性考虑</strong><br>虽然内存价格下降，但无限制地扩展物理内存并不现实。换页机制提供了一种高效的解决方案，可以用较小的物理内存结合磁盘空间，满足大规模应用的需求。</p>
</li>
<li><p><strong>提升系统稳定性</strong><br>在极端情况下（例如瞬时高内存需求），如果没有换页机制，系统可能会崩溃，而换页机制能通过磁盘作为后备存储，保障系统稳定运行。</p>
</li>
</ol>
<p>结论：<br>换页机制是现代操作系统的重要基础，即使物理内存容量增加且价格下降，其在资源管理和系统稳定性中的作用仍然不可或缺。</p>
<h2 id="假设物理内存足够大，虚拟内存是否有存在的必要？如果不使用虚拟内存抽象，恢复到只用物理内存寻址，会带来哪些改变？"><a href="#假设物理内存足够大，虚拟内存是否有存在的必要？如果不使用虚拟内存抽象，恢复到只用物理内存寻址，会带来哪些改变？" class="headerlink" title="假设物理内存足够大，虚拟内存是否有存在的必要？如果不使用虚拟内存抽象，恢复到只用物理内存寻址，会带来哪些改变？"></a>假设物理内存足够大，虚拟内存是否有存在的必要？如果不使用虚拟内存抽象，恢复到只用物理内存寻址，会带来哪些改变？</h2><p>即使物理内存足够大，虚拟内存仍然是必要的。让我解释一下原因：</p>
<h3 id="虚拟内存的重要作用"><a href="#虚拟内存的重要作用" class="headerlink" title="虚拟内存的重要作用"></a>虚拟内存的重要作用</h3><ol>
<li><p><strong>内存隔离与保护</strong></p>
<ul>
<li>每个进程都有自己的独立地址空间</li>
<li>防止进程间相互干扰</li>
<li>提供访问权限控制（读&#x2F;写&#x2F;执行）</li>
</ul>
</li>
<li><p><strong>地址空间统一</strong></p>
<ul>
<li>程序可以使用连续的地址空间</li>
<li>实际物理内存可以是不连续的</li>
<li>简化了程序的开发和加载</li>
</ul>
</li>
<li><p><strong>共享内存实现</strong></p>
<ul>
<li>多个进程可以映射同一块物理内存</li>
<li>便于进程间通信</li>
<li>节省内存（共享库）</li>
</ul>
</li>
</ol>
<h3 id="不使用虚拟内存的后果"><a href="#不使用虚拟内存的后果" class="headerlink" title="不使用虚拟内存的后果"></a>不使用虚拟内存的后果</h3><ol>
<li><strong>安全问题</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">进程A: 可以直接访问进程B的内存</span><br><span class="line">结果: 数据泄露、程序崩溃、系统不稳定</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>开发复杂性</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用虚拟内存</span></span><br><span class="line"><span class="type">char</span> *buffer = <span class="built_in">malloc</span>(<span class="number">1024</span>);  <span class="comment">// 简单分配连续空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不使用虚拟内存</span></span><br><span class="line"><span class="type">char</span> *buffer = find_physical_memory_gaps(<span class="number">1024</span>);  <span class="comment">// 需要处理物理内存碎片</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p><strong>内存管理困难</strong></p>
<ul>
<li>内存碎片化严重</li>
<li>程序加载位置固定</li>
<li>动态库共享困难</li>
</ul>
</li>
<li><p><strong>多任务支持受限</strong></p>
<ul>
<li>进程切换复杂</li>
<li>内存布局冲突</li>
<li>难以实现进程隔离</li>
</ul>
</li>
</ol>
<p>因此，虚拟内存不仅仅是为了解决物理内存不足的问题，更是现代操作系统中实现安全性、隔离性和易用性的重要基础。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>049-data-structure-and-algorithm-learning</title>
    <url>/2024/11/19/049-data-structure-and-algorithm-learning/</url>
    <content><![CDATA[<p>数据结构与算法是计算机科学的基础，是解决实际问题的关键。</p>
<span id="more"></span>

<h3 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h3><ul>
<li>《大话数据结构》</li>
</ul>
<h3 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h3><ul>
<li><a href="https://www.hello-algo.com/">Hello 算法</a></li>
</ul>
]]></content>
      <categories>
        <category>learning</category>
      </categories>
  </entry>
  <entry>
    <title>050-线程与进程</title>
    <url>/2024/11/19/050-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<p>进程是操作系统对一个正在运行的程序的一种抽象。线程是进程中的一个执行单元。</p>
<span id="more"></span>

<h2 id="为什么不用类似于-fork-的方式创建线程"><a href="#为什么不用类似于-fork-的方式创建线程" class="headerlink" title="为什么不用类似于 fork 的方式创建线程"></a>为什么不用类似于 fork 的方式创建线程</h2><h3 id="fork-创建进程的特点"><a href="#fork-创建进程的特点" class="headerlink" title="fork 创建进程的特点"></a>fork 创建进程的特点</h3><ol>
<li><strong>资源复制</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pid_t</span> pid = fork();</span><br><span class="line"><span class="comment">// fork会复制：</span></span><br><span class="line"><span class="comment">// - 内存空间</span></span><br><span class="line"><span class="comment">// - 文件描述符</span></span><br><span class="line"><span class="comment">// - 程序计数器</span></span><br><span class="line"><span class="comment">// 等所有资源</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>开销大</strong><ul>
<li>需要复制整个进程地址空间</li>
<li>创建新的页表</li>
<li>复制文件描述符表</li>
</ul>
</li>
</ol>
<h3 id="线程的设计目的"><a href="#线程的设计目的" class="headerlink" title="线程的设计目的"></a>线程的设计目的</h3><ol>
<li><strong>轻量级任务切换</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pthread_t</span> thread;</span><br><span class="line">pthread_create(&amp;thread, <span class="literal">NULL</span>, thread_func, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 线程共享：</span></span><br><span class="line"><span class="comment">// - 代码段</span></span><br><span class="line"><span class="comment">// - 堆空间</span></span><br><span class="line"><span class="comment">// - 文件描述符</span></span><br><span class="line"><span class="comment">// 仅独立：</span></span><br><span class="line"><span class="comment">// - 栈空间</span></span><br><span class="line"><span class="comment">// - 寄存器</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>资源共享优势</strong><ul>
<li>线程间通信成本低</li>
<li>上下文切换快</li>
<li>内存占用小</li>
</ul>
</li>
</ol>
<h3 id="如果用-fork-方式创建线程会带来的问题"><a href="#如果用-fork-方式创建线程会带来的问题" class="headerlink" title="如果用 fork 方式创建线程会带来的问题"></a>如果用 fork 方式创建线程会带来的问题</h3><ol>
<li><strong>性能问题</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建100个线程：</span><br><span class="line">- 当前方式：只需要分配100个栈空间</span><br><span class="line">- fork方式：需要复制100次整个进程空间</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><strong>资源浪费</strong></p>
<ul>
<li>大量重复的内存页</li>
<li>不必要的资源隔离</li>
<li>系统开销增加</li>
</ul>
</li>
<li><p><strong>通信困难</strong></p>
<ul>
<li>失去了共享内存的便利</li>
<li>需要使用 IPC 机制</li>
<li>效率降低</li>
</ul>
</li>
</ol>
<p>因此，线程的设计初衷就是要比进程更轻量级，如果用 fork 方式创建线程，就违背了这个设计初衷，失去了线程的主要优势。</p>
<h2 id="Linux-中-一个多线程进程使用-fork-生成了一个新进程-新进程中会存在几个线程-为什么要这么设计"><a href="#Linux-中-一个多线程进程使用-fork-生成了一个新进程-新进程中会存在几个线程-为什么要这么设计" class="headerlink" title="Linux 中,一个多线程进程使用 fork 生成了一个新进程, 新进程中会存在几个线程? 为什么要这么设计"></a>Linux 中,一个多线程进程使用 fork 生成了一个新进程, 新进程中会存在几个线程? 为什么要这么设计</h2><p>让我解释 Linux 中 fork 多线程进程的行为：</p>
<h3 id="基本行为"><a href="#基本行为" class="headerlink" title="基本行为"></a>基本行为</h3><ol>
<li><strong>只复制调用 fork 的线程</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主进程有3个线程</span></span><br><span class="line"><span class="type">pthread_t</span> thread1, thread2;</span><br><span class="line">pthread_create(&amp;thread1, <span class="literal">NULL</span>, func1, <span class="literal">NULL</span>);</span><br><span class="line">pthread_create(&amp;thread2, <span class="literal">NULL</span>, func2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> pid = fork();  <span class="comment">// 假设在thread1中调用</span></span><br><span class="line"><span class="comment">// 子进程只会包含thread1的副本</span></span><br></pre></td></tr></table></figure>

<h3 id="为什么这样设计"><a href="#为什么这样设计" class="headerlink" title="为什么这样设计"></a>为什么这样设计</h3><ol>
<li><strong>安全性考虑</strong><ul>
<li>如果复制所有线程，可能导致：</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线程2正在进行文件写入</span></span><br><span class="line">write(fd, data, size);</span><br><span class="line"><span class="comment">// fork发生</span></span><br><span class="line"><span class="comment">// 子进程的线程2会从中间继续执行</span></span><br><span class="line"><span class="comment">// 导致文件数据重复或损坏</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>死锁风险</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mutex_lock(&amp;mutex);  <span class="comment">// 线程2持有锁</span></span><br><span class="line"><span class="comment">// fork发生</span></span><br><span class="line"><span class="comment">// 子进程中没有线程2，锁永远无法释放</span></span><br><span class="line"><span class="comment">// 导致死锁</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>实现复杂性</strong><ul>
<li>复制所有线程需要：<ul>
<li>重建线程间的同步关系</li>
<li>复制所有线程的上下文</li>
<li>处理线程池等复杂结构</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ol>
<li><strong>fork 后立即 exec</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 子进程：立即执行新程序</span></span><br><span class="line">    execv(path, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>在主线程中 fork</strong><ul>
<li>避免在子线程中调用 fork</li>
<li>减少不确定性</li>
<li>更容易管理资源</li>
</ul>
</li>
</ol>
<p>这种设计既保证了安全性，又简化了实现，是一个合理的折中方案。</p>
<h2 id="编写至少两种使用-fork-的程序-使-fork-执行失败-并解释-fork-失败的原因"><a href="#编写至少两种使用-fork-的程序-使-fork-执行失败-并解释-fork-失败的原因" class="headerlink" title="编写至少两种使用 fork 的程序, 使 fork 执行失败, 并解释 fork 失败的原因"></a>编写至少两种使用 fork 的程序, 使 fork 执行失败, 并解释 fork 失败的原因</h2><p>让我展示两种让 fork 失败的程序：</p>
<h3 id="1-耗尽系统进程数限制"><a href="#1-耗尽系统进程数限制" class="headerlink" title="1. 耗尽系统进程数限制"></a>1. 耗尽系统进程数限制</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        pid_t pid = fork();</span><br><span class="line">        if (pid &lt; 0) &#123;</span><br><span class="line">            printf(&quot;Fork失败: %s\n&quot;, strerror(errno));</span><br><span class="line">            printf(&quot;成功创建进程数: %d\n&quot;, count);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">        if (pid == 0) &#123;</span><br><span class="line">            // 子进程睡眠不退出，占用进程表</span><br><span class="line">            sleep(100);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>失败原因：</strong></p>
<ul>
<li>系统有最大进程数限制（通过<code>ulimit -u</code>可查看）</li>
<li>当达到限制时，fork 会失败并返回 EAGAIN 错误</li>
</ul>
<h3 id="2-耗尽系统内存"><a href="#2-耗尽系统内存" class="headerlink" title="2. 耗尽系统内存"></a>2. 耗尽系统内存</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">#define ALLOC_SIZE (100*1024*1024) // 100MB</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 先占用大量内存</span><br><span class="line">    char* memory[1000];</span><br><span class="line">    int i = 0;</span><br><span class="line"></span><br><span class="line">    while(1) &#123;</span><br><span class="line">        memory[i] = malloc(ALLOC_SIZE);</span><br><span class="line">        if (memory[i] == NULL) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        // 写入内存确保实际分配</span><br><span class="line">        memset(memory[i], 1, ALLOC_SIZE);</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        pid_t pid = fork();</span><br><span class="line">        if (pid &lt; 0) &#123;</span><br><span class="line">            printf(&quot;Fork失败: %s\n&quot;, strerror(errno));</span><br><span class="line">            printf(&quot;已分配内存: %d MB\n&quot;, i * 100);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">        if (pid == 0) &#123;</span><br><span class="line">            sleep(100);  // 子进程保持运行</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>失败原因：</strong></p>
<ul>
<li>fork 需要复制父进程的地址空间</li>
<li>当系统内存不足时，无法为新进程分配内存</li>
<li>返回 ENOMEM 错误</li>
</ul>
<h3 id="其他可能导致-fork-失败的情况"><a href="#其他可能导致-fork-失败的情况" class="headerlink" title="其他可能导致 fork 失败的情况"></a>其他可能导致 fork 失败的情况</h3><ol>
<li><strong>资源限制</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置资源限制</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rlim</span>;</span></span><br><span class="line">rlim.rlim_cur = <span class="number">0</span>;</span><br><span class="line">rlim.rlim_max = <span class="number">0</span>;</span><br><span class="line">setrlimit(RLIMIT_NPROC, &amp;rlim);  <span class="comment">// 设置进程数限制为0</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>cgroup 限制</strong></li>
</ol>
<ul>
<li>在容器环境中设置严格的资源限制</li>
<li>限制进程数或内存使用</li>
</ul>
<p>使用这些程序时要注意：</p>
<ul>
<li>可能会影响系统稳定性</li>
<li>建议在测试环境运行</li>
<li>运行后需要及时清理资源</li>
</ul>
<h2 id="当子进程终止时，由于父进程可能正忙于自己的工作，没能及时调用-wait，因此子进程将变成僵尸进程。不过，由于操作系统记录了父进程与子进程之间的关系，在子进程退出时，它会发送-SIGCHLD-信号给父进程。请基于该机制实现程序，使得父进程能及时处理子进程的退出，尽可能避免子进程成为僵尸进程"><a href="#当子进程终止时，由于父进程可能正忙于自己的工作，没能及时调用-wait，因此子进程将变成僵尸进程。不过，由于操作系统记录了父进程与子进程之间的关系，在子进程退出时，它会发送-SIGCHLD-信号给父进程。请基于该机制实现程序，使得父进程能及时处理子进程的退出，尽可能避免子进程成为僵尸进程" class="headerlink" title="当子进程终止时，由于父进程可能正忙于自己的工作，没能及时调用 wait，因此子进程将变成僵尸进程。不过，由于操作系统记录了父进程与子进程之间的关系，在子进程退出时，它会发送 SIGCHLD 信号给父进程。请基于该机制实现程序，使得父进程能及时处理子进程的退出，尽可能避免子进程成为僵尸进程"></a>当子进程终止时，由于父进程可能正忙于自己的工作，没能及时调用 wait，因此子进程将变成僵尸进程。不过，由于操作系统记录了父进程与子进程之间的关系，在子进程退出时，它会发送 SIGCHLD 信号给父进程。请基于该机制实现程序，使得父进程能及时处理子进程的退出，尽可能避免子进程成为僵尸进程</h2><p>让我展示如何通过处理 SIGCHLD 信号来避免僵尸进程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line"></span><br><span class="line">// 信号处理函数</span><br><span class="line">void handle_sigchld(int sig) &#123;</span><br><span class="line">    int saved_errno = errno;  // 保存errno</span><br><span class="line">    pid_t pid;</span><br><span class="line"></span><br><span class="line">    // 循环调用waitpid，处理所有已终止的子进程</span><br><span class="line">    while ((pid = waitpid(-1, NULL, WNOHANG)) &gt; 0) &#123;</span><br><span class="line">        printf(&quot;子进程 %d 已被回收\n&quot;, pid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    errno = saved_errno;  // 恢复errno</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 设置SIGCHLD信号处理函数</span><br><span class="line">    struct sigaction sa;</span><br><span class="line">    sa.sa_handler = handle_sigchld;</span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sa.sa_flags = SA_RESTART | SA_NOCLDSTOP;  // 重启被中断的系统调用</span><br><span class="line"></span><br><span class="line">    if (sigaction(SIGCHLD, &amp;sa, NULL) == -1) &#123;</span><br><span class="line">        perror(&quot;sigaction&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 创建多个子进程</span><br><span class="line">    for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">        pid_t pid = fork();</span><br><span class="line"></span><br><span class="line">        if (pid &lt; 0) &#123;</span><br><span class="line">            perror(&quot;fork&quot;);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (pid == 0) &#123;  // 子进程</span><br><span class="line">            printf(&quot;子进程 %d 开始运行\n&quot;, getpid());</span><br><span class="line">            sleep(i + 1);  // 每个子进程睡眠不同时间</span><br><span class="line">            printf(&quot;子进程 %d 即将退出\n&quot;, getpid());</span><br><span class="line">            exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 父进程继续做其他工作</span><br><span class="line">    printf(&quot;父进程继续运行...\n&quot;);</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关键点解释"><a href="#关键点解释" class="headerlink" title="关键点解释"></a>关键点解释</h3><ol>
<li><strong>信号处理函数设计</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handle_sigchld</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// WNOHANG: 非阻塞等待</span></span><br><span class="line">        <span class="comment">// -1: 等待任何子进程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>信号处理器设置</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sa.sa_flags = SA_RESTART | SA_NOCLDSTOP;</span><br><span class="line"><span class="comment">// SA_RESTART: 重启被信号处理打断的系统调用</span></span><br><span class="line"><span class="comment">// SA_NOCLDSTOP: 只在子进程终止时发送信号，子进程暂停时不发送</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>保护 errno</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> saved_errno = errno;</span><br><span class="line"><span class="comment">// ... 信号处理 ...</span></span><br><span class="line">errno = saved_errno;</span><br></pre></td></tr></table></figure>

<h3 id="为什么这样设计-1"><a href="#为什么这样设计-1" class="headerlink" title="为什么这样设计"></a>为什么这样设计</h3><ol>
<li><p><strong>使用 while 循环处理 waitpid</strong></p>
<ul>
<li>多个子进程可能同时退出</li>
<li>一次信号可能对应多个子进程终止</li>
<li>确保处理所有已终止的子进程</li>
</ul>
</li>
<li><p><strong>使用 WNOHANG 标志</strong></p>
<ul>
<li>非阻塞调用</li>
<li>避免信号处理函数阻塞</li>
<li>提高程序响应性</li>
</ul>
</li>
<li><p><strong>保存和恢复 errno</strong></p>
<ul>
<li>信号处理可能改变 errno</li>
<li>避免干扰主程序的错误处理</li>
</ul>
</li>
</ol>
<h3 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h3><ol>
<li><strong>错误处理</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (sigaction(SIGCHLD, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>在程序初始化时设置信号处理</strong><ul>
<li>尽早设置，避免遗漏子进程</li>
<li>确保所有 fork 之前都已设置好处理器</li>
</ul>
</li>
</ol>
<p>这种方式可以有效避免僵尸进程，同时不会影响父进程的正常工作。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>051-使用cmake编译项目</title>
    <url>/2024/11/19/051-%E4%BD%BF%E7%94%A8cmake%E7%BC%96%E8%AF%91%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p>要编译一个已有 <code>CMakeLists.txt</code> 文件的 C++ 项目，你需要按照以下步骤进行操作：</p>
<span id="more"></span>

<h2 id="CMake-和-make"><a href="#CMake-和-make" class="headerlink" title="CMake 和 make"></a>CMake 和 make</h2><h3 id="1-确保安装了-CMake-和编译工具"><a href="#1-确保安装了-CMake-和编译工具" class="headerlink" title="1. 确保安装了 CMake 和编译工具"></a>1. <strong>确保安装了 CMake 和编译工具</strong></h3><p>首先，确保你的系统已经安装了 <code>CMake</code> 和适当的 C++ 编译工具。具体取决于你的操作系统，下面是一些常见的安装方式：</p>
<ul>
<li><strong>Windows</strong>：安装 <a href="https://cmake.org/download/">CMake</a> 和 <strong>Visual Studio</strong> 或 <strong>MinGW</strong>（如果你使用的是命令行编译器）。</li>
<li><strong>Linux&#x2F;Mac</strong>：可以通过包管理器安装 <code>CMake</code> 和 <code>g++</code> 编译器：<ul>
<li>Linux: <code>sudo apt-get install cmake g++</code></li>
<li>macOS: <code>brew install cmake</code>（如果使用 Homebrew）</li>
</ul>
</li>
</ul>
<h3 id="2-创建构建目录"><a href="#2-创建构建目录" class="headerlink" title="2. 创建构建目录"></a>2. <strong>创建构建目录</strong></h3><p>通常我们不直接在项目的根目录中进行构建，而是创建一个单独的构建目录，这样可以保持项目目录的整洁。</p>
<p>在项目的根目录下，执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br></pre></td></tr></table></figure>

<h3 id="3-运行-CMake-配置项目"><a href="#3-运行-CMake-配置项目" class="headerlink" title="3. 运行 CMake 配置项目"></a>3. <strong>运行 CMake 配置项目</strong></h3><p>在构建目录中，使用 <code>cmake</code> 命令来配置项目。这会生成平台特定的构建文件（如 Makefile 或 Visual Studio 工程文件）。你可以指定源代码的目录（即 <code>CMakeLists.txt</code> 文件所在的目录）。</p>
<p>假设 <code>CMakeLists.txt</code> 文件在上级目录，你可以运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake ..</span><br></pre></td></tr></table></figure>

<p>这个命令会让 CMake 读取上级目录中的 <code>CMakeLists.txt</code> 文件，并生成相应的构建配置。如果没有问题，CMake 会自动检测到编译工具链并设置好相关构建配置。</p>
<p>如果你想指定编译器或者生成不同的构建文件格式（例如使用 Visual Studio 或者 Ninja），可以使用 <code>-G</code> 选项：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake .. -G <span class="string">&quot;Visual Studio 16 2019&quot;</span>  <span class="comment"># 如果你使用 Visual Studio 2019</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">cmake .. -G <span class="string">&quot;Ninja&quot;</span>  <span class="comment"># 如果你使用 Ninja 作为构建工具</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">cmake .. -G <span class="string">&quot;NMake Makefiles&quot;</span> <span class="comment"># 如果你使用 MinGW</span></span><br></pre></td></tr></table></figure>

<h3 id="4-编译项目"><a href="#4-编译项目" class="headerlink" title="4. 编译项目"></a>4. <strong>编译项目</strong></h3><p>一旦 CMake 配置完毕，接下来可以进行编译：</p>
<ul>
<li><p><strong>如果你使用的是 Makefile</strong>，可以运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>如果你使用的是 Visual Studio</strong>，你可以直接打开生成的 <code>.sln</code> 文件并通过 Visual Studio 编译，或者在命令行中使用 <code>MSBuild</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msbuild your_project.sln</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>如果你使用的是 Ninja</strong>，可以直接运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ninja</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-运行程序"><a href="#5-运行程序" class="headerlink" title="5. 运行程序"></a>5. <strong>运行程序</strong></h3><p>编译成功后，生成的可执行文件会放在构建目录中（具体位置取决于 <code>CMakeLists.txt</code> 配置）。你可以运行它：</p>
<ul>
<li><p>在 Linux&#x2F;macOS 中，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./your_executable</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 Windows 中，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">your_executable.exe</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-清理构建文件（可选）"><a href="#6-清理构建文件（可选）" class="headerlink" title="6. 清理构建文件（可选）"></a>6. <strong>清理构建文件（可选）</strong></h3><p>如果你想清理构建目录并重新构建，可以使用以下命令：</p>
<ul>
<li><p>使用 <strong>CMake</strong> 清理构建文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake --build . --target clean</span><br></pre></td></tr></table></figure>
</li>
<li><p>或者直接删除构建目录中的文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf *</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="总结步骤"><a href="#总结步骤" class="headerlink" title="总结步骤"></a>总结步骤</h3><ol>
<li>创建 <code>build</code> 目录：<code>mkdir build &amp;&amp; cd build</code></li>
<li>运行 <code>cmake ..</code> 配置项目。</li>
<li>使用 <code>make</code>、<code>ninja</code> 或者 Visual Studio 等工具进行编译。</li>
<li>执行生成的可执行文件。</li>
</ol>
<h2 id="配置编译器"><a href="#配置编译器" class="headerlink" title="配置编译器"></a>配置编译器</h2><p>直接使用 <code>cmake</code> 命令可能失败，因为 <code>cmake</code> 找不到默认的编译器，这时需要指定编译器。</p>
<p>可以在运行 CMake 时指定 MinGW 编译器。使用 <code>-D</code> 参数设置 <code>CMAKE_C_COMPILER</code> 和 <code>CMAKE_CXX_COMPILER</code> 变量。假设你的 MinGW 安装在默认位置，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake .. -G <span class="string">&quot;MinGW Makefiles&quot;</span> -D CMAKE_C_COMPILER=gcc -D CMAKE_CXX_COMPILER=g++</span><br></pre></td></tr></table></figure>

<p>如果需要指定 MinGW 的完整路径（推荐这样做以避免路径问题），可以这样写：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake .. -G <span class="string">&quot;MinGW Makefiles&quot;</span> -D CMAKE_C_COMPILER=<span class="string">&quot;D:/mingw64/bin/gcc.exe&quot;</span> -D CMAKE_CXX_COMPILER=<span class="string">&quot;D:/mingw64/bin/g++.exe&quot;</span></span><br></pre></td></tr></table></figure>

<p>请根据你的 MinGW 实际安装路径调整上述路径。</p>
<p>你也可以通过设置环境变量 <code>CC</code> 和 <code>CXX</code> 来指定编译器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> CC=D:/mingw64/bin/gcc.exe</span><br><span class="line"><span class="built_in">set</span> CXX=D:/mingw64/bin/g++.exe</span><br><span class="line">cmake .. -G <span class="string">&quot;MinGW Makefiles&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果你想让这个设置持久化，可以将编译器路径添加到你的 CMake 设置文件中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;cmake.sourceDirectory&quot;: &quot;D:/Code/GitHub/hello-algo/codes/cpp&quot;,</span><br><span class="line">    &quot;cmake.cmakePath&quot;: &quot;D:/software/CMake/cmake-3.31.0-windows-x86_64/bin/cmake.exe&quot;,</span><br><span class="line">    &quot;cmake.configureSettings&quot;: &#123;</span><br><span class="line">        &quot;CMAKE_C_COMPILER&quot;: &quot;D:/mingw64/bin/gcc.exe&quot;,</span><br><span class="line">        &quot;CMAKE_CXX_COMPILER&quot;: &quot;D:/mingw64/bin/g++.exe&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;cmake.generator&quot;: &quot;MinGW Makefiles&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>记得替换为你系统中 MinGW 的实际安装路径。</p>
<p>如果指定生成器失败，可以用 <code>cmake .. -G &quot;NMake Makefiles&quot;</code> 来指定生成器。</p>
<p>在项目根目录下运行 <code>cmake --list-generators</code> 可以查看所有可用的生成器。能看到默认的生成器。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>052-进程间通信</title>
    <url>/2024/11/19/052-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<p>进程间通信(Inter-Process Communication, IPC)</p>
<span id="more"></span>

<h2 id="进程间通信有哪些方式"><a href="#进程间通信有哪些方式" class="headerlink" title="进程间通信有哪些方式"></a>进程间通信有哪些方式</h2><ul>
<li>共享内存</li>
<li>管道</li>
<li>消息队列</li>
<li>信号量</li>
<li>套接字</li>
</ul>
<p>进程间通信（IPC）的连接可以通过多种机制建立，每种机制都有其特定的用途和实现方式。以下是几种常见的 IPC 机制及其连接建立方式：</p>
<h3 id="1-管道（Pipe）"><a href="#1-管道（Pipe）" class="headerlink" title="1. 管道（Pipe）"></a>1. 管道（Pipe）</h3><ul>
<li><p><strong>匿名管道</strong></p>
<ul>
<li>只能在父子进程之间使用</li>
<li>通过<code>pipe()</code>系统调用创建</li>
<li>创建后返回两个文件描述符：一个用于读，一个用于写</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">if</span> (pipe(pipefd) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>命名管道（FIFO）</strong></p>
<ul>
<li>可以在无亲缘关系的进程间使用</li>
<li>通过<code>mkfifo()</code>创建一个特殊文件</li>
<li>进程通过打开这个文件进行读写</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mkfifo(<span class="string">&quot;/tmp/myfifo&quot;</span>, <span class="number">0666</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-消息队列"><a href="#2-消息队列" class="headerlink" title="2. 消息队列"></a>2. 消息队列</h3><ul>
<li><p>通过<code>msgget()</code>创建或获取一个消息队列标识符</p>
</li>
<li><p>使用<code>msgsnd()</code>和<code>msgrcv()</code>进行消息发送和接收</p>
</li>
<li><p>使用<code>msgctl()</code>进行消息队列控制，如删除消息队列或修改消息队列的权限</p>
</li>
<li><p>消息队列是基于消息的，消息队列是保存在内核中的链表，消息队列中每个消息都有一个类型和优先级</p>
</li>
<li><p>支持多进程并发访问</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">key_t</span> key = ftok(<span class="string">&quot;progfile&quot;</span>, <span class="number">65</span>);</span><br><span class="line"><span class="type">int</span> msgid = msgget(key, <span class="number">0666</span> | IPC_CREAT);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-共享内存"><a href="#3-共享内存" class="headerlink" title="3. 共享内存"></a>3. 共享内存</h3><ul>
<li><p>使用共享内存的很重要原因是性能，内核为需要通信的进程分配了一块内存，进程可以直接访问这块内存，不需要内核介入</p>
</li>
<li><p>当进程不再希望共享内存时，通过<code>shmdt()</code>将共享内存段从进程的地址空间分离，取消共享内存段与进程的地址空间的映射，只影响当前进程，其他正在使用共享内存的进程不受影响</p>
</li>
<li><p>通过<code>shmget()</code>创建或获取一个共享内存段</p>
</li>
<li><p>使用<code>shmat()</code>将共享内存段附加到进程的地址空间</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">key_t</span> key = ftok(<span class="string">&quot;shmfile&quot;</span>, <span class="number">65</span>);</span><br><span class="line"><span class="type">int</span> shmid = shmget(key, <span class="number">1024</span>, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line"><span class="type">char</span> *str = (<span class="type">char</span>*) shmat(shmid, (<span class="type">void</span>*)<span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-信号量"><a href="#4-信号量" class="headerlink" title="4. 信号量"></a>4. 信号量</h3><ul>
<li><p>信号量是用于进程间同步的机制</p>
</li>
<li><p>信号量的主要操作是两个原语：<code>P</code>操作和<code>V</code>操作，计数器值只能在 0 和 1 之间变化</p>
<ul>
<li><code>P</code>操作：计数器减一，如果计数器为 0，无法减一，则阻塞，直至计数器大于 0，减一成功</li>
<li><code>V</code>操作：计数器加一，如果计数器超过 1，则无法加一，忽略本次操作</li>
</ul>
</li>
<li><p>通过<code>semget()</code>创建或获取一个信号量集</p>
</li>
<li><p>使用<code>semop()</code>进行信号量操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">key_t</span> key = ftok(<span class="string">&quot;semfile&quot;</span>, <span class="number">65</span>);</span><br><span class="line"><span class="type">int</span> semid = semget(key, <span class="number">1</span>, <span class="number">0666</span> | IPC_CREAT);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-套接字（Sockets）"><a href="#5-套接字（Sockets）" class="headerlink" title="5. 套接字（Sockets）"></a>5. 套接字（Sockets）</h3><ul>
<li><p><strong>本地套接字（UNIX 域套接字）</strong></p>
<ul>
<li>通过<code>socket()</code>创建</li>
<li>使用<code>bind()</code>、<code>listen()</code>、<code>accept()</code>建立连接</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sockfd = socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span></span><br><span class="line">addr.sun_family = AF_UNIX;</span><br><span class="line"><span class="built_in">strcpy</span>(addr.sun_path, <span class="string">&quot;/tmp/mysocket&quot;</span>);</span><br><span class="line">bind(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">listen(sockfd, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>网络套接字</strong></p>
<ul>
<li>用于不同主机间的通信</li>
<li>通过<code>socket()</code>创建</li>
<li>使用<code>connect()</code>、<code>bind()</code>、<code>listen()</code>、<code>accept()</code>建立连接</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">addr.sin_family = AF_INET;</span><br><span class="line">addr.sin_port = htons(<span class="number">8080</span>);</span><br><span class="line">addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">bind(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">listen(sockfd, <span class="number">5</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-信号"><a href="#6-信号" class="headerlink" title="6. 信号"></a>6. 信号</h3><ul>
<li><p>通过<code>kill()</code>发送信号</p>
</li>
<li><p>进程通过<code>signal()</code>或<code>sigaction()</code>设置信号处理函数</p>
</li>
<li><p>Linux 常规信号有 32 个，信号值范围为 1-31，信号值为 0 的信号通常用于进程间同步；POSIX 引入了 32 个信号（实时信号），信号值范围为 32-64</p>
</li>
<li><p>使用信号，一个进程可以随时通知另一个进程某个事件的发生，并且接收者不需要阻塞等待该事件，内核会帮助其切换到对应的处理函数中响应信号事件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">signal(SIGUSR1, handler_function);</span><br><span class="line">kill(pid, SIGUSR1);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="信号表"><a href="#信号表" class="headerlink" title="信号表"></a>信号表</h4><p>在终端，可通过<code>kill -l</code>查看所有的 signal 信号。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:~$ kill -l</span><br><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP</span><br><span class="line"> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</span><br><span class="line">11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</span><br><span class="line">16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP</span><br><span class="line">21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR</span><br><span class="line">31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1  64) SIGRTMAX</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/hmmmmmya/MyResources@main/typora/20241120143758.png" alt="宏内核进程间通信机制对比"></p>
<h2 id="请给出一个管道的设计-使其支持双向通信"><a href="#请给出一个管道的设计-使其支持双向通信" class="headerlink" title="请给出一个管道的设计,使其支持双向通信"></a>请给出一个管道的设计,使其支持双向通信</h2><p>实现双向通信的管道可以通过创建两个单向管道来完成，一个用于从 A 到 B 的通信，另一个用于从 B 到 A 的通信。以下是实现双向管道通信的设计方案：</p>
<hr>
<h3 id="1-管道结构设计"><a href="#1-管道结构设计" class="headerlink" title="1. 管道结构设计"></a>1. <strong>管道结构设计</strong></h3><ul>
<li><strong>管道 A-&gt;B</strong>: 一个单向管道，负责从进程 A 向进程 B 发送数据。</li>
<li><strong>管道 B-&gt;A</strong>: 另一个单向管道，负责从进程 B 向进程 A 发送数据。</li>
</ul>
<hr>
<h3 id="2-关键步骤"><a href="#2-关键步骤" class="headerlink" title="2. 关键步骤"></a>2. <strong>关键步骤</strong></h3><p>假设使用 C 语言和 POSIX 标准管道 (<code>pipe</code>)：</p>
<h4 id="1-创建管道"><a href="#1-创建管道" class="headerlink" title="(1) 创建管道"></a><strong>(1) 创建管道</strong></h4><p>每个管道由一对文件描述符表示：<code>fd[0]</code> 用于读，<code>fd[1]</code> 用于写。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> pipeAB[<span class="number">2</span>]; <span class="comment">// A-&gt;B</span></span><br><span class="line"><span class="type">int</span> pipeBA[<span class="number">2</span>]; <span class="comment">// B-&gt;A</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建两个单向管道</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">pipe</span>(pipeAB) == <span class="number">-1</span> || <span class="built_in">pipe</span>(pipeBA) == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-在父子进程间通信"><a href="#2-在父子进程间通信" class="headerlink" title="(2) 在父子进程间通信"></a><strong>(2) 在父子进程间通信</strong></h4><ul>
<li><strong>父进程 A</strong>: 关闭 <code>pipeAB[0]</code> 和 <code>pipeBA[1]</code>，仅用于写入到 <code>pipeAB</code> 和读取 <code>pipeBA</code>。</li>
<li><strong>子进程 B</strong>: 关闭 <code>pipeAB[1]</code> 和 <code>pipeBA[0]</code>，仅用于读取 <code>pipeAB</code> 和写入到 <code>pipeBA</code>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 子进程B</span></span><br><span class="line">    <span class="built_in">close</span>(pipeAB[<span class="number">1</span>]); <span class="comment">// 关闭写端</span></span><br><span class="line">    <span class="built_in">close</span>(pipeBA[<span class="number">0</span>]); <span class="comment">// 关闭读端</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">256</span>];</span><br><span class="line">    <span class="comment">// 从 A-&gt;B 读取数据</span></span><br><span class="line">    <span class="built_in">read</span>(pipeAB[<span class="number">0</span>], buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;B received: %s\n&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向 B-&gt;A 写入数据</span></span><br><span class="line">    <span class="built_in">write</span>(pipeBA[<span class="number">1</span>], <span class="string">&quot;Hello A&quot;</span>, <span class="number">7</span>);</span><br><span class="line">    <span class="built_in">close</span>(pipeAB[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">close</span>(pipeBA[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 父进程A</span></span><br><span class="line">    <span class="built_in">close</span>(pipeAB[<span class="number">0</span>]); <span class="comment">// 关闭读端</span></span><br><span class="line">    <span class="built_in">close</span>(pipeBA[<span class="number">1</span>]); <span class="comment">// 关闭写端</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向 A-&gt;B 写入数据</span></span><br><span class="line">    <span class="built_in">write</span>(pipeAB[<span class="number">1</span>], <span class="string">&quot;Hello B&quot;</span>, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">256</span>];</span><br><span class="line">    <span class="comment">// 从 B-&gt;A 读取数据</span></span><br><span class="line">    <span class="built_in">read</span>(pipeBA[<span class="number">0</span>], buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;A received: %s\n&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(pipeAB[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">close</span>(pipeBA[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-使用-select-或-poll-支持异步通信"><a href="#3-使用-select-或-poll-支持异步通信" class="headerlink" title="3. 使用 select 或 poll 支持异步通信"></a>3. <strong>使用 <code>select</code> 或 <code>poll</code> 支持异步通信</strong></h3><p>为了避免阻塞，可使用 <code>select</code> 或 <code>poll</code> 对管道的读写操作进行多路复用，检查管道是否有数据可读。</p>
<hr>
<h3 id="4-其他方案"><a href="#4-其他方案" class="headerlink" title="4. 其他方案"></a>4. <strong>其他方案</strong></h3><p>除了 POSIX 管道，还可以使用以下方法实现双向通信：</p>
<ol>
<li><strong>Socket</strong>: 使用 <code>socketpair</code> 创建全双工通信。</li>
<li><strong>消息队列</strong>: 使用 System V 或 POSIX 消息队列。</li>
<li><strong>共享内存</strong>: 配合信号量实现双向通信。</li>
<li><strong>FIFO（命名管道）</strong>: 通过创建两个命名管道实现双向通信。</li>
</ol>
<p>选择哪种方式取决于具体的应用场景和需求。如果是本地进程间通信，<code>pipe</code> 和 <code>socketpair</code> 是推荐的简单方案。</p>
<h3 id="选择合适的-IPC-机制"><a href="#选择合适的-IPC-机制" class="headerlink" title="选择合适的 IPC 机制"></a>选择合适的 IPC 机制</h3><ul>
<li><strong>管道</strong>适合简单的父子进程通信</li>
<li><strong>消息队列</strong>适合需要消息排序和优先级的场景</li>
<li><strong>共享内存</strong>适合需要高效大数据量传输的场景</li>
<li><strong>信号量</strong>常用于进程间同步</li>
<li><strong>套接字</strong>适合网络通信或复杂的本地通信</li>
</ul>
<p>每种 IPC 机制都有其特定的应用场景和优缺点，选择时应根据具体需求和系统环境进行权衡。</p>
<h2 id="在进程间通信过程中-数据和控制流分别是如何传输和转移的"><a href="#在进程间通信过程中-数据和控制流分别是如何传输和转移的" class="headerlink" title="在进程间通信过程中, 数据和控制流分别是如何传输和转移的"></a>在进程间通信过程中, 数据和控制流分别是如何传输和转移的</h2><p>一种常见的通信数据的抽象是消息。消息一般包含消息头和消息体。消息头中包含消息类型、消息长度、消息优先级等控制信息，消息体中包含实际需要传输的数据。</p>
<h2 id="进程间通信的连接是如何建立的"><a href="#进程间通信的连接是如何建立的" class="headerlink" title="进程间通信的连接是如何建立的"></a>进程间通信的连接是如何建立的</h2><p>通信过程一般指通信的进程间具体的通信发起、回复、结束的过程。</p>
<p>发送者将要传输的数据内容拷贝到发送者消息上，然后一次设置头部的状态（设置为“准备就绪”等）。</p>
<p>接收者不停地轮询发送者消息的状态信息，当发现消息头部的状态变为“准备就绪”时，就表示发送者发送了一个消息。</p>
<p>发送者一发送完消息，就开始轮询接收者消息的状态信息，当发现接收者消息头部的状态变为“准备就绪”时，就表示接收者接收到了一个消息。</p>
<p>接收者在读取发送者的消息后，处理请求，并在接受者消息上准备返回结果。</p>
<p>发送者不停地轮询接收者消息的状态信息，当发现接收者消息头部的状态变为“返回结果”时，就表示接收者处理完了消息，并准备返回结果。</p>
<p>发送者读取接收者消息中的返回结果，并从消息中删除返回结果。</p>
<h3 id="直接通信和间接通信"><a href="#直接通信和间接通信" class="headerlink" title="直接通信和间接通信"></a>直接通信和间接通信</h3><p>直接通信：发送者和接收者都知道彼此的标识符。比如进程号。</p>
<p>间接通信：发送者和接收者不知道彼此的标识符，需要一个中间实体（如消息队列、共享内存、管道等）来传递消息。</p>
<h2 id="什么是超时机制-为什么需要超时机制"><a href="#什么是超时机制-为什么需要超时机制" class="headerlink" title="什么是超时机制, 为什么需要超时机制"></a>什么是超时机制, 为什么需要超时机制</h2><p>超时机制是进程间通信中的一种机制，用于处理通信过程中可能出现的延迟或失败情况。允许发送者&#x2F;接收者设置一个超时时间，如果在这个时间内没有收到回复，则认为通信失败。由操作系统内核结束此次 IPC 调用，返回一个超时的错误。</p>
<h2 id="一个进程如何找到另一个进程提供的服务"><a href="#一个进程如何找到另一个进程提供的服务" class="headerlink" title="一个进程如何找到另一个进程提供的服务"></a>一个进程如何找到另一个进程提供的服务</h2><p>一个进程找到另一个进程提供的服务，可以通过以下几种常见的通信机制实现，具体选择取决于操作系统环境和应用场景：</p>
<hr>
<h3 id="1-使用命名管道-FIFO"><a href="#1-使用命名管道-FIFO" class="headerlink" title="1. 使用命名管道 (FIFO)"></a><strong>1. 使用命名管道 (FIFO)</strong></h3><ul>
<li><strong>适用场景</strong>: 本地进程间通信，简单高效。</li>
<li><strong>实现步骤</strong>:<ol>
<li>服务端创建一个命名管道（FIFO）。</li>
<li>客户端打开该命名管道进行读写。</li>
<li>使用文件路径标识管道。</li>
</ol>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 服务端</span></span><br><span class="line"><span class="built_in">mkfifo</span>(<span class="string">&quot;/tmp/myservice&quot;</span>, <span class="number">0666</span>); <span class="comment">// 创建命名管道</span></span><br><span class="line"><span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;/tmp/myservice&quot;</span>, O_RDONLY); <span class="comment">// 打开管道用于读取</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;/tmp/myservice&quot;</span>, O_WRONLY); <span class="comment">// 打开管道用于写入</span></span><br><span class="line"><span class="built_in">write</span>(fd, <span class="string">&quot;Hello Service&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;Hello Service&quot;</span>));</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-使用套接字（Socket）"><a href="#2-使用套接字（Socket）" class="headerlink" title="2. 使用套接字（Socket）"></a><strong>2. 使用套接字（Socket）</strong></h3><ul>
<li><strong>适用场景</strong>: 本地或分布式场景，通过网络通信。</li>
<li><strong>实现步骤</strong>:<ol>
<li>服务端监听一个固定的地址和端口。</li>
<li>客户端通过地址和端口连接到服务端。</li>
</ol>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 服务端</span></span><br><span class="line"><span class="type">int</span> server_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address = &#123; ... &#125;; <span class="comment">// 设置地址和端口</span></span><br><span class="line"><span class="built_in">bind</span>(server_fd, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="built_in">sizeof</span>(address));</span><br><span class="line"><span class="built_in">listen</span>(server_fd, <span class="number">3</span>);</span><br><span class="line"><span class="type">int</span> client_fd = <span class="built_in">accept</span>(server_fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>); <span class="comment">// 等待客户端连接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="type">int</span> client_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">connect</span>(client_fd, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="built_in">sizeof</span>(address));</span><br><span class="line"><span class="built_in">write</span>(client_fd, <span class="string">&quot;Hello Service&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;Hello Service&quot;</span>));</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-使用共享内存"><a href="#3-使用共享内存" class="headerlink" title="3. 使用共享内存"></a><strong>3. 使用共享内存</strong></h3><ul>
<li><strong>适用场景</strong>: 本地进程间通信，数据量大且需要高效。</li>
<li><strong>实现步骤</strong>:<ol>
<li>服务端创建一个共享内存段并设置标识符。</li>
<li>客户端通过标识符访问共享内存。</li>
<li>使用信号量或互斥锁同步访问。</li>
</ol>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 服务端</span></span><br><span class="line"><span class="type">int</span> shm_id = <span class="built_in">shmget</span>(<span class="number">1234</span>, <span class="number">1024</span>, IPC_CREAT | <span class="number">0666</span>); <span class="comment">// 创建共享内存</span></span><br><span class="line"><span class="type">char</span>* shm_ptr = (<span class="type">char</span>*)<span class="built_in">shmat</span>(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">// 映射到地址空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="type">int</span> shm_id = <span class="built_in">shmget</span>(<span class="number">1234</span>, <span class="number">1024</span>, <span class="number">0666</span>); <span class="comment">// 获取共享内存</span></span><br><span class="line"><span class="type">char</span>* shm_ptr = (<span class="type">char</span>*)<span class="built_in">shmat</span>(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">// 映射到地址空间</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-使用系统总线-如-D-Bus-或-ZeroMQ"><a href="#4-使用系统总线-如-D-Bus-或-ZeroMQ" class="headerlink" title="4. 使用系统总线 (如 D-Bus 或 ZeroMQ)"></a><strong>4. 使用系统总线 (如 D-Bus 或 ZeroMQ)</strong></h3><ul>
<li><strong>适用场景</strong>: 复杂系统，支持服务发现和消息路由。</li>
<li><strong>实现步骤</strong>:<ol>
<li>服务端注册服务到消息总线。</li>
<li>客户端通过总线查找服务。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="5-使用文件描述符或信号"><a href="#5-使用文件描述符或信号" class="headerlink" title="5. 使用文件描述符或信号"></a><strong>5. 使用文件描述符或信号</strong></h3><ul>
<li><strong>适用场景</strong>: 简单标识服务状态。</li>
<li><strong>实现方式</strong>:<ul>
<li>服务端创建特定文件（如 Unix 域套接字文件）。</li>
<li>客户端通过文件路径定位服务。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="6-使用注册表或配置文件"><a href="#6-使用注册表或配置文件" class="headerlink" title="6. 使用注册表或配置文件"></a><strong>6. 使用注册表或配置文件</strong></h3><ul>
<li><strong>适用场景</strong>: 服务动态发布或客户端动态查找。</li>
<li><strong>实现方式</strong>:<ul>
<li>服务端将自身信息（如 PID、套接字地址）写入文件或注册表。</li>
<li>客户端读取该文件查找服务。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 服务端</span></span><br><span class="line">FILE* f = <span class="built_in">fopen</span>(<span class="string">&quot;/tmp/service_info&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(f, <span class="string">&quot;127.0.0.1:8080\n&quot;</span>); <span class="comment">// 写入服务信息</span></span><br><span class="line"><span class="built_in">fclose</span>(f);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line">FILE* f = <span class="built_in">fopen</span>(<span class="string">&quot;/tmp/service_info&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="type">char</span> service_address[<span class="number">256</span>];</span><br><span class="line"><span class="built_in">fgets</span>(service_address, <span class="built_in">sizeof</span>(service_address), f);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="7-服务发现协议"><a href="#7-服务发现协议" class="headerlink" title="7. 服务发现协议"></a><strong>7. 服务发现协议</strong></h3><ul>
<li><strong>适用场景</strong>: 动态服务发现，分布式系统。</li>
<li><strong>实现方式</strong>:<ul>
<li>使用诸如 <code>mDNS</code>、<code>Consul</code> 等服务发现工具。</li>
<li>服务端注册到发现工具，客户端通过工具查找服务。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="综合建议"><a href="#综合建议" class="headerlink" title="综合建议"></a><strong>综合建议</strong></h3><ul>
<li><strong>本地简单通信</strong>: 命名管道、共享内存。</li>
<li><strong>本地或远程灵活通信</strong>: Socket。</li>
<li><strong>动态服务发现</strong>: 服务总线或专用工具（如 Consul）。</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>053-localhost和127.0.0.1的关系</title>
    <url>/2024/11/20/053-localhost%E5%92%8C127-0-0-1%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<p><code>localhost</code> 和 <code>127.0.0.1</code> 都是指向本地主机的地址，但它们在使用上有一些细微的区别：</p>
<h3 id="1-127-0-0-1"><a href="#1-127-0-0-1" class="headerlink" title="1. 127.0.0.1"></a>1. <code>127.0.0.1</code></h3><ul>
<li><strong>IPv4 地址</strong>：<code>127.0.0.1</code> 是一个标准的 IPv4 地址，专门用于指向本地计算机。</li>
<li><strong>环回地址</strong>：它是一个环回地址，意味着任何发送到这个地址的数据包都会被返回到本地计算机。</li>
<li><strong>网络接口</strong>：通常与名为<code>lo</code>或<code>lo0</code>的网络接口绑定。</li>
</ul>
<h3 id="2-localhost"><a href="#2-localhost" class="headerlink" title="2. localhost"></a>2. <code>localhost</code></h3><ul>
<li><strong>主机名</strong>：<code>localhost</code> 是一个主机名，通常在系统的<code>/etc/hosts</code>文件中被解析为<code>127.0.0.1</code>。</li>
<li><strong>域名解析</strong>：在大多数系统中，<code>localhost</code> 被解析为<code>127.0.0.1</code>，但它也可以被配置为解析为其他地址（如 IPv6 的<code>::1</code>）。</li>
<li><strong>可配置性</strong>：用户可以在<code>/etc/hosts</code>文件中更改<code>localhost</code>的解析地址。</li>
</ul>
<h3 id="3-关系与区别"><a href="#3-关系与区别" class="headerlink" title="3. 关系与区别"></a>3. 关系与区别</h3><ul>
<li><strong>默认解析</strong>：在大多数情况下，<code>localhost</code> 默认解析为<code>127.0.0.1</code>，但它是通过域名解析系统（如<code>/etc/hosts</code>文件）实现的。</li>
<li><strong>IPv6 支持</strong>：<code>localhost</code> 也可以解析为 IPv6 地址<code>::1</code>，而<code>127.0.0.1</code>仅限于 IPv4。</li>
<li><strong>使用场景</strong>：在编程和网络配置中，使用<code>localhost</code>可以使代码更具可移植性，因为它不依赖于特定的 IP 地址。</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>在大多数 Linux 系统中，<code>/etc/hosts</code>文件中会有如下配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1   localhost</span><br><span class="line">::1         localhost</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1 localhost</span><br><span class="line">127.0.1.1 wt400</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">The following lines are desirable <span class="keyword">for</span> IPv6 capable hosts</span></span><br><span class="line">::1     ip6-localhost ip6-loopback</span><br><span class="line">fe00::0 ip6-localnet</span><br><span class="line">ff00::0 ip6-mcastprefix</span><br><span class="line">ff02::1 ip6-allnodes</span><br><span class="line">ff02::2 ip6-allrouters</span><br></pre></td></tr></table></figure>

<p>这意味着无论是 IPv4 还是 IPv6，<code>localhost</code>都会指向本地计算机。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong><code>127.0.0.1</code></strong> 是一个固定的 IPv4 地址，用于指向本地计算机。</li>
<li><strong><code>localhost</code></strong> 是一个主机名，通常解析为<code>127.0.0.1</code>，但可以配置为其他地址。</li>
<li>在大多数情况下，它们可以互换使用，但<code>localhost</code>提供了更大的灵活性和可移植性。</li>
<li>在终端中，ping <code>localhost</code> 和 <code>127.0.0.1</code> 的效果是一样的。都不经过网卡。</li>
</ul>
<h3 id="为什么-ping-127-0-0-1-不经过网卡？"><a href="#为什么-ping-127-0-0-1-不经过网卡？" class="headerlink" title="为什么 ping 127.0.0.1 不经过网卡？"></a>为什么 <code>ping 127.0.0.1</code> 不经过网卡？</h3><p><code>ping 127.0.0.1</code> 并不是测试网卡的连接，而是测试本机的网络协议栈（loopback interface）。它通过回环地址测试网络协议栈是否正常工作。具体来说：</p>
<ol>
<li><p><strong>127.0.0.1 的作用</strong></p>
<ul>
<li>它是回环地址，代表本机，无论网络接口的状态如何，都不会发送数据到外部网络设备。</li>
<li>即使你的网卡未连接到任何网络，<code>ping 127.0.0.1</code> 也会返回响应，因为它不依赖物理网卡。</li>
</ul>
</li>
<li><p><strong>测试范围</strong></p>
<ul>
<li>如果 <code>ping 127.0.0.1</code> 成功，说明操作系统的 TCP&#x2F;IP 协议栈正常工作。</li>
<li>如果失败，可能是 TCP&#x2F;IP 协议栈或相关配置出了问题，但与物理网卡无直接关系。</li>
</ul>
</li>
<li><p><strong>测试网卡的方法</strong></p>
<ul>
<li>使用 <code>ping</code> 测试网卡的 IP 地址（如 <code>ping 192.168.1.x</code>），确保网卡与局域网设备通信正常。</li>
<li>检查网卡硬件状态，可通过命令如 <code>ipconfig</code> (Windows) 或 <code>ifconfig</code> (Linux) 查看网卡是否被正确识别。</li>
<li>使用 <code>ethtool</code>（Linux）或设备管理器（Windows）进一步诊断。</li>
</ul>
</li>
</ol>
<p>简单来说，<code>ping 127.0.0.1</code> 仅能确认协议栈的正常性，不能完全验证网卡的工作状态。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>054-Microsoft Visual Studio 怎么编译c++项目, 项目中包含了.sln文件</title>
    <url>/2024/11/21/054-Microsoft-Visual-Studio-%E6%80%8E%E4%B9%88%E7%BC%96%E8%AF%91cpp-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%8C%85%E5%90%AB%E4%BA%86-sln%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>在 Microsoft Visual Studio 中编译包含 <code>.sln</code> 文件的 C++ 项目通常需要以下步骤：</p>
<span id="more"></span>

<h2 id="Microsoft-Visual-Studio-编译-c-项目"><a href="#Microsoft-Visual-Studio-编译-c-项目" class="headerlink" title="Microsoft Visual Studio 编译 c++ 项目"></a>Microsoft Visual Studio 编译 c++ 项目</h2><h3 id="步骤-1-打开解决方案"><a href="#步骤-1-打开解决方案" class="headerlink" title="步骤 1: 打开解决方案"></a><strong>步骤 1: 打开解决方案</strong></h3><ol>
<li>启动 Microsoft Visual Studio。</li>
<li>点击 <strong>“文件” -&gt; “打开” -&gt; “项目&#x2F;解决方案”</strong>。</li>
<li>浏览到包含 <code>.sln</code> 文件的目录，选择该文件，然后点击 <strong>“打开”</strong>。</li>
</ol>
<hr>
<h3 id="步骤-2-设置构建配置"><a href="#步骤-2-设置构建配置" class="headerlink" title="步骤 2: 设置构建配置"></a><strong>步骤 2: 设置构建配置</strong></h3><ol>
<li>在 Visual Studio 窗口的工具栏中找到 <strong>“解决方案配置”</strong> 下拉菜单（通常在右上角），选择合适的配置：<ul>
<li><strong>Debug</strong>：用于调试，包含调试信息，优化级别较低。</li>
<li><strong>Release</strong>：用于发布，优化级别较高，无调试信息。</li>
</ul>
</li>
<li>根据需要，选择 <strong>“平台”</strong>（如 x86 或 x64）。</li>
</ol>
<hr>
<h3 id="步骤-3-检查项目设置"><a href="#步骤-3-检查项目设置" class="headerlink" title="步骤 3: 检查项目设置"></a><strong>步骤 3: 检查项目设置</strong></h3><ol>
<li>在解决方案资源管理器（<strong>Solution Explorer</strong>）中右键单击项目名称，选择 <strong>“属性”</strong>。</li>
<li>在弹出的 <strong>“属性页”</strong> 中检查关键配置：<ul>
<li><strong>常规</strong>:<ul>
<li>确保 <strong>输出目录</strong> 和 <strong>中间目录</strong> 是合适的。</li>
</ul>
</li>
<li><strong>C&#x2F;C++</strong>:<ul>
<li>确保包含路径（Include Directories）正确。</li>
<li>根据需要设置警告等级、优化选项等。</li>
</ul>
</li>
<li><strong>链接器</strong>:<ul>
<li>确保库路径（Library Directories）正确。</li>
<li>确保引用的库文件（Additional Dependencies）正确。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="步骤-4-编译项目"><a href="#步骤-4-编译项目" class="headerlink" title="步骤 4: 编译项目"></a><strong>步骤 4: 编译项目</strong></h3><ol>
<li>在工具栏中点击 <strong>“生成” -&gt; “生成解决方案”</strong> 或按下快捷键 <code>Ctrl+Shift+B</code>。</li>
<li>Visual Studio 会开始编译项目，编译日志将显示在下方的 <strong>“输出”</strong> 窗口中。</li>
<li>如果没有错误，生成的可执行文件通常会保存在项目的 <code>Debug</code> 或 <code>Release</code> 文件夹中。</li>
</ol>
<hr>
<h3 id="步骤-5-运行项目"><a href="#步骤-5-运行项目" class="headerlink" title="步骤 5: 运行项目"></a><strong>步骤 5: 运行项目</strong></h3><ol>
<li>点击工具栏中的绿色箭头（<strong>“本地 Windows 调试器”</strong>），或者按下 <code>F5</code> 运行项目。</li>
<li>如果只想运行而不调试，可以按下 <code>Ctrl+F5</code>。</li>
</ol>
<hr>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a><strong>常见问题</strong></h3><ul>
<li><strong>缺少库文件</strong>：<ul>
<li>确保在项目属性中的 <strong>链接器 -&gt; 输入 -&gt; 附加依赖项</strong> 中添加了所有必要的库文件。</li>
</ul>
</li>
<li><strong>头文件找不到</strong>：<ul>
<li>确保在 <strong>C&#x2F;C++ -&gt; 常规 -&gt; 附加包含目录</strong> 中添加了所有必要的头文件路径。</li>
</ul>
</li>
<li><strong>编译错误</strong>：<ul>
<li>查看 <strong>“错误列表”</strong> 窗口中的错误信息，逐一修复。</li>
</ul>
</li>
</ul>
<p>按照以上步骤操作后，您应该能够成功编译和运行包含 <code>.sln</code> 文件的 C++ 项目。</p>
<h2 id="怎么看-Visual-Studio-中是否有某个头文件"><a href="#怎么看-Visual-Studio-中是否有某个头文件" class="headerlink" title="怎么看 Visual Studio 中是否有某个头文件"></a>怎么看 Visual Studio 中是否有某个头文件</h2><p>在 Microsoft Visual Studio 中检查某个头文件是否存在，可以通过以下几种方法：</p>
<hr>
<h3 id="方法-1-使用-IntelliSense"><a href="#方法-1-使用-IntelliSense" class="headerlink" title="方法 1: 使用 IntelliSense"></a><strong>方法 1: 使用 IntelliSense</strong></h3><ol>
<li>打开需要检查的 <code>.cpp</code> 或 <code>.h</code> 文件。</li>
<li>在代码中键入：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;your_header_file.h&quot;</span></span></span><br></pre></td></tr></table></figure></li>
<li>如果 IntelliSense 提示报错，例如 <strong>“Cannot open source file”</strong> 或波浪线，说明头文件未被找到或路径有问题。</li>
<li>如果没有错误提示，按住 <code>Ctrl</code> 并点击该头文件名称，Visual Studio 会尝试跳转到文件所在位置。</li>
</ol>
<hr>
<h3 id="方法-2-使用“转到文件”功能"><a href="#方法-2-使用“转到文件”功能" class="headerlink" title="方法 2: 使用“转到文件”功能"></a><strong>方法 2: 使用“转到文件”功能</strong></h3><ol>
<li>按下 <code>Ctrl+T</code> 或 <code>Ctrl+逗号</code> 打开“转到”窗口。</li>
<li>在弹出的输入框中，输入头文件的名称（例如 <code>your_header_file.h</code>）。</li>
<li>如果头文件存在并且在项目路径或已包含的目录中，Visual Studio 会列出相关文件。</li>
</ol>
<hr>
<h3 id="方法-3-检查包含路径"><a href="#方法-3-检查包含路径" class="headerlink" title="方法 3: 检查包含路径"></a><strong>方法 3: 检查包含路径</strong></h3><ol>
<li>在 <strong>解决方案资源管理器</strong> 中右键点击项目名称，选择 <strong>“属性”</strong>。</li>
<li>在 <strong>属性页</strong> 中导航到 <strong>C&#x2F;C++ -&gt; 常规 -&gt; 附加包含目录</strong>。</li>
<li>检查包含路径中是否包含目标头文件所在的目录。<ul>
<li>如果没有，将包含头文件的目录添加进去，格式如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(SolutionDir)include</span><br></pre></td></tr></table></figure></li>
<li>确保路径正确且文件确实在其中。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="方法-4-全局文件搜索"><a href="#方法-4-全局文件搜索" class="headerlink" title="方法 4: 全局文件搜索"></a><strong>方法 4: 全局文件搜索</strong></h3><ol>
<li>按下 <code>Ctrl+Shift+F</code> 打开“查找文件”窗口。</li>
<li>在 <strong>“文件内容”</strong> 输入框中，输入头文件的名称（例如 <code>your_header_file.h</code>）。</li>
<li>设置查找范围为项目目录或整个解决方案。</li>
<li>点击 <strong>“查找全部”</strong>，如果文件存在，则会列出结果。</li>
</ol>
<hr>
<h3 id="方法-5-手动检查文件路径"><a href="#方法-5-手动检查文件路径" class="headerlink" title="方法 5: 手动检查文件路径"></a><strong>方法 5: 手动检查文件路径</strong></h3><ol>
<li>检查您的项目目录或代码仓库中是否存在目标头文件。</li>
<li>如果使用第三方库，检查库的 <code>include</code> 文件夹是否包含该头文件。</li>
<li>确保 <code>附加包含目录</code> 已正确配置。</li>
</ol>
<hr>
<h3 id="补充-确保头文件生效的注意事项"><a href="#补充-确保头文件生效的注意事项" class="headerlink" title="补充: 确保头文件生效的注意事项"></a><strong>补充: 确保头文件生效的注意事项</strong></h3><ul>
<li><strong>自定义头文件</strong>：确保头文件已添加到项目中。如果头文件未包含在解决方案中，右键项目 -&gt; 添加 -&gt; 现有项，将头文件加入到项目。</li>
<li><strong>第三方头文件</strong>：检查是否安装了相关的第三方库，并确保其路径正确。</li>
</ul>
<p>通过以上方法，您可以快速确认目标头文件是否在 Visual Studio 的项目中以及它的路径是否被正确配置。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>055-windwos下用Studio编译缺少jsoncpp库怎么办</title>
    <url>/2024/11/21/055-windwos%E4%B8%8B%E7%94%A8Studio%E7%BC%96%E8%AF%91%E7%BC%BA%E5%B0%91jsoncpp%E5%BA%93%E6%80%8E%E4%B9%88%E5%8A%9E/</url>
    <content><![CDATA[<p>在 Windows 下使用 Microsoft Visual Studio 时，如果没有<code>jsoncpp</code>库，你可以通过以下几种方式来解决这个问题：</p>
<ol>
<li><p><strong>使用 vcpkg 安装 jsoncpp 库</strong>：</p>
<ul>
<li><p>首先，确保你已经安装并设置好<code>vcpkg</code>。如果没有，请参考<a href="https://github.com/microsoft/vcpkg">vcpkg 的官方文档</a>进行安装。</p>
</li>
<li><p>打开命令提示符，导航到<code>vcpkg</code>的安装目录，然后运行以下命令来安装<code>jsoncpp</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vcpkg install jsoncpp</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装完成后，将<code>vcpkg</code>集成到 Visual Studio 中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vcpkg integrate install</span><br></pre></td></tr></table></figure>
</li>
<li><p>在你的项目中，确保在项目属性中包含<code>vcpkg</code>的头文件和库路径。</p>
</li>
</ul>
</li>
<li><p><strong>手动下载和编译 jsoncpp 库</strong>：</p>
<ul>
<li>访问<a href="https://github.com/open-source-parsers/jsoncpp">jsoncpp 的 GitHub 页面</a>下载源码。</li>
<li>使用 CMake 生成 Visual Studio 项目文件，然后在 Visual Studio 中打开并编译。</li>
<li>将生成的库文件和头文件添加到你的项目中。</li>
</ul>
</li>
<li><p><strong>使用 NuGet 包管理器</strong>：</p>
<ul>
<li>在 Visual Studio 中，右键点击你的项目，选择“管理 NuGet 包”。</li>
<li>搜索<code>jsoncpp</code>并安装。</li>
</ul>
</li>
<li><p><strong>替代库</strong>：</p>
<ul>
<li>如果<code>jsoncpp</code>不适合你的需求，可以考虑使用其他 JSON 库，比如<code>nlohmann/json</code>，它也可以通过<code>vcpkg</code>或<code>NuGet</code>安装。</li>
</ul>
</li>
</ol>
<p>通过以上方法，你应该能够在 Visual Studio 中使用<code>jsoncpp</code>库。希望这些建议对你有帮助！如果有其他问题，请随时问我。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>056-ifndef LINUX</title>
    <url>/2024/11/21/056-ifndef-LINUX/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>057-nlohmann_json库的使用</title>
    <url>/2024/11/22/057-nlohmann-json%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="json-hpp-库下载及安装"><a href="#json-hpp-库下载及安装" class="headerlink" title="json.hpp 库下载及安装"></a>json.hpp 库下载及安装</h2><p>nlohmann json 的开源项目地址：</p>
<p><a href="https://github.com/nlohmann/json#serialization%E2%80%93deserialization">https://github.com/nlohmann/json#serialization–deserialization</a></p>
<p>对于我们项目中要使用 nlohmann json 工具，只需要引入 json.hpp 这一个文件，其中包含所有接口函数，正如其文档中所述 json.hpp 文件在 single_include&#x2F;nlohmann 目录下，我们只需要下载该文件即可：</p>
<p>git clone <a href="https://github.com/nlohmann/json/blob/develop/single_include/nlohmann/json.hpp">https://github.com/nlohmann/json/blob/develop/single_include/nlohmann/json.hpp</a></p>
<p>注意：不是 include&#x2F;nlohmann&#x2F;json.hpp，而是 single_include&#x2F;nlohmann&#x2F;json.hpp，前者要包含整个文件夹，后者只需要包含 json.hpp 文件。</p>
<h2 id="用-json-赋值"><a href="#用-json-赋值" class="headerlink" title="用 json 赋值"></a>用 json 赋值</h2><p>在使用 nlohmann JSON 库时，如果 JSON 中存储的类型与要赋值的变量类型一致，通常不需要显式地使用 <code>get&lt;&gt;()</code> 进行类型转换。<code>at()</code> 方法会返回一个 JSON 值对象，该对象可以直接赋值给与其类型兼容的变量。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;nlohmann/json.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    nlohmann::json j;</span><br><span class="line">    j[<span class="string">&quot;pi&quot;</span>] = <span class="number">3.14159</span>;</span><br><span class="line">    j[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;GPT-4&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接赋值</span></span><br><span class="line">    <span class="type">float</span> pi = j.<span class="built_in">at</span>(<span class="string">&quot;pi&quot;</span>);</span><br><span class="line">    std::string name = j.<span class="built_in">at</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;pi: &quot;</span> &lt;&lt; pi &lt;&lt; <span class="string">&quot;, name: &quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>j.at(&quot;pi&quot;)</code> 返回一个 JSON 值对象，该对象可以直接赋值给 <code>float</code> 类型的变量 <code>pi</code>，因为 JSON 中的值是一个浮点数。同样，<code>j.at(&quot;name&quot;)</code> 返回一个字符串，可以直接赋值给 <code>std::string</code> 类型的变量 <code>name</code>。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li><p><strong>类型匹配</strong>：确保 JSON 中的值类型与变量类型匹配，否则会抛出异常。例如，如果 JSON 中的值是整数而你试图将其赋值给浮点数，可能会导致类型不匹配错误。</p>
</li>
<li><p><strong>异常处理</strong>：使用 <code>at()</code> 方法时，如果键不存在，会抛出 <code>std::out_of_range</code> 异常。因此，确保键存在或使用异常处理机制。</p>
</li>
<li><p><strong>类型安全</strong>：虽然可以直接赋值，但在某些情况下，显式使用 <code>get&lt;&gt;()</code> 可以提高代码的可读性和类型安全性，特别是在处理复杂数据结构时。</p>
</li>
<li><p><strong>char 类型</strong>：<strong>nlohmann&#x2F;json 库本身并没有直接支持 char 类型</strong>，所以需要转换，赋值给 json 时需要转换为 string 或者 int。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>058-design-patterns-learning</title>
    <url>/2024/11/28/058-design-patterns-learning/</url>
    <content><![CDATA[<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h3><ul>
<li><a href="https://refactoringguru.cn/design-patterns/cpp">refactoringguru 设计模式</a></li>
<li><a href="https://design-patterns.readthedocs.io/zh-cn/latest/index.html">图说设计模式</a></li>
<li><a href="https://www.geeksforgeeks.org/introduction-to-pattern-designing/">GeeksforGeeks 设计模式</a></li>
</ul>
<h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><ul>
<li><a href="https://www.bilibili.com/video/BV1Zd4y1t7HK/?vd_source=afd9bb086cf8c56bfa160a01bb00e8d8">设计模式-阿西拜编程</a></li>
</ul>
<h3 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h3><ul>
<li><a href="https://github.com/kamranahmedse/design-patterns-for-humans">design-patterns-for-humans</a></li>
<li><a href="https://github.com/JakubVojvoda/design-patterns-cpp?tab=readme-ov-file">design-patterns-cpp</a></li>
</ul>
]]></content>
      <categories>
        <category>learning</category>
      </categories>
  </entry>
  <entry>
    <title>059-int赋值给char</title>
    <url>/2024/11/30/059-int%E8%B5%8B%E5%80%BC%E7%BB%99char/</url>
    <content><![CDATA[<h3 id="int-直接赋值给-char-会怎么样"><a href="#int-直接赋值给-char-会怎么样" class="headerlink" title="int 直接赋值给 char 会怎么样"></a>int 直接赋值给 char 会怎么样</h3><p>在 C++中，将一个 <code>int</code> 类型的值直接赋值给一个 <code>char</code> 类型的变量时，可能会发生以下情况：</p>
<ol>
<li><p><strong>截断</strong>：<code>char</code> 类型通常是 1 字节（8 位），而 <code>int</code> 类型通常是 4 字节（32 位）或更多。因此，当 <code>int</code> 的值超出 <code>char</code> 的表示范围时，只有最低的 8 位会被保留，其余的位会被截断。这可能导致数据丢失或值的改变。</p>
</li>
<li><p><strong>符号扩展</strong>：如果 <code>char</code> 是有符号的（<code>signed char</code>），并且 <code>int</code> 的值超出了 <code>char</code> 的正数范围（通常是 -128 到 127），则可能会导致符号扩展问题，导致负值。</p>
</li>
<li><p><strong>未定义行为</strong>：如果 <code>int</code> 的值超出了 <code>char</code> 的表示范围，可能会导致未定义行为，具体表现取决于编译器和平台。</p>
</li>
</ol>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> largeValue = <span class="number">300</span>;</span><br><span class="line"><span class="type">char</span> smallValue = largeValue; <span class="comment">// smallValue 可能会变成 44，因为 300 的最低 8 位是 44</span></span><br></pre></td></tr></table></figure>

<p>为了避免这些问题，通常建议在赋值前进行显式的类型转换，并确保值在目标类型的范围内：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> largeValue = <span class="number">300</span>;</span><br><span class="line"><span class="type">char</span> smallValue = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(largeValue &amp; <span class="number">0xFF</span>); <span class="comment">// 只保留最低的 8 位</span></span><br></pre></td></tr></table></figure>

<p>这样可以确保程序的行为是可预测的。</p>
<p>总结: 从二进制角度来看, int 是 32 位, char 是 8 位, 不要直接将 int 赋值给 char, 要进行类型转换, <strong>只保留最低的 8 位</strong>.</p>
<h3 id="int-1-和-char-‘1’-的主要区别"><a href="#int-1-和-char-‘1’-的主要区别" class="headerlink" title="int(1) 和 char(‘1’) 的主要区别"></a>int(1) 和 char(‘1’) 的主要区别</h3><ol>
<li><strong>数值表示</strong>：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">1</span>;     <span class="comment">// 数值1，二进制为 00000001</span></span><br><span class="line"><span class="type">char</span> c = <span class="string">&#x27;1&#x27;</span>;    <span class="comment">// 字符&#x27;1&#x27;，ASCII码为49（二进制 00110001）</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>内存占用</strong>：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;int大小: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; <span class="string">&quot;字节&quot;</span> &lt;&lt; std::endl;    <span class="comment">// 通常是4字节</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;char大小: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span>) &lt;&lt; <span class="string">&quot;字节&quot;</span> &lt;&lt; std::endl;   <span class="comment">// 1字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>使用场景示例</strong>：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">1</span>;      <span class="comment">// 用于数学计算</span></span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;1&#x27;</span>;     <span class="comment">// 用于字符表示</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数学运算</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;num + 1 = &quot;</span> &lt;&lt; num + <span class="number">1</span> &lt;&lt; std::endl;        <span class="comment">// 输出：2</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c + 1 = &quot;</span> &lt;&lt; c + <span class="number">1</span> &lt;&lt; std::endl;           <span class="comment">// 输出：50 (ASCII 49 + 1)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符输出</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;num as char: &quot;</span> &lt;&lt; (<span class="type">char</span>)num &lt;&lt; std::endl;   <span class="comment">// 输出：SOH (不可打印字符)</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c as char: &quot;</span> &lt;&lt; c &lt;&lt; std::endl;            <span class="comment">// 输出：1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ASCII值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c的ASCII值: &quot;</span> &lt;&lt; (<span class="type">int</span>)c &lt;&lt; std::endl;      <span class="comment">// 输出：49</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要区别总结：</p>
<ol>
<li><p><strong>本质区别</strong>：</p>
<ul>
<li><code>int(1)</code> 是数值 1, 二进制为 00000000 00000000 00000000 00000001</li>
<li><code>char(&#39;1&#39;)</code> 是字符’1’的 ASCII 码值 49, 二进制为 00110001</li>
<li><code>char(1)</code> 是二进制 00000001</li>
</ul>
</li>
<li><p><strong>用途区别</strong>：</p>
<ul>
<li><code>int</code> 主要用于数值计算</li>
<li><code>char</code> 主要用于字符表示</li>
</ul>
</li>
<li><p><strong>存储区别</strong>：</p>
<ul>
<li><code>int</code> 通常占 4 字节</li>
<li><code>char</code> 占 1 字节</li>
</ul>
</li>
<li><p><strong>表示范围</strong>：</p>
<ul>
<li><code>int</code> 通常范围是 -2147483648 到 2147483647</li>
<li><code>char</code> 范围是 -128 到 127（unsigned char 是 0 到 255）</li>
</ul>
</li>
<li><p><strong>转换注意事项</strong>：</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="type">char</span> c = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换示例</span></span><br><span class="line"><span class="type">int</span> num_from_char = c - <span class="string">&#x27;0&#x27;</span>;    <span class="comment">// 字符转数字：49 - 48 = 1</span></span><br><span class="line"><span class="type">char</span> char_from_int = num + <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 数字转字符：1 + 48 = &#x27;1&#x27;</span></span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;字符&#x27;1&#x27;转换为数字: &quot;</span> &lt;&lt; num_from_char &lt;&lt; std::endl;  <span class="comment">// 输出：1</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;数字1转换为字符: &quot;</span> &lt;&lt; char_from_int &lt;&lt; std::endl;    <span class="comment">// 输出：1</span></span><br></pre></td></tr></table></figure>

<p>这些区别在处理数值计算和字符串操作时特别重要，尤其是在：</p>
<ul>
<li>数字字符串转换为实际数值</li>
<li>格式化输出</li>
<li>文件操作</li>
<li>用户输入处理</li>
</ul>
<p>等场景中需要特别注意。</p>
<h3 id="static-cast-和-static-cast-largeValue-0xFF"><a href="#static-cast-和-static-cast-largeValue-0xFF" class="headerlink" title="static_cast 和 static_cast(largeValue &amp; 0xFF)"></a>static_cast<char> 和 static_cast<char>(largeValue &amp; 0xFF)</h3><ol>
<li><strong>简单的 static_cast<char></strong>:</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> largeValue = <span class="number">300</span>;</span><br><span class="line"><span class="type">char</span> c1 = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(largeValue);  <span class="comment">// 可能导致未定义行为</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>使用位掩码的 static_cast<char>(largeValue &amp; 0xFF)</strong>:</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> largeValue = <span class="number">300</span>;</span><br><span class="line"><span class="type">char</span> c2 = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(largeValue &amp; <span class="number">0xFF</span>);  <span class="comment">// 安全地截取最后8位</span></span><br></pre></td></tr></table></figure>

<p>主要区别：</p>
<ol>
<li><strong>数值范围处理</strong>：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> largeValue = <span class="number">300</span>;  <span class="comment">// 二进制：0000 0001 0010 1100</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法1：直接转换</span></span><br><span class="line">    <span class="type">char</span> c1 = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(largeValue);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;直接转换结果: &quot;</span> &lt;&lt; (<span class="type">int</span>)c1 &lt;&lt; std::endl;  <span class="comment">// 结果不确定</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法2：使用位掩码</span></span><br><span class="line">    <span class="type">char</span> c2 = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(largeValue &amp; <span class="number">0xFF</span>);  <span class="comment">// 只保留最后8位：0010 1100</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;位掩码转换结果: &quot;</span> &lt;&lt; (<span class="type">int</span>)c2 &lt;&lt; std::endl;  <span class="comment">// 输出：44</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>安全性比较</strong>：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">demonstrateCasting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 超出char范围的值</span></span><br><span class="line">    <span class="type">int</span> values[] = &#123;<span class="number">128</span>, <span class="number">255</span>, <span class="number">256</span>, <span class="number">300</span>, <span class="number">-129</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> val : values) &#123;</span><br><span class="line">        <span class="comment">// 直接转换 - 可能导致未定义行为</span></span><br><span class="line">        <span class="type">char</span> direct = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用位掩码 - 安全地截取最后8位</span></span><br><span class="line">        <span class="type">char</span> masked = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(val &amp; <span class="number">0xFF</span>);</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;原值: &quot;</span> &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;直接转换: &quot;</span> &lt;&lt; (<span class="type">int</span>)direct &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;位掩码转换: &quot;</span> &lt;&lt; (<span class="type">int</span>)masked &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;-------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要区别总结：</p>
<ol>
<li><p><strong>安全性</strong>：</p>
<ul>
<li><code>static_cast&lt;char&gt;</code> 在值超出 char 范围时可能导致未定义行为</li>
<li><code>static_cast&lt;char&gt;(value &amp; 0xFF)</code> 总是安全地截取最后 8 位</li>
</ul>
</li>
<li><p><strong>值范围</strong>：</p>
<ul>
<li><code>static_cast&lt;char&gt;</code> 不保证结果在 char 的有效范围内</li>
<li><code>static_cast&lt;char&gt;(value &amp; 0xFF)</code> 保证结果在 0-255 之间</li>
</ul>
</li>
<li><p><strong>使用场景</strong>：</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">example</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 适合使用直接转换的场景</span></span><br><span class="line">    <span class="type">int</span> smallValue = <span class="number">65</span>;</span><br><span class="line">    <span class="type">char</span> c1 = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(smallValue);  <span class="comment">// 转换&#x27;A&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 适合使用位掩码的场景</span></span><br><span class="line">    <span class="type">int</span> networkByte = <span class="number">0x1234</span>;</span><br><span class="line">    <span class="type">char</span> lowByte = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(networkByte &amp; <span class="number">0xFF</span>);  <span class="comment">// 获取最低字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>位操作说明</strong>：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 0xFF的作用演示</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">explainBitMask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">300</span>;  <span class="comment">// 二进制：0000 0001 0010 1100</span></span><br><span class="line">    <span class="type">int</span> masked = value &amp; <span class="number">0xFF</span>;  <span class="comment">// 0xFF = 0000 0000 1111 1111</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结果只保留最后8位：0010 1100 (44在十进制中)</span></span><br><span class="line">    <span class="type">char</span> result = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(masked);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;原始值: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;掩码后: &quot;</span> &lt;&lt; (<span class="type">int</span>)result &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建议：</p>
<ul>
<li>当确定输入值在 char 范围内时，可以使用简单的<code>static_cast&lt;char&gt;</code></li>
<li>处理可能超出范围的值时，应使用<code>static_cast&lt;char&gt;(value &amp; 0xFF)</code></li>
<li>在处理网络字节序或二进制数据时，位掩码方式特别有用</li>
</ul>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>060-cpp成员函数</title>
    <url>/2024/12/02/060-cpp%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>在 C++中，类的成员函数通常包括以下几种类型：</p>
<ol>
<li><p><strong>构造函数（Constructor）</strong>：</p>
<ul>
<li>用于初始化对象。构造函数的名称与类名相同，没有返回类型。</li>
<li>可以有多个构造函数（重载），以支持不同的初始化方式。</li>
</ul>
</li>
<li><p><strong>析构函数（Destructor）</strong>：</p>
<ul>
<li>用于清理对象。析构函数的名称是类名的前面加上波浪号（~），没有返回类型，也没有参数。</li>
<li>在对象生命周期结束时自动调用。</li>
</ul>
</li>
<li><p><strong>拷贝构造函数（Copy Constructor）</strong>：</p>
<ul>
<li>用于复制对象。通常用于对象的复制初始化。</li>
<li>形如：<code>ClassName(const ClassName &amp;other)</code></li>
</ul>
</li>
<li><p><strong>赋值运算符重载（Assignment Operator Overload）</strong>：</p>
<ul>
<li>用于对象的赋值操作。</li>
<li>形如：<code>ClassName&amp; operator=(const ClassName &amp;other)</code></li>
</ul>
</li>
<li><p><strong>移动构造函数（Move Constructor）</strong>：</p>
<ul>
<li>用于移动语义，提高性能。</li>
<li>形如：<code>ClassName(ClassName &amp;&amp;other)</code></li>
</ul>
</li>
<li><p><strong>移动赋值运算符重载（Move Assignment Operator Overload）</strong>：</p>
<ul>
<li>用于移动语义的赋值操作。</li>
<li>形如：<code>ClassName&amp; operator=(ClassName &amp;&amp;other)</code></li>
</ul>
</li>
<li><p><strong>访问器（Accessors）</strong>：</p>
<ul>
<li>用于获取对象的私有成员变量的值。</li>
<li>通常是<code>const</code>函数，不修改对象的状态。</li>
</ul>
</li>
<li><p><strong>修改器（Mutators）</strong>：</p>
<ul>
<li>用于设置对象的私有成员变量的值。</li>
<li>通常会对输入值进行验证。</li>
</ul>
</li>
<li><p><strong>静态成员函数（Static Member Functions）</strong>：</p>
<ul>
<li>不依赖于对象实例，可以通过类名直接调用。</li>
<li>不能访问非静态成员变量。</li>
</ul>
</li>
<li><p><strong>友元函数（Friend Functions）</strong>：</p>
<ul>
<li>不是类的成员，但可以访问类的私有和保护成员。</li>
<li>通过<code>friend</code>关键字声明。</li>
</ul>
</li>
<li><p><strong>虚函数（Virtual Functions）</strong>：</p>
<ul>
<li>用于实现多态行为。</li>
<li>在基类中声明为<code>virtual</code>，在派生类中可以重写。</li>
</ul>
</li>
<li><p><strong>常成员函数（Const Member Functions）</strong>：</p>
<ul>
<li>不修改对象的状态。</li>
<li>在函数声明后加上<code>const</code>关键字。</li>
</ul>
</li>
</ol>
<p>这些成员函数的具体实现和使用取决于类的设计需求和功能。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>062-const</title>
    <url>/2024/12/03/062-const/</url>
    <content><![CDATA[<h2 id="基本数据类型和字面值-直接传值-不要使用const"><a href="#基本数据类型和字面值-直接传值-不要使用const" class="headerlink" title="基本数据类型和字面值, 直接传值, 不要使用const&amp;"></a>基本数据类型和字面值, 直接传值, 不要使用<code>const&amp;</code></h2><p>在 C++中，<code>const&amp;</code>通常用于避免拷贝传递参数，尤其是对于较大的对象。然而，对于基本数据类型（如<code>int</code>、<code>float</code>等），传递它们的引用（包括<code>const&amp;</code>）通常没有太大意义，因为它们本身就很小，拷贝的开销很低。对于基本数据类型，这种做法是可以的，但并不是必要的。你可以直接传值而不是引用，尤其是当你传递的是字面值（如<code>0</code>和<code>1</code>）时。</p>
<p>即: 基本数据类型和字面值, 直接传值, 不要使用<code>const&amp;</code></p>
<h2 id="函数参数使用const"><a href="#函数参数使用const" class="headerlink" title="函数参数使用const"></a>函数参数使用<code>const</code></h2><p>在 C++中，使用<code>const</code>来修饰函数参数可以防止在函数内部修改这些参数的值。对于基本数据类型（如<code>int</code>、<code>float</code>等），使用<code>const</code>来修饰传值参数通常没有太大意义，因为传值本身就意味着在函数内部的修改不会影响到外部。</p>
<p>然而，如果你希望明确表达参数在函数内部不应被修改的意图，或者为了代码的一致性，你可以使用<code>const</code>来修饰传值参数。这样做不会影响性能或功能，但可以提高代码的可读性。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>061-右值引用</title>
    <url>/2024/12/02/061-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="左值与右值"><a href="#左值与右值" class="headerlink" title="左值与右值"></a>左值与右值</h2><p>C++ 中值有两个独立的属性：有地址的值(gvalue)和可以被移动的值(rvalue)</p>
<ol>
<li><p>有地址 + 不能移动 &#x3D; 左值(lvalue)</p>
</li>
<li><p>有地址 + 可以移动 &#x3D; 将亡值(xvalue), 包括: 右值引用类型的返回值，比如 <code>std::move(x)</code></p>
</li>
<li><p>没有地址 + 可以移动 &#x3D; 纯右值(prvalue), 包括:</p>
<ul>
<li>字面量，比如 <code>42</code></li>
<li>临时对象，比如 <code>1 + 2</code></li>
<li>this 指针</li>
</ul>
</li>
<li><p>没有地址 + 不能移动, 目前没有用到</p>
</li>
</ol>
<p>总之, 一个值是左值还是右值，取决于它的地址是否可以被获取。大多数时候只需要区分一个值是左值还是右值即可。</p>
<h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><p>右值引用是 C++11 引入的一种引用类型，用于表示对右值的引用。右值引用可以绑定到右值，但不能绑定到左值。右值引用通常用于实现移动语义和完美转发。</p>
<ul>
<li>右值引用只能绑定到右值上，比如 <code>int &amp;&amp;</code></li>
<li>左值引用只能绑定到左值上，比如 <code>int &amp;</code></li>
<li>const 的左值引用可以绑定到左值或右值上，比如 <code>const int &amp;</code></li>
</ul>
<h2 id="移动构造函数和移动赋值运算符"><a href="#移动构造函数和移动赋值运算符" class="headerlink" title="移动构造函数和移动赋值运算符"></a>移动构造函数和移动赋值运算符</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    string s&#123;&#125;;</span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt; pi&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Move constructor</span></span><br><span class="line">    <span class="built_in">Widget</span>(Widget &amp;&amp;w) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Move assignment operator</span></span><br><span class="line">    Widget &amp;<span class="keyword">operator</span>=(Widget &amp;&amp;w) = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>移动操作和异常安全</p>
<ul>
<li>移动操作一般不分配新资源，因此不会抛出异常</li>
<li>如果移动操作不抛异常，必须注明 noexcept</li>
</ul>
<h2 id="通用引用和引用折叠"><a href="#通用引用和引用折叠" class="headerlink" title="通用引用和引用折叠"></a>通用引用和引用折叠</h2><h3 id="通用引用"><a href="#通用引用" class="headerlink" title="通用引用"></a>通用引用</h3><p>通用引用是一种既可以绑定到左值，又可以绑定到右值的引用类型，其本质是一个模板参数化的右值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;  <span class="comment">// T&amp;&amp; 是通用引用</span></span><br><span class="line">    <span class="comment">// arg 既可以接受左值，也可以接受右值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h3><p>引用折叠规则:</p>
<ol>
<li><p>左值引用（&amp;）优先级高于右值引用（&amp;&amp;）。</p>
</li>
<li><p>以下是所有的折叠情况：</p>
<ul>
<li>T&amp; &amp; → T&amp;</li>
<li>T&amp; &amp;&amp; → T&amp;</li>
<li>T&amp;&amp; &amp; → T&amp;</li>
<li>T&amp;&amp; &amp;&amp; → T&amp;&amp;</li>
</ul>
</li>
</ol>
<h2 id="remove-reference"><a href="#remove-reference" class="headerlink" title="remove_reference"></a>remove_reference</h2><p>std::remove_reference 是 C++ 标准库中的一个类型特性（type trait），定义在头文件 <type_traits> 中。它的主要作用是移除类型中的引用部分（包括左值引用 &amp; 和右值引用 &amp;&amp;），返回原始类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">remove_reference</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">remove_reference</span>&lt;T&amp;&gt; &#123;</span><br><span class="line">    <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">remove_reference</span>&lt;T&amp;&amp;&gt; &#123;</span><br><span class="line">    <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>常用场景: 类型推导、模板元编程、完美转发等。</p>
<p>总结</p>
<ul>
<li>std::remove_reference 是一个编译期工具，通过模板特化对类型进行处理。</li>
<li>它不会在运行时产生临时变量，也不会涉及任何值类别的转换。</li>
<li>编译器只会根据类型推导规则替换类型，例如将 int&amp; 转换为 int，最终生成相应的代码。</li>
<li>不会去掉 const 和 volatile 修饰符</li>
</ul>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>063-模板</title>
    <url>/2024/12/03/063-%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h2 id="模板参数会保留其传入类型的所有修饰符"><a href="#模板参数会保留其传入类型的所有修饰符" class="headerlink" title="模板参数会保留其传入类型的所有修饰符"></a>模板参数会保留其传入类型的所有修饰符</h2><p>在 C++中，模板参数会保留其传入类型的所有修饰符，包括<code>const</code>和引用（<code>&amp;</code>或<code>&amp;&amp;</code>）。这意味着如果你传递一个<code>const</code>类型或引用类型作为模板参数，模板会保留这些修饰符。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T param)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// param的类型会保留T的所有修饰符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">func</span>(a); <span class="comment">// T为const int</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">func</span>(b); <span class="comment">// T为int</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>&amp; c = b;</span><br><span class="line">    <span class="built_in">func</span>(c); <span class="comment">// T为int&amp;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; d = a;</span><br><span class="line">    <span class="built_in">func</span>(d); <span class="comment">// T为const int&amp;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>func</code>函数的模板参数<code>T</code>会保留传入参数的<code>const</code>和引用修饰符。因此，<code>T</code>的类型会根据传入的参数类型而有所不同。</p>
<p>如果你希望在模板中去掉这些修饰符，可以使用标准库中的类型萃取工具，如<code>std::remove_const</code>和<code>std::remove_reference</code>。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> PlainType = <span class="keyword">typename</span> std::remove_const&lt;<span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&gt;::type;</span><br><span class="line">    <span class="comment">// PlainType是去掉const和引用后的基本类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，你可以在模板中根据需要处理类型的修饰符。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>064-数据结构</title>
    <url>/2024/12/04/064-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="常见概念"><a href="#常见概念" class="headerlink" title="常见概念"></a>常见概念</h2><h3 id="随机访问"><a href="#随机访问" class="headerlink" title="随机访问"></a>随机访问</h3><p>随机访问（Random Access）是指在数据结构中，可以在常数时间内（O(1)）直接访问任意一个元素，而不需要从头开始遍历数据结构。数组（Array）是支持随机访问的典型数据结构，因为可以通过<strong>索引</strong>(数据地址+偏移量)直接访问任意位置的元素。</p>
<p>在支持随机访问的数据结构中，元素的存储位置是连续的，这使得通过计算偏移量来直接定位元素成为可能。相比之下，链表（Linked List）不支持随机访问，因为访问某个元素需要从头开始逐个遍历，时间复杂度为 O(n)。</p>
<p>随机访问的优势在于其高效性，特别是在需要频繁访问或修改特定位置的元素时。然而，这种高效性通常是以牺牲插入和删除操作的效率为代价的，因为在数组中插入或删除元素可能需要移动大量数据。</p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="哈希表就是键值对吗"><a href="#哈希表就是键值对吗" class="headerlink" title="哈希表就是键值对吗"></a>哈希表就是键值对吗</h3><p>哈希表（Hash Table）确实是基于键值对（key-value pair）的一种数据结构。它通过一个哈希函数将键映射到一个数组中的位置，以便快速查找对应的值。以下是哈希表的一些关键特性：</p>
<ol>
<li><p><strong>键值对存储</strong>：哈希表中的每个元素都是一个键值对。键用于标识数据，值是与该键相关联的数据。</p>
</li>
<li><p><strong>快速查找</strong>：通过哈希函数，哈希表可以在平均情况下以常数时间复杂度（O(1)）进行查找、插入和删除操作。</p>
</li>
<li><p><strong>哈希冲突</strong>：由于不同的键可能映射到相同的哈希值，哈希表需要处理冲突。常见的冲突解决方法包括链地址法（使用链表存储冲突的元素）和开放地址法（在数组中寻找下一个空闲位置）。</p>
</li>
<li><p><strong>动态调整</strong>：为了保持高效性，哈希表通常会在负载因子（已存储元素数量与数组大小的比值）超过某个阈值时进行扩展和重哈希。</p>
</li>
</ol>
<p>因此，哈希表不仅仅是键值对的简单集合，它还包含了用于高效存储和检索的机制。</p>
<h3 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h3><p>哈希冲突（Hash Collision）是指在哈希表中，不同的键通过哈希函数映射到相同的哈希值或数组位置的情况。由于哈希表的核心是通过哈希函数将键映射到数组中的位置，因此冲突是不可避免的。处理哈希冲突的方法主要有以下几种：</p>
<ol>
<li><p><strong>链地址法（Separate Chaining）</strong>：</p>
<ul>
<li>在每个数组位置存储一个链表（或其他数据结构），所有映射到同一位置的元素都存储在这个链表中。</li>
<li>当发生冲突时，将新元素添加到链表中。</li>
<li>查找时，需要遍历链表来查找目标元素。</li>
</ul>
</li>
<li><p><strong>开放地址法（Open Addressing）</strong>：</p>
<ul>
<li>当发生冲突时，寻找数组中的下一个空闲位置来存储元素。</li>
<li>常见的开放地址法策略包括线性探测（Linear Probing）、二次探测（Quadratic Probing）和双重哈希（Double Hashing）。</li>
</ul>
</li>
<li><p><strong>再哈希（Rehashing）</strong>：</p>
<ul>
<li>当哈希表的负载因子超过某个阈值时，创建一个更大的哈希表，并将所有元素重新哈希到新的表中(扩容)。</li>
<li>这可以减少冲突的发生频率。</li>
</ul>
</li>
</ol>
<h4 id="扩容哈希表"><a href="#扩容哈希表" class="headerlink" title="扩容哈希表"></a>扩容哈希表</h4><p>负载因子定义为哈希表中元素数量除以桶数量，反映了哈希冲突的严重程度，常用作触发哈希表扩容的条件。</p>
<p>简单粗暴，但是效率低，因为哈希表扩容需要进行大量的数据搬运与哈希值计算。</p>
<p>改良哈希表数据结构，使得哈希表可以在出现哈希冲突时正常工作。</p>
<ul>
<li>仅在必要时，即当哈希冲突比较严重时，才执行扩容操作。</li>
<li>哈希表的结构改良方法主要包括“链式地址”和“开放寻址”。</li>
</ul>
<h4 id="链式地址的局限性"><a href="#链式地址的局限性" class="headerlink" title="链式地址的局限性"></a>链式地址的局限性</h4><ul>
<li>占用空间增大：链表包含节点指针，它相比数组更加耗费内存空间。</li>
<li>查询效率降低：因为需要线性遍历链表来查找对应元素。</li>
</ul>
<p>值得注意的是，当链表很长时，查询效率 O(n) 很差。此时可以将链表转换为“AVL 树”或“红黑树”，从而将查询操作的时间复杂度优化至 O(logn)。</p>
<h4 id="开放寻址的局限性"><a href="#开放寻址的局限性" class="headerlink" title="开放寻址的局限性"></a>开放寻址的局限性</h4><ul>
<li>线性探测容易产生“聚集现象”。数组中连续被占用的位置越长，这些连续位置发生哈希冲突的可能性越大，从而进一步促使该位置的聚堆生长，形成恶性循环，最终导致增删查改操作效率劣化。</li>
<li>负载因子不能太大，否则会降低查询效率。</li>
<li>删除元素比较麻烦，不能直接删除，需要惰性删除(lazy delete)。这是因为删除元素会在数组内产生一个空桶 None ，而当查询元素时，线性探测到该空桶就会返回，因此在该空桶之下的元素都无法再被访问到，程序可能误判这些元素不存在。<ul>
<li>惰性删除: 不直接从哈希表中移除元素，而是利用一个常量 TOMBSTONE 来标记这个桶。在该机制下，None 和 TOMBSTONE 都代表空桶，都可以放置键值对。但不同的是，线性探测到 TOMBSTONE 时应该继续遍历，因为其之下可能还存在键值对。</li>
</ul>
</li>
</ul>
<p>请注意，开放寻址（线性探测、平方探测和多次哈希）哈希表都存在“不能直接删除元素”的问题。</p>
<h3 id="怎么理解哈希的输入空间通常远大于输出空间（数组长度）"><a href="#怎么理解哈希的输入空间通常远大于输出空间（数组长度）" class="headerlink" title="怎么理解哈希的输入空间通常远大于输出空间（数组长度）"></a>怎么理解哈希的输入空间通常远大于输出空间（数组长度）</h3><p>哈希函数的输入空间通常远大于输出空间的原因在于，哈希函数需要将一个非常大的输入集合（如所有可能的字符串或整数）映射到一个相对较小的输出集合（如哈希表的数组索引）。这种映射过程不可避免地会导致哈希冲突，因为多个不同的输入可能会被映射到相同的输出值。</p>
<h4 id="理解这一点的几个关键点"><a href="#理解这一点的几个关键点" class="headerlink" title="理解这一点的几个关键点"></a>理解这一点的几个关键点</h4><ol>
<li><p><strong>输入空间的广泛性</strong>：</p>
<ul>
<li>输入空间可以是非常大的集合。例如，所有可能的字符串组合、所有可能的整数等。这些集合的大小通常是无限的或非常大的。</li>
</ul>
</li>
<li><p><strong>输出空间的有限性</strong>：</p>
<ul>
<li>输出空间是哈希表的大小，即数组的长度。这个长度是有限的，因为计算机的内存是有限的，哈希表的大小通常是一个固定的数值。</li>
</ul>
</li>
<li><p><strong>映射的必要性</strong>：</p>
<ul>
<li>哈希函数的作用是将大输入空间映射到小输出空间，以便在有限的内存中高效地存储和检索数据。</li>
</ul>
</li>
<li><p><strong>冲突的不可避免性</strong>：</p>
<ul>
<li>由于输入空间远大于输出空间，必然会有不同的输入映射到相同的输出值，这就是哈希冲突。</li>
</ul>
</li>
</ol>
<h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><p>假设你有一个哈希表，其数组长度为 1000（输出空间），而你需要存储的可能输入是所有可能的 32 位整数（输入空间）。32 位整数的可能值有 2^32 个（约 43 亿），显然远大于 1000。因此，多个不同的整数可能会映射到同一个数组索引，导致冲突。</p>
<p>这种映射机制是哈希表设计中的一个基本挑战，处理冲突的方法（如链地址法和开放地址法）就是为了解决这个问题。</p>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>递: 向下<br>归: 向上</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆是一种特殊的树形数据结构，其中每个节点都满足特定的堆性质。堆通常用于实现优先队列（Priority Queue），因为它可以高效地支持插入和删除操作，同时保持元素的有序性。</p>
<p>堆有两种主要类型：</p>
<ul>
<li>最大堆（Max Heap）：在最大堆中，每个节点的值都大于或等于其子节点的值。</li>
<li>最小堆（Min Heap）：在最小堆中，每个节点的值都小于或等于其子节点的值。</li>
</ul>
<p>Q：数据结构的“堆”与内存管理的“堆”是同一个概念吗？</p>
<p>两者不是同一个概念，只是碰巧都叫“堆”。</p>
<p>数据结构的“堆”是基于数组实现的树形数据结构，而内存管理的“堆”是内存管理机制。</p>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>065-cpp-sleep</title>
    <url>/2024/12/12/065-cpp-sleep/</url>
    <content><![CDATA[<h3 id="C-休眠函数"><a href="#C-休眠函数" class="headerlink" title="C++ 休眠函数"></a>C++ 休眠函数</h3><p>让我用中文解释这两种休眠方式的区别：</p>
<ol>
<li><code>std::this_thread::sleep_for</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>)); <span class="comment">// C++11 方式</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这是 C++11 引入的现代休眠方法</li>
<li>跨平台兼容性好</li>
<li>可以使用不同的时间单位（毫秒、微秒、秒等）</li>
<li>提供类型安全</li>
<li>可以与其他 C++时间相关的功能无缝配合</li>
<li>精度依赖于操作系统实现</li>
</ul>
<ol start="2">
<li><code>usleep</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">usleep</span>(<span class="number">100000</span>); <span class="comment">// 参数单位是微秒</span></span><br></pre></td></tr></table></figure>

<ul>
<li>POSIX 系统的传统 C 函数</li>
<li>只在 UNIX&#x2F;Linux 系统上可用</li>
<li>只接受微秒作为参数单位</li>
<li>参数类型是无符号整数</li>
<li>在某些系统上已经被废弃</li>
<li>可能会被信号中断</li>
</ul>
<p>建议：</p>
<ol>
<li>在现代 C++代码中，推荐使用<code>std::this_thread::sleep_for</code></li>
<li>如果是只针对 UNIX&#x2F;Linux 的老代码，<code>usleep</code>也是可以接受的</li>
<li>如果需要高精度定时，两者都不够理想，应该考虑使用专门的实时编程方案</li>
</ol>
<p>示例对比：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 现代C++方式，休眠100毫秒</span></span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统方式，休眠100毫秒</span></span><br><span class="line"><span class="built_in">usleep</span>(<span class="number">100</span> * <span class="number">1000</span>);  <span class="comment">// 需要自己转换单位</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>067-read/write和recv/send的区别</title>
    <url>/2024/12/28/067-read-write%E5%92%8Crecv-send%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p><code>read()</code>&#x2F;<code>write()</code> 和 <code>recv()</code>&#x2F;<code>send()</code> 是用于数据传输的系统调用，但它们有一些区别：</p>
<ol>
<li><p><strong>通用性</strong>：</p>
<ul>
<li><code>read()</code> 和 <code>write()</code> 是通用的 I&#x2F;O 操作函数，可以用于文件、管道、套接字等各种文件描述符。</li>
<li><code>recv()</code> 和 <code>send()</code> 专门用于套接字操作，提供了一些额外的功能。</li>
</ul>
</li>
<li><p><strong>功能性</strong>：</p>
<ul>
<li><code>recv()</code> 和 <code>send()</code> 可以指定额外的标志（flags），如 <code>MSG_DONTWAIT</code>、<code>MSG_PEEK</code> 等，这些标志可以改变函数的行为。</li>
<li><code>read()</code> 和 <code>write()</code> 没有这些额外的标志。</li>
</ul>
</li>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>recv()</code> 和 <code>send()</code> 的参数中包含一个 <code>flags</code> 参数，用于指定操作的行为。</li>
<li><code>read()</code> 和 <code>write()</code> 没有 <code>flags</code> 参数。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>：</p>
<ul>
<li>在网络编程中，通常使用 <code>recv()</code> 和 <code>send()</code>，因为它们提供了更灵活的控制。</li>
<li>对于文件 I&#x2F;O，通常使用 <code>read()</code> 和 <code>write()</code>。</li>
</ul>
</li>
</ol>
<p>总结来说，<code>recv()</code> 和 <code>send()</code> 是为网络编程设计的，提供了更多的控制选项，而 <code>read()</code> 和 <code>write()</code> 是更通用的 I&#x2F;O 操作函数。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title>066-生产者消费者模型</title>
    <url>/2024/12/13/066-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>要实现 SCPI 回复与请求的匹配，可以考虑使用生产者-消费者模式或线程间同步机制。以下是一个简化的实现思路：</p>
<ol>
<li><strong>使用队列</strong>：可以使用一个线程安全的队列来存储请求和对应的回复。</li>
<li><strong>生产者线程</strong>：负责发送 SCPI 命令并将请求信息（如请求 ID）放入队列。</li>
<li><strong>消费者线程</strong>：负责从队列中取出请求信息，等待并接收对应的回复。</li>
</ol>
<p>以下是一个简化的代码示例，展示如何使用 C++的线程和队列来实现这一模式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::queue&lt;std::pair&lt;<span class="type">int</span>, std::string&gt;&gt; request_queue;</span><br><span class="line">std::mutex queue_mutex;</span><br><span class="line">std::condition_variable queue_cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Producer</span><span class="params">(<span class="type">int</span> request_id, <span class="type">const</span> std::string&amp; command)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line">        request_queue.<span class="built_in">push</span>(&#123;request_id, command&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    queue_cv.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line">        queue_cv.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> !request_queue.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> request = request_queue.<span class="built_in">front</span>();</span><br><span class="line">        request_queue.<span class="built_in">pop</span>();</span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> request_id = request.first;</span><br><span class="line">        std::string command = request.second;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟发送命令并接收回复</span></span><br><span class="line">        std::string reply = <span class="string">&quot;Reply for &quot;</span> + command; <span class="comment">// 假设这是接收到的回复</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理回复</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Request ID: &quot;</span> &lt;&lt; request_id &lt;&lt; <span class="string">&quot;, Reply: &quot;</span> &lt;&lt; reply &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumer_thread</span><span class="params">(Consumer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟发送请求</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">Producer</span>(i, <span class="string">&quot;SCPI Command &quot;</span> + std::<span class="built_in">to_string</span>(i));</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    consumer_thread.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul>
<li><strong>生产者线程</strong>：<code>Producer</code>函数模拟发送 SCPI 命令，并将请求 ID 和命令放入队列。</li>
<li><strong>消费者线程</strong>：<code>Consumer</code>函数从队列中取出请求，模拟接收回复，并输出结果。</li>
<li><strong>线程同步</strong>：使用<code>std::mutex</code>和<code>std::condition_variable</code>来确保线程安全和同步。</li>
</ul>
<p>在实际应用中，你需要根据具体的 SCPI 命令和回复机制来调整代码，确保请求和回复能够正确匹配。可能还需要处理超时、错误等情况。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>068-单例模式</title>
    <url>/2025/01/10/068-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>单例模式是一种设计模式，确保一个类只有一个实例，并提供一个全局访问点。</p>
<span id="more"></span>

<h2 id="懒汉模式-Meyers’-Singleton"><a href="#懒汉模式-Meyers’-Singleton" class="headerlink" title="懒汉模式(Meyers’ Singleton)"></a>懒汉模式(Meyers’ Singleton)</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">static</span> Singleton obj;  <span class="comment">// 静态局部变量</span></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>; <span class="comment">// 显示拒绝拷贝构造和复制构造</span></span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="通用化"><a href="#通用化" class="headerlink" title="通用化"></a>通用化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> T&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> T t;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton instance;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton Singleton::instance;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>开箱即用</tag>
      </tags>
  </entry>
  <entry>
    <title>070-cpp提升效率的操作</title>
    <url>/2025/01/15/070-cpp%E6%8F%90%E5%8D%87%E6%95%88%E7%8E%87%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<span id="more"></span>

<ul>
<li>传递引用或者指针</li>
<li>使用 std::move 进行移动语义, 通过所有权的转移, 减少拷贝</li>
<li>使用 std::forward 进行完美转发</li>
</ul>
<h2 id="编译期优化"><a href="#编译期优化" class="headerlink" title="编译期优化"></a>编译期优化</h2><ul>
<li>内联函数 inline</li>
<li>模板和编译期常量计算<ul>
<li>使用模板元编程或 constexpr 将某些操作推迟到编译期，避免运行时计算。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">0</span> ? <span class="number">1</span> : n * <span class="built_in">factorial</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>避免不必要的动态分配<ul>
<li>尽量使用自动存储（栈）而非动态分配（堆），因为堆分配的开销更大。</li>
<li>使用标准容器（如 std::vector）时，可以通过 reserve 提前分配足够的内存。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">vec.<span class="built_in">reserve</span>(<span class="number">100</span>); <span class="comment">// 提前分配 100 个元素的内存</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>避免虚函数的性能开销<ul>
<li>如果类不需要继承和多态，尽量避免使用虚函数。</li>
<li>使用 final 关键字声明不可被继承的类，帮助编译器进行优化。</li>
</ul>
</li>
<li>使用轻量级数据结构<ul>
<li>选择合适的数据结构，如 std::array 代替 std::vector 用于固定大小的数组。</li>
<li>如果键值较少且固定，std::unordered_map 比 std::map 快。</li>
</ul>
</li>
</ul>
<h2 id="运行期优化"><a href="#运行期优化" class="headerlink" title="运行期优化"></a>运行期优化</h2><ul>
<li>使用移动语义<ul>
<li>在可能的情况下，使用移动构造函数和移动赋值运算符避免拷贝开销。</li>
<li>配合 std::move 显式触发移动语义。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::string str1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">std::string str2 = std::<span class="built_in">move</span>(str1);  <span class="comment">// 移动而不是拷贝</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>智能指针管理资源<ul>
<li>使用 std::unique_ptr 和 std::shared_ptr 代替裸指针，可以提高资源管理效率，避免内存泄漏。</li>
<li>如果对象的生命周期明确，std::unique_ptr 的开销比 std::shared_ptr 更小。</li>
</ul>
</li>
<li>减少不必要的拷贝<ul>
<li>函数参数传递时，优先选择按引用传递而非按值传递。</li>
</ul>
</li>
<li>缓存优化<ul>
<li>数据访问尽量具有局部性（时间局部性和空间局部性），减少缓存未命中。</li>
<li>避免频繁分配和释放小块内存。</li>
</ul>
</li>
<li>并行化和多线程<ul>
<li>使用 C++ 标准库中的多线程工具（如 std::thread、std::async）提高并行执行效率。</li>
<li>结合线程池（如 std::thread_pool 或自定义线程池）处理高并发任务。</li>
</ul>
</li>
<li>避免不必要的同步<ul>
<li>在多线程场景中，避免对低冲突或读多写少的资源使用过多锁。</li>
<li>使用无锁数据结构（如 std::atomic）或读写锁提高效率。</li>
</ul>
</li>
</ul>
<p>总结</p>
<ul>
<li>代码设计：选择合适的数据结构和算法是效率优化的基础。</li>
<li>语言特性：利用 C++ 的现代特性（如移动语义、智能指针、constexpr）。</li>
<li>资源管理：减少不必要的分配与拷贝，合理使用线程和同步。</li>
<li>工具分析：结合性能分析工具，找到关键性能瓶颈，优化热点代码。</li>
</ul>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>移动语义与完美转发</title>
    <url>/2025/01/15/069-%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E4%B8%8E%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// std::move 的实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type &amp;&amp;<span class="title">move</span><span class="params">(T &amp;&amp;param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> ReturnType = <span class="keyword">typename</span> remove_reference&lt;T&gt;::type &amp;&amp;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;ReturnType&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 remove_reference 去掉 T 的引用性质（并不会去掉 cv 限定符），然后给它加上 &amp;&amp;，形成 ReturnType 类型，由于右值引用类型的返回值是右值，因此结果是实参被无条件地转换为右值。</p>
<p>如果没有定义移动构造函数，则使用拷贝构造函数。</p>
<p>std::move 是一个模板函数，用于将对象转换为右值引用。它并不直接对对象、值或内存进行任何实际的移动操作。std::move 的作用是告诉编译器可以“窃取”对象的资源，因为对象不再需要保持其原始状态。</p>
<ol>
<li>对象转换：std::move 将一个左值（通常是一个命名对象）转换为右值引用。这种转换允许你调用对象的移动构造函数或移动赋值运算符。</li>
<li>资源转移：在使用 std::move 后，通常会调用对象的移动构造函数或移动赋值运算符，这些函数负责实际的资源转移（如指针、动态内存、文件句柄等）。</li>
<li>内存管理：std::move 本身不管理内存。内存的管理和资源的转移由移动构造函数或移动赋值运算符负责。</li>
<li>std::move 通常用于将左值转换为右值引用，以便能够调用对象的移动构造函数或移动赋值运算符。然而，对于纯右值（即临时对象或字面值），std::move 通常是不必要并且多余的，因为它们本身已经是右值。</li>
</ol>
<h2 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h2><p>保留参数的值类别（左值、右值），是否为 const 或 volatile 修饰符，并将其传递给其他函数。</p>
<p>std::forward 的实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> T &gt;</span></span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp; t)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> T &gt;</span></span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp;&amp; t)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="怎么判断该用-move-还是-forward？"><a href="#怎么判断该用-move-还是-forward？" class="headerlink" title="怎么判断该用 move 还是 forward？"></a>怎么判断该用 move 还是 forward？</h2><ul>
<li>对右值引用 move<br>右值引用只能绑定到右值上，所以可以无条件地将它转换为右值</li>
<li>对通用引用 forward<br>通用引用既能绑定到左值上，也能绑定到右值上，在后一种情况下，我们希望能将它转换为右值</li>
<li>在右值引用上调用 std::forward 表现出的行为是正确的，但由于 std::forward 没法自动做类型推导，写出来的代码会比较繁琐；但如果在通用引用上调用 std::move，可能会导致左值被错误地修改，导致异常的行为。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.cnblogs.com/ljx-null/p/16512384.html">移动语义和完美转发浅析</a></li>
</ul>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>开箱即用</tag>
      </tags>
  </entry>
  <entry>
    <title>071-windows编译运行c++项目</title>
    <url>/2025/01/16/071-windows%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8Ccpp%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li>windows 11</li>
<li>cmake 3.31.0</li>
<li>mingw 8.1.0</li>
<li>vscode 1.86.1</li>
<li>vscode 插件<ul>
<li>CMake Tools（提供 CMake 支持）</li>
<li>C&#x2F;C++（提供代码补全和调试支持）</li>
<li>Code Runner（可选，用于快速运行程序）</li>
</ul>
</li>
</ul>
<p>环境配置参考 <a href="007_windows%E4%B8%8B%E6%90%AD%E5%BB%BACpp%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83.md">007-windows 下搭建 Cpp 编译环境</a></p>
<h2 id="步骤一-Create-a-project"><a href="#步骤一-Create-a-project" class="headerlink" title="步骤一: Create a project"></a>步骤一: Create a project</h2><p>创建一个 cpp 项目</p>
<h2 id="步骤二-Configure-a-project"><a href="#步骤二-Configure-a-project" class="headerlink" title="步骤二: Configure a project"></a>步骤二: Configure a project</h2><h3 id="2-1-创建-CMakeLists-txt"><a href="#2-1-创建-CMakeLists-txt" class="headerlink" title="2.1 创建 CMakeLists.txt"></a>2.1 创建 CMakeLists.txt</h3><ol>
<li>CMake: Quick Start</li>
<li>输入项目名</li>
<li>选择创建 c++项目</li>
<li>选择 CTest 作为测试支持, 也可以选择 CPack 来打包</li>
<li>创建可执行文件 Executable 或者 Library</li>
</ol>
<h3 id="2-2-创建-CMakePresets-json"><a href="#2-2-创建-CMakePresets-json" class="headerlink" title="2.2 创建 CMakePresets.json"></a>2.2 创建 CMakePresets.json</h3><p>创建 CMakePresets.json 预设配置</p>
<ol>
<li>创建新的预设</li>
<li>从编译器创建, 选择本地编译器 MinGW</li>
<li>命名预设</li>
</ol>
<p>或者选择已有预设配置</p>
<p>注: 此时应该生成了 CMakeLists.txt 和 CMakePresets.json 文件</p>
<h3 id="2-3-两者的关系"><a href="#2-3-两者的关系" class="headerlink" title="2.3 两者的关系"></a>2.3 两者的关系</h3><ol>
<li><p>CMakeLists.txt 是核心，cmakepresets.json 是辅助配置文件：</p>
<ul>
<li>CMakeLists.txt 决定了项目如何构建，包含了所有的构建规则。</li>
<li>cmakepresets.json 定义了如何调用 CMake 来处理这些规则。</li>
</ul>
</li>
<li><p>cmakepresets.json 简化了构建配置：</p>
<ul>
<li>开发者无需记住或输入复杂的命令行参数，可以直接选择预设。</li>
<li>预设适用于不同的开发环境、构建目标或用户配置。</li>
</ul>
</li>
<li><p>工作流程:</p>
<ul>
<li>CMake 读取 cmakepresets.json 来确定配置选项和生成器。</li>
<li>根据选定的预设调用 CMakeLists.txt，生成相应的构建系统。</li>
</ul>
</li>
<li><p>兼容性:</p>
<ul>
<li>cmakepresets.json 在 CMake 3.19 引入，推荐使用 CMake 3.21 或更高版本以获得更好的支持。</li>
<li>如果没有 cmakepresets.json，则可以通过命令行参数直接配置 CMake。</li>
</ul>
</li>
</ol>
<h2 id="步骤三-Build-a-project"><a href="#步骤三-Build-a-project" class="headerlink" title="步骤三: Build a project"></a>步骤三: Build a project</h2><h3 id="3-1-选择-CMake-Preset"><a href="#3-1-选择-CMake-Preset" class="headerlink" title="3.1 选择 CMake Preset"></a>3.1 选择 CMake Preset</h3><ol>
<li>打开 VSCode 的命令面板, 输入 CMake: Select Configure Preset。</li>
<li>选择 default（或你定义的其他 preset 名称）。</li>
</ol>
<h3 id="3-2-配置项目"><a href="#3-2-配置项目" class="headerlink" title="3.2 配置项目"></a>3.2 配置项目</h3><ol>
<li>打开命令面板, 输入 CMake: Configure。</li>
<li>VSCode 会自动运行 cmake，并根据你的 CMakePresets.json 配置项目。</li>
</ol>
<p>注: 生成 build 文件夹</p>
<h3 id="3-3-构建项目"><a href="#3-3-构建项目" class="headerlink" title="3.3 构建项目"></a>3.3 构建项目</h3><ol>
<li>打开命令面板, 输入 CMake: Build。</li>
<li>VSCode 会调用 CMake，使用 MinGW 编译你的项目。</li>
</ol>
<p>注: 构建成功显示 Build complete</p>
<h2 id="步骤四-Run-a-project"><a href="#步骤四-Run-a-project" class="headerlink" title="步骤四: Run a project"></a>步骤四: Run a project</h2><ol>
<li>打开命令面板, 输入 CMake: Run。</li>
<li>VSCode 会调用 CMake，使用 MinGW 编译你的项目。</li>
</ol>
<p>注: 运行成功会在 build 目录下生成可执行文件</p>
<h2 id="步骤五-调试"><a href="#步骤五-调试" class="headerlink" title="步骤五: 调试"></a>步骤五: 调试</h2><ol>
<li>确保你的项目生成了可执行文件（通常位于 build 文件夹）。</li>
<li>运行 -&gt; 启动调试 -&gt; 选择调试器 g++ -&gt; 生成 .&#x2F;vscode&#x2F;tasks.json</li>
<li>点击创建 launch.json</li>
<li>配置 launch.json（用于调试）： 打开 .vscode&#x2F;launch.json，并添加以下内容：</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Debug&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/build/your_program_name.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:/Software/mingw/mingw64/bin/gdb.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Enable pretty-printing for gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>启动调试：<ul>
<li>在调试面板点击“启动调试”（绿色三角形）。</li>
</ul>
</li>
</ol>
<p>补充：CMake 工具栏<br>在 VSCode 的状态栏下方，你可以看到由 CMake Tools 扩展提供的工具栏：</p>
<ul>
<li>[Select Kit]：选择编译器（一般选择 MinGW）。</li>
<li>[Build]：一键构建。</li>
<li>[Debug]：直接运行调试。</li>
</ul>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title>072-spdlog使用方法</title>
    <url>/2025/02/11/072-spdlog%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>Very fast, header only, C++ logging library.</p>
<span id="more"></span>

<ol>
<li><p>spdlog 的 github 项目地址 <a href="https://github.com/gabime/spdlog">https://github.com/gabime/spdlog</a></p>
</li>
<li><p>在右侧的 <code>releases</code> 中下载 Latest 版本.</p>
</li>
<li><p>解压后，将 <code>include</code> 目录下的 <code>spdlog</code> <strong>文件夹</strong>拷贝到项目中。注意: <code>spdlog</code>不是单头文件，而是文件夹。</p>
</li>
<li><p>在 <code>main.cpp</code> 中添加如下内容:</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spdlog/spdlog.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>生成 CMake</p>
<ul>
<li>5.1 CMake: Qucik Start</li>
<li>5.2 输入项目名</li>
<li>5.3 选择创建 c++项目</li>
<li>5.4 选择 CTest 作为测试支持, 也可以选择 CPack 来打包</li>
<li>5.5 创建可执行文件 Executable 或者 Library</li>
<li>5.6 选择或创建预设配置</li>
</ul>
</li>
<li><p>在 <code>CMakeLists.txt</code> 中添加如下内容:</p>
</li>
</ol>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置 spdlog 头文件路径，确保 spdlog 目录在根路径</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(hello PRIVATE <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>)</span><br></pre></td></tr></table></figure>

<p><code>Linux</code> 环境下, 在 <code>build</code> 目录下 <code>cmake .. &amp;&amp; make -j</code></p>
<ol start="7">
<li>运行 <code>hello</code> 程序</li>
</ol>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
</search>
